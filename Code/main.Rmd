---
title: "SCLC Analysis"
author: "Andrew Willems & Tian Hong"
date: "2023-04-05"
output: html_document
---

```{r setup, include=FALSE}
# This sets the global chunk options for knitr to display the R code.
knitr::opts_chunk$set(
  echo = TRUE
)

# This sets the root directory for knitr to the project directory.
knitr::opts_knit$set(root.dir = "~/Documents/Work/Phd_program/hong_lab/Projects/sclc/")
```

## SCLC Analysis

# Loading needed packages
```{r load needed packages}
# cowplot: for making publication-ready plots in R
# data.table: for efficient data manipulation and manipulation of large datasets
# DESeq2: a single-cell differentially-expressed (DE) method
# DEsingle: a single-cell differentially-expressed (DE) method
# devtools: for developing R packages and managing dependencies
# doParallel: for parallel computing
# edgeR: a single-cell differentially-expressed (DE) method
# GGally: for making parallel coordinate plots
# forestplot: for visualizing Cox model coefficients 
# ggplot2: for data visualization and making high-quality, customizable plots
# glmnet: for fitting generalized linear models via penalized maximum likelihood
# hoardeR: for caching data to disk and improving the speed of data access
# igraph: for network analysis and visualization
# Matrix: for efficient manipulation and calculation with dense and sparse matrices
# monocle3: for single-cell RNA-seq analysis and visualization
# parallel: for running parallel computations in R
# phateR: for visualizing high-dimensional data in a 2D plot
# pwr: for power analysis calculations
# reticulate: for running Python code in R and vice versa
# retry: for allowing us to repeatedly restart code due to timeouts or errors
# Rmagic: for running R code in Jupyter notebooks
# scDD: Another method for doing DE of genes
# SingleCellExperiment: For building special data objects used by many single-cell data analysis tools
# styler: for consistent code formatting and styling
# survival: for survival analysis and modeling
# survminer: for visualization of survival analysis results and data
# svglite: for creating vector graphics in R
# switchde: for differential expression analysis of RNA-seq data using a Bayesian framework
# tidyverse: for data manipulation, visualization, and analysis using a consistent set of tools and syntax
# viridis: for creating color palettes for data visualization that are perceptually uniform and easy to interpret
# zinbwave: for DESeq2 pre-processing

pacman::p_load(
  cowplot, coxed, data.table, DESeq2, DEsingle, devtools, doParallel, easystats, edgeR, foreach, forestplot, ggforce, GGally, ggplot2, glmnet, hoardeR, igraph, Matrix, monocle3, parallel, phateR, progress, pwr, reticulate, retry, Rmagic, scDD, SingleCellExperiment, styler, survival, survminer, survsim, svglite, switchde, tidyverse, viridis, zinbwave
)
```

# Setting up Conda environment that is needed for MAGIC
```{r miniconda setup for MAGIC}
# Loading conda environment 'r-reticulate' for MAGIC package
use_condaenv("/Users/andrewwillems/Library/r-miniconda-arm64/envs/r-reticulate")
```

# Sourcing external R files that contain needed functions
```{r sourcing needed functions}
# This code sources several R scripts that contain functions used for analyzing miRNA expression data in small cell lung cancer (SCLC).
# The 'cox_model.R' script contains a function for performing a Cox proportional hazards model on the data.
# The 'km_plotter.R' script contains a function for creating a Kaplan-Meier plot to visualize survival data.
# The 'lung_mirna_calculator.R' script contains functions for preprocessing and normalizing the miRNA expression data.
# The 'risk_score_calculator.R' script contains a function for calculating a risk score for each patient based on the results of the Cox model.
# The 'main.Rmd' markdown notebook contains all the code for the SCLC analysis for the paper.
# This code also sources 'cell_dataset_builder.R', which contains functions for building a dataset from processed scRNA-seq expression data.

invisible(lapply(list.files("Code", pattern = "\\.R$", full.names = TRUE), source))
```

# Loading bulk SCLC data from U of Cologne that contains survival information
```{r loading data}
# Link to paper: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4861069/
# Link to data: https://www.cbioportal.org/study/summary?id=sclc_ucologne_2015
# Paper title for data: Comprehensive genomic profiles of small cell lung cancer by George et al.
# Load gene expression data from a file and select relevant columns
scl_df <- read.csv(
  file = "Data/sclc_ucologne_2015/data_mrna_seq_rpkm.txt",
  sep = "\t"
)
scl_df <- subset(scl_df,
  select = c(Hugo_Symbol, sclc_ucologne_2015_S00022:sclc_ucologne_2015_S02397)
)

# Clean up column names by removing prefix
colnames(scl_df) <- sub("^sclc_ucologne_2015_S", "", colnames(scl_df))

# Load clinical data for patients and clean up column names and values
scl_patient <- read.csv(
  file = "Data/sclc_ucologne_2015/data_clinical_patient.txt",
  sep = "\t"
)

scl_patient <- scl_patient %>%
  slice(5:121) %>%
  rename(
    Patient.ID = X.Patient.Identifier, Overall.Survival.Status = Overall.Survival.Status,
    Overall.Survival.Months. = Overall.Survival..Months., Smoker = Smoker, Progress.Free.Survival.Months. = Progress.Free.Survival..Months., Acquisition.Method = First.Pathologic.Diagnosis.Biospecimen.Acquisition.Method.Type, Age = Diagnosis.Age, Radiation = Radiation.Therapy
  ) %>%
  select(Patient.ID, Sex, Overall.Survival.Status, Overall.Survival.Months., Progress.Free.Survival.Months., Smoker, Chemotherapy, Neoadjuvant.Chemotherapy, N.Stage, M.Stage, UICC.Tumor.Stage, Acquisition.Method, Age, Radiation) %>%
  filter(Smoker != "Never") %>%
  filter(Smoker != "") %>%
  mutate(
    Smoker = as.factor(Smoker),
    Smoker = if_else(Smoker == "Current", true = 1, false = 0)
  ) %>%
  mutate(Overall.Survival.Status = ifelse(Overall.Survival.Status == "1:DECEASED", 1, 0)) %>%
  rename(
    vital.status = Overall.Survival.Status,
    time = Overall.Survival.Months.
  ) %>%
  mutate(Patient.ID = gsub(
    x = Patient.ID,
    pattern = "sclc_ucologne_2015_S",
    replacement = ""
  )) %>%
  mutate(vital.status_new = as.numeric(vital.status)) %>%
  mutate(time_new = as.numeric(time)) %>%
  select(-vital.status, -time) %>%
  rename(
    vital.status = vital.status_new,
    time = time_new
  ) %>%
  mutate(time = time * 30) %>%
  filter(time != 0) %>%
  mutate(Progress.Free.Survival.Months. = ifelse(Progress.Free.Survival.Months. == "", NA, Progress.Free.Survival.Months.)) %>%
  rename_all(tolower)
# Uncomment this line for the progress free analysis
# filter(!is.na(progress.free.survival.months.)) %>%
# rename(time2 = progress.free.survival.months.) %>%
# mutate(time2 = as.numeric(time2)) %>%
# mutate(time2 = time2 * 30)


# Extract the list of gene symbols
scl_genes <- scl_df$Hugo_Symbol

# Find the list of patients that have data for both gene expression and clinical data
common_patients <- intersect(scl_patient$patient.id, colnames(scl_df))


# Select only the common columns from gene expression data and transpose it
# so that each row corresponds to a patient
scl_common <- scl_df %>%
  select(all_of(common_patients)) %>%
  t() %>%
  as.data.frame()

# Assign the gene symbols as column names
colnames(scl_common) <- scl_genes

# Remove duplicated columns and add patient ID as a column
scl_common <- scl_common %>%
  select(-which(duplicated(names(.)))) %>%
  rownames_to_column(var = "patient.id")

# Join the gene expression data with the clinical data for each patient
scl_common <- left_join(scl_common, scl_patient[, c(
  "sex", "smoker",
  "vital.status", "time",
  "patient.id", "n.stage", "m.stage", "uicc.tumor.stage",
  "chemotherapy", "neoadjuvant.chemotherapy", "acquisition.method",
  "age", "radiation"
)],
by = "patient.id"
) %>%
  rename_all(tolower) %>%
  select(
    patient.id, age, sex, smoker, vital.status, time, n.stage, m.stage,
    uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy, radiation, 
    acquisition.method,  everything()
  )

# Removing intermediate files to keep the environment clean
rm(scl_df, scl_patient, scl_genes, common_patients)
```

# Loading and pre-processing single-cell data
```{r single-cell data loading}
# Read in the gene expression data and filter out columns that start with
# "SCLC_P1" or "SCLC_P14" because they have been treated with cancer
# treatment and we don't want it to affect our analysis
# Data from: https://ngdc.cncb.ac.cn/omix/release/OMIX002441
# Paper title for data: Single-cell transcriptomic profiling reveals the tumor heterogeneity of small-cell lung cancer by Yanhua Tian
sc_df <- fread("Data/OMIX002441-01.csv")
sc_df <- sc_df %>%
  select(-matches("^(SCLC_P1|SCLC_P14)")) %>%
  t() # transpose the data frame to have cells as rows

# Set column names to the first row of the data frame
colnames(sc_df) <- sc_df["V1", ]
sc_df <- sc_df[-1, ] # remove first row, which is now redundant
sc_df <- as.data.frame(sc_df)

# Read in the metadata and filter for tumor samples only
meta_data <- fread("Data/OMIX002441-02.csv")

# Test to try and combine NT column info with patient info
meta_data <- meta_data %>%
  mutate(V1 = paste0(V1, "_", NT))

meta_data <- meta_data %>%
  filter(NT == "tumor")

# Set row names to the first column, which contains the cell IDs
colnames(meta_data)[1] <- "id"

# Join the two dataframes on the "id" column
sc_df$id <- rownames(sc_df)
sc_df <- inner_join(sc_df, meta_data, by = "id")
rownames(sc_df) <- sc_df$id
sc_df <- sc_df %>%
  mutate(id = paste0(id, "_", NT, "_", cell_type))

rownames(sc_df) <- sc_df$id

sc_df <- sc_df %>% select(
  -id, -patient, -NT, -tissue, -cell_type,
  -nCount_RNA, -nFeature_RNA, -Pre_Map_Reads,
  -Aligned_Reads, -MappingRate
)

# Keep only genes that are expressed in at least 10 cells
keep_cols <- colSums(sc_df > 0) > 10
sc_df <- sc_df[, keep_cols]

sc_rownames <- rownames(sc_df)

# Convert the data frame to integers
sc_df <- apply(sc_df, c(1, 2), as.integer) %>%
  as.data.frame()

rownames(sc_df) <- sc_rownames

# Plot the distribution of library sizes
p1 <- ggplot() +
  geom_histogram(aes(x = rowSums(sc_df)), bins = 50) +
  geom_vline(xintercept = 1000, color = "red") +
  theme(
    panel.background = element_blank(),
    axis.title = element_text(size = 22, face = "bold"),
    axis.text = element_text(size = 20),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.ticks = element_line(linewidth = 1.25),
    axis.ticks.length = unit(0.2, units = "cm"),
    axis.line = element_line(color = "black", linewidth = 1.25),
    plot.subtitle = element_text(hjust = 0.5, size = 22)
  ) +
  ggtitle("Distribution of Library Sizes in scRNA-seq",
    subtitle = "Library size distribution after filtering genes with positive expression in at least 10 cells."
  ) +
  xlab("Library Size") +
  ylab("Count") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0))

# Saving to PNG format
ggsave(
  plot = p1, width = 20, height = 20, units = "in", dpi = 600,
  device = "png", filename = "sc_library_distribution_sizes.png", path = "Outputs/"
)

# Saving to SVG format
ggsave(
  plot = p1, width = 20, height = 20, units = "in", dpi = 600,
  device = "svg", filename = "sc_library_distribution_sizes.svg", path = "Outputs/"
)

# Keep only cells with a library size between 1000 and 15000
keep_rows <- rowSums(sc_df) > 1000 & rowSums(sc_df) < 15000
sc_df <- sc_df[keep_rows, ]

# Normalize the library size and take the square root of the expression values
sc_df <- library.size.normalize(sc_df)
sc_df <- sqrt(sc_df)

# Removing intermediate files to keep the environment tidy
rm(keep_cols, keep_rows, sc_rownames, p1)
```

# Single-cell denoising with MAGIC
```{r single-cell denoising}
# Convert the sc_df dataframe to a matrix
sc_df_mat <- as.matrix(sc_df)

# Generate a random seed based on system time
# Seed is: 1688576604
# seed <- as.integer(Sys.time())

# Apply the MAGIC (Model-based Analysis of Genome-wide CRISPR/Cas9 Knockout) algorithm to denoise the scRNA-seq data.
# The 'genes' parameter specifies the set of genes to use for MAGIC imputation. Here, 'all_genes' is used to include all genes in the analysis.
# The 'seed' parameter specifies a random seed for reproducibility.
# The 'n.jobs' parameter specifies the number of cores to use for parallelization. Setting it to -1 indicates that all available cores should be used.
sc_denoised <- magic(sc_df_mat, genes = "all_genes", seed = 1688405764, n.jobs = -1)

# Saving the denoised matrix
saveRDS(sc_denoised, "Outputs/denoised_sc_data_new_random_seed.rds")

# Removing intermediate files to keep environment tidy
rm(sc_df_mat)
```

# Pseudotime generation with Monocle3
```{r generating pseudotime from single-cell data}
sc_denoised$result <- sc_denoised$result %>%
  t()

meta_data <- meta_data %>%
  filter(id %in% colnames(sc_denoised$result)) %>%
  column_to_rownames(var = "id")

cds_cell_meta <- meta_data
cds_gene_meta <- data.frame(gene_short_name = rownames(sc_denoised$result))
rownames(cds_gene_meta) <- cds_gene_meta$gene_short_name

emt_genes <- read.csv("Data/emt_genes_tian.txt", sep = "\t")

# Getting common genes between EMT list and our list
common_emt_genes <- intersect(cds_gene_meta$gene_short_name, emt_genes$Gene)
common_emt_genes <- data.frame(gene_short_name = common_emt_genes)
rownames(common_emt_genes) <- common_emt_genes$gene_short_name

cds_output <- cell_dataset_builder(
  gene_expression = "TUBA1A",
  cell_data = sc_denoised$result,
  gene_meta = cds_gene_meta,
  cell_meta = cds_cell_meta,
  pt_root = "Y_7",
  gene_title = "TUBA1A",
  pt_title = "TUBA1A",
  point_size = 2.5,
  norm_flag = "none",
  use_ordering_funct = FALSE,
  cds_filename = "Outputs/cds.rds",
  plot_file = "Outputs/emt_gene_expression.png",
  pt_file = "Outputs/pt_expression.png",
  pt_data_filename = "Outputs/TUBA1A_pseudotime_data.csv"
)

# Bringing the cell expression and pseudotime graphs together into a single plot
combo_plot <- ggarrange(cds_output$Cell_Progression_Graph, cds_output$PT_Graph,
  ncol = 2, nrow = 1, align = "h", labels = c("A", "B"),
  legend = "bottom", font.label = c(size = 18)
)

combo_plot <- combo_plot + ggtitle("SDE Pseudotime Ordering") +
  theme(
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5, size = 9)
  )


# Saving to PNG
ggsave(
  plot = combo_plot, device = "png", dpi = 600, width = 7, height = 5,
  units = "in", filename = "Outputs/sde_foundation_plot_new_random_seed.png", bg = "white"
)

# Saving to SVG
ggsave(
  plot = combo_plot, device = "svg", dpi = 600, width = 7, height = 5,
  units = "in", filename = "Outputs/sde_foundation_plot_new_random_seed.svg", bg = "white"
)
```

# Calculating and saving SDE metric
```{r sde metric}
sde_genes <- switchde_calculator(sc_denoised$result,
  pseudo_time = cds_output$PT_Data
)

saveRDS(sde_genes, "Outputs/sde_genes_new_random_seed.rds")

head(sde_genes)
```

# Finding ideal number of genes for SDE metric
```{r ideal gene number for sde metric}
sde_genes <- readRDS("Outputs/sde_genes_new_random_seed.rds")
gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1
for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 1,
    cox_predictors = sde_genes,
    cox_df = scl_common,
    gene_num = gn,
    n_folds = 10,
    calc_auc = FALSE,
    save_coefs = FALSE,
    verbose = FALSE,
    cat_preds = FALSE,
    my_folds = NULL
  )
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  write.csv(cindex_df, paste0("Outputs/sde/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_new_random_seed.csv"))
  counter <- counter + 1
}


# Now seeing what the best c-index is
all_sde_cindices <- read_files(folder_path = "Outputs/sde/", pattern = "*_new_random_seed.csv")
all_sde_cindices_sub <- all_sde_cindices %>% filter(cindex_active_genes < 8)
max_sde_cindex <- all_sde_cindices_sub[which.max(all_sde_cindices_sub$cindex), ] # 0.7034 with 4 active genes with new random seed
max_sde_cindex <- all_sde_cindices[which.max(all_sde_cindices$cindex), ] # 0.7221 with 7 active genes with initial 123 random seed
```

# Calculating and saving MAD metric
```{r mad metric}
mad_genes <- mad_calculator(sc_denoised$result)
saveRDS(mad_genes, "Outputs/mad_genes_new_random_seed.rds")
head(mad_genes)
```

# Finding ideal gene size for MAD metric
```{r ideal gene size for mad}
gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1
for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(my_seed = 1688405764,
                                  my_alpha = 1,
                                  cox_predictors = mad_genes,
                                  cox_df = scl_common,
                                  gene_num = gn,
                                  n_folds = 10, 
                                  calc_auc = FALSE,
                                  save_coefs = FALSE,
                                  verbose = FALSE,
                                  cat_preds = FALSE)
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  write.csv(cindex_df, paste0("Outputs/mad/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_new_random_seed.csv"))
  counter <- counter + 1
}


# Now seeing what the best c-index is
all_mad_cindices <- read_files(folder_path = "Outputs/mad/", pattern = "*.csv")
max_mad_cindex <- all_mad_cindices[which.max(all_mad_cindices$cindex), ] # 0.7718 with 13 active genes
all_mad_cindices_sub <- all_mad_cindices %>% filter(cindex_active_genes == 7 | cindex_active_genes == 8) # 0.7221 with 7 active genes
```

# C-index of small miRNA set
```{r mirna with small number of active genes cindex}
file_list <- list.files(path = "Outputs/mirna/rds", pattern = "*.rds", full.names = TRUE)
file_list <- file_list[!grepl("_mat_", file_list)]

gene_sizes <- seq(2, 8, 1)
cox_outputs <- list()
counter <- 1
for (f in file_list) {
  print(f)
  for (gn in gene_sizes) {
    current_mirna_met <- readRDS(paste0(f))
    current_cox <- cox_model_fitter(my_seed = 1, my_alpha = 1, cox_predictors = current_mirna_met, cox_df = scl_common, gene_num = gn, n_folds = 10, calc_auc = FALSE, save_coefs = FALSE, verbose = FALSE, cat_preds = FALSE)
    cox_outputs[[counter]] <- current_cox
    mirna_genes <- str_extract(f, "(?<=mirna_genes_)\\d+")
    mirnas <- str_extract(f, "(?<=mirnas_)\\d+")
    cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/mirna/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_mirnas_", mirnas, "_targets_", mirna_genes, ".csv"))
    counter <- counter + 1
  }
}
```

# Finding performance of the small miRNA set
```{r loading in all mirna outputs for small size and finding performance}
# Now seeing what the best c-index is
all_mirna_cindices <- read_files(folder_path = "Outputs/mirna/glmnet/", pattern = "*.csv")
max_mirna_cindex <- all_mirna_cindices[which.max(all_mirna_cindices$cindex), ] #  0.7560 with 5 active genes
```

```{r df of individual metrics}
all_individual_met_df <- bind_rows(max_mirna_cindex, max_sde_cindex, all_mad_cindices_sub[1, ])
all_individual_met_df <- all_individual_met_df %>%
  mutate(metric = c("mirna", "sde", "mad"))
```

# Cancer clinical staging Cox model 
```{r generate a cox model with just the cancer staging to see performance}
scl_patient <- read.csv(
  file = "Data/sclc_ucologne_2015/data_clinical_patient.txt",
  sep = "\t"
)

scl_patient <- scl_patient %>%
  slice(5:121) %>%
  rename(
    Patient.ID = X.Patient.Identifier, Overall.Survival.Status = Overall.Survival.Status,
    Overall.Survival.Months. = Overall.Survival..Months., Smoker = Smoker
  ) %>%
  select(Patient.ID, Sex, Overall.Survival.Status, Overall.Survival.Months., Smoker, Sex, Ethnicity.Category, N.Stage, M.Stage, UICC.Tumor.Stage, Chemotherapy, Neoadjuvant.Chemotherapy) %>%
  filter(Smoker != "Never") %>%
  filter(Smoker != "") %>%
  mutate(
    Smoker = as.factor(Smoker),
    Smoker = if_else(Smoker == "Current", true = 1, false = 0)
  ) %>%
  mutate(Overall.Survival.Status = ifelse(Overall.Survival.Status == "1:DECEASED", 1, 0)) %>%
  rename(
    vital.status = Overall.Survival.Status,
    time = Overall.Survival.Months.
  ) %>%
  mutate(Patient.ID = gsub(
    x = Patient.ID,
    pattern = "sclc_ucologne_2015_S",
    replacement = ""
  )) %>%
  mutate(vital.status_new = as.numeric(vital.status)) %>%
  mutate(time_new = as.numeric(time)) %>%
  select(-vital.status, -time) %>%
  rename(
    vital.status = vital.status_new,
    time = time_new
  ) %>%
  mutate(time = time * 30) %>%
  filter(time != 0) %>%
  rename_all(tolower)

scl_clinical_only <- scl_patient %>%
  mutate(n.stage = ifelse(n.stage == "", NA, n.stage)) %>%
  mutate(m.stage = ifelse(m.stage == "", NA, m.stage)) %>%
  filter(!is.na(ethnicity.category) & !is.na(n.stage) & !is.na(m.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ia", 1, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "I", 1, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ib", 1, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IB", 1, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIa", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IV", 4, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "iib", 2, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "iia", 2, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "iiia", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "iiib", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIa", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIb", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIa", 2, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIb", 2, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "II", 2, uicc.tumor.stage)) %>%
  mutate(n.stage = ifelse(n.stage == "1a", 1, n.stage)) %>%
  mutate(n.stage = ifelse(n.stage == "1b", 1, n.stage)) %>%
  mutate(n.stage = ifelse(n.stage == "X", "x", n.stage)) %>%
  mutate(m.stage = ifelse(m.stage == "1a", 1, m.stage)) %>%
  mutate(m.stage = ifelse(m.stage == "1b", 1, m.stage))

surv_y <- Surv(time = scl_clinical_only$time, event = scl_clinical_only$vital.status, type = "right")
clinical_cox_only <- coxph(data = scl_clinical_only, formula = surv_y ~ n.stage + m.stage + uicc.tumor.stage)
summary_clinical <- summary(clinical_cox_only)
clinical_staging_only_cindex <- round(as.numeric(as.vector(summary_clinical$concordance["C"])), digits = 4) # 0.6205 with 9 active predictors
clinical_staging_only_cindex_se <- round(as.numeric(as.vector(summary_clinical$concordance["se(C)"])), digits = 4)

clinical_staging_only_df <- data.frame(X = 1, cindex = clinical_staging_only_cindex, cindex_se = clinical_staging_only_cindex_se, cindex_active_genes = 9, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "clinical_staging")
# Adding staging c-index to df of other individual metrics
all_individual_met_df <- bind_rows(all_individual_met_df, clinical_staging_only_df)
```

# Random gene Cox performance
```{r random gene selection}
scl_common <- scl_common %>%
  select(
    -patient.id, -sex, -smoker, -vital.status, -time, -n.stage, -m.stage,
    -uicc.tumor.stage, -chemotherapy, -neoadjuvant.chemotherapy
  )

# Function to randomly sample genes from the dataset
sample_genes <- function(df, n_genes, n_samples = 1000) {
  gene_names <- colnames(df)
  n_genes <- min(n_genes, length(gene_names))
  samples <- lapply(1:n_samples, function(x) {
    df %>%
      select(sample(gene_names, n_genes, replace = FALSE)) %>%
      rename_all(tolower)
  })
  return(samples)
}


# set.seed(123)
set.seed(1688405764)
sampled_genes <- sample_genes(df = scl_common, n_genes = 7, n_samples = 1000)

# Re-loading the scl file so that we can include the meta data
scl_patient <- read.csv(
  file = "Data/sclc_ucologne_2015/data_clinical_patient.txt",
  sep = "\t"
)

scl_patient <- scl_patient %>%
  slice(5:121) %>%
  rename(
    Patient.ID = X.Patient.Identifier, Overall.Survival.Status = Overall.Survival.Status,
    Overall.Survival.Months. = Overall.Survival..Months., Smoker = Smoker
  ) %>%
  select(Patient.ID, Sex, Overall.Survival.Status, Overall.Survival.Months., Smoker, Sex) %>%
  filter(Smoker != "Never") %>%
  filter(Smoker != "") %>%
  mutate(
    Smoker = as.factor(Smoker),
    Smoker = if_else(Smoker == "Current", true = 1, false = 0)
  ) %>%
  mutate(Overall.Survival.Status = ifelse(Overall.Survival.Status == "1:DECEASED", 1, 0)) %>%
  rename(
    vital.status = Overall.Survival.Status,
    time = Overall.Survival.Months.
  ) %>%
  mutate(Patient.ID = gsub(
    x = Patient.ID,
    pattern = "sclc_ucologne_2015_S",
    replacement = ""
  )) %>%
  mutate(vital.status_new = as.numeric(vital.status)) %>%
  mutate(time_new = as.numeric(time)) %>%
  select(-vital.status, -time) %>%
  rename(
    vital.status = vital.status_new,
    time = time_new
  ) %>%
  mutate(time = time * 30) %>%
  filter(time != 0) %>%
  rename_all(tolower)


# Extract the list of gene symbols
scl_genes <- scl_df$Hugo_Symbol

# Find the list of patients that have data for both gene expression and clinical data
common_patients <- intersect(scl_patient$patient.id, colnames(scl_df))

# Select only the common columns from gene expression data and transpose it
# so that each row corresponds to a patient
scl_common <- scl_df %>%
  select(all_of(common_patients)) %>%
  t() %>%
  as.data.frame()

# Assign the gene symbols as column names
colnames(scl_common) <- scl_genes

# Remove duplicated columns and add patient ID as a column
scl_common <- scl_common %>%
  select(-which(duplicated(names(.)))) %>%
  rownames_to_column(var = "patient.id")

# Join the gene expression data with the clinical data for each patient
scl_common <- left_join(scl_common, scl_patient[, c(
  "vital.status", "time",
  "patient.id"
)],
by = "patient.id"
) %>%
  rename_all(tolower) %>%
  select(
    patient.id, vital.status, time, everything()
  )


counter <- 1
cox_outputs <- list()
for (g in sampled_genes) {
  current_genes <- g
  current_cox <- cox_model_fitter(my_seed = 1, my_alpha = 1, cox_predictors = current_genes, cox_df = scl_common, gene_num = 7, n_folds = 10, calc_auc = FALSE, save_coefs = FALSE, verbose = FALSE, cat_preds = FALSE)
  cox_outputs[[counter]] <- current_cox

  if (is.null(current_cox)) {
    next
  } else {
    cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/random_genes/glmnet_7_genes_glmnet_index_", cindex_index, "_lambda_", lambda, ".csv"))
    counter <- counter + 1
  }
}


# Combining all files together
all_random_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/random_genes/", pattern = "*.csv")
mean_random_cindices <- mean(all_random_cindices$cindex) # 0.606116
random_genes_only_df <- data.frame(X = 1, cindex = mean_random_cindices, cindex_se = NA, cindex_active_genes = NA, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "random_genes")
all_individual_met_df <- bind_rows(all_individual_met_df, random_genes_only_df)
write.csv(all_individual_met_df, "Outputs/all_individual_metrics_cindex.csv")
```

# Getting miRNA targeting info to make miRNA metric
```{r mirna}
# Now sending those miRNAs to TargetScan
mirna_num <- seq(100, 800, 100)
mirna_target_num <- seq(2, 8, 1)
for (m in mirna_num[1:4]) {
  for (t in mirna_target_num[1:7]) {
    mirna_genes <- mirna_calculator(ts_org = "Human", ts_version = "8.0", max_mir_targets = t, cancer_up = TRUE, cancer_type1 = "lung cancer", print_ts_targets = FALSE, status = "up", max_mirnas = m, mirna_genes_mat_name = paste0("Outputs/mirna/mirna_genes_mat_", m, "_mirnas_", t, "_targets_up.csv"), mirna_ranking_name = paste0("Outputs/mirna/mirna_genes_", m, "_mirnas_", t, "_targets_up_.csv"), mirna_ranking_name_rds = paste0("Outputs/mirna/mirna_genes_", m, "_mirnas_", t, "_targets_up_.rds"), mirna_genes_mat_name_rds = paste0("Outputs/mirna/mirna_genes_mat_", m, "_mirnas_", t, "_targets_up.rds"))
  }
}
```


# miRNA scores with site conservation info
```{r mirna score with conservation info}
# Now sending those miRNAs to TargetScan with conservation info
mirna_num <- seq(100, 800, 100)
mirna_target_num <- seq(2, 8, 1)
for (m in mirna_num[1:4]) {
  for (t in mirna_target_num[1:7]) {
    mirna_genes <- mirna_calculator(ts_org = "Human", ts_version = "8.0", max_mir_targets = t, cancer_up = TRUE, cancer_type1 = "lung cancer", print_ts_targets = FALSE, status = "up", max_mirnas = m, include_sites_score = TRUE, mirna_genes_mat_name = paste0("Outputs/mirna/mirna_genes_mat_", m, "_mirnas_", t, "_targets_up_site_score.csv"), mirna_ranking_name = paste0("Outputs/mirna/mirna_genes_", m, "_mirnas_", t, "_targets_up_site_score.csv"), mirna_ranking_name_rds = paste0("Outputs/mirna/mirna_genes_", m, "_mirnas_", t, "_targets_up_site_score.rds"), mirna_genes_mat_name_rds = paste0("Outputs/mirna/mirna_genes_mat_", m, "_mirnas_", t, "_targets_up_site_score.rds"), save_site_score = TRUE, mirna_site_score_name = paste0("Outputs/mirna/mirna_genes_mat_", m, "_mirnas_", t, "_targets_up_site_score_output.csv"))
  }
}
```

# Determining highest scoring miRNAs from our best miRNA gene signature
```{r best miRNA score from gene signature}
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
mirna_genes_site_score <- read.csv("Outputs/mirna/mirna_genes_mat_200_mirnas_5_targets_up_site_score_output.csv")

tfrc_mirnas <- mirna_genes_site_score %>%
  mutate(gene = tolower(gene)) %>%
  filter(gene == "tfrc")


fam83f_mirnas <- mirna_genes_site_score %>%
  mutate(gene = tolower(gene)) %>%
  filter(gene == "fam83f")


samd12_mirnas <- mirna_genes_site_score %>%
  mutate(gene = tolower(gene)) %>%
  filter(gene == "samd12")


grin2b_mirnas <- mirna_genes_site_score %>%
  mutate(gene = tolower(gene)) %>%
  filter(gene == "grin2b")


dlk1_mirnas <- mirna_genes_site_score %>%
  mutate(gene = tolower(gene)) %>%
  filter(gene == "dlk1")

gng13_mirnas <- mirna_genes_site_score %>%
  mutate(gene = tolower(gene)) %>%
  filter(gene == "gng13")



cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
```


## Combinations of metrics
# MAD + SDE
```{r mad + sde}
sde_genes <- readRDS("Outputs/sde_genes.rds")
mad_genes <- readRDS("Outputs/mad_genes.rds")

# Optimize the weights of the MAD + SDE metrics
mad_sde_optimized <- two_weight_optimizer(
  first.metric = mad_genes,
  second.metric = sde_genes,
  my.start = 0,
  my.finish = 1,
  step.size = 0.1,
  my.filename = paste0("Outputs/Optimization_mad_sde_1_alpha.rds")
)

gene_sizes <- seq(2, 8, 1)
counter <- 1
for (ms in mad_sde_optimized) {
  for (gs in gene_sizes) {
    current_cox <- cox_model_fitter(
      my_seed = 1,
      my_alpha = 1,
      cox_predictors = ms,
      cox_df = scl_common,
      gene_num = gs,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10
    )
    cindex <- current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/mad_sde/cindex_", gs, "_mad_sde_optimized_", counter, ".csv"))
    active_genes_df <- as.data.frame(cbind(current_cox$`Active Genes`, current_cox$`Active Coefficients`))
    colnames(active_genes_df) <- c("gene", "coef")
    write.csv(active_genes_df, paste0("Outputs/glmnet_coefs/mad_sde/cindex_", gs, "_mad_sde_optimized_", counter, "_active_coefs_df.csv"))
    counter <- counter + 1
  }
}

all_mad_sde_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/mad_sde/", pattern = "*.csv")
max_mad_sde_cindices <- all_mad_sde_cindices[which.max(all_mad_sde_cindices$cindex), ] # 0.7201824 with 3 active predictors
```

# miRNA + SDE
```{r mirna + sde}
sde_genes <- readRDS("Outputs/sde_genes.rds")
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
gene_sizes <- seq(2, 8, 1)
counter <- 1

# Optimizing the weights
mirna_sde_optimized <- two_weight_optimizer(
  first.metric = mirna_genes,
  second.metric = sde_genes,
  my.start = 0,
  my.finish = 1,
  step.size = 0.1,
  my.filename = paste0("Outputs/Optimization_mirna_sde_1_alpha.rds")
)

for (ms in mirna_sde_optimized) {
  for (gs in gene_sizes) {
    current_cox <- cox_model_fitter(
      my_seed = 1,
      my_alpha = 1,
      cox_predictors = ms,
      cox_df = scl_common,
      gene_num = gs,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10
    )
    cindex <- current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/mirna_sde/cindex_", gs, "_mirna_sde_optimized_", counter, ".csv"))
    active_genes_df <- as.data.frame(cbind(current_cox$`Active Genes`, current_cox$`Active Coefficients`))
    colnames(active_genes_df) <- c("gene", "coef")
    write.csv(active_genes_df, paste0("Outputs/glmnet_coefs/mirna_sde/cindex_", gs, "_mirna_sde_optimized_", counter, "_active_coefs_df.csv"))
    counter <- counter + 1
  }
}

all_mirna_sde_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/mirna_sde/", pattern = "*.csv")
max_mirna_sde_cindices <- all_mirna_sde_cindices[which.max(all_mirna_sde_cindices$cindex), ] # 0.7560 with 5 active predictors
```

# miRNA + MAD
```{r mad + mirna}
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
mad_genes <- readRDS("Outputs/mad_genes.rds")

# Optimize the weights of the MAD + SDE metrics
mad_mirna_optimized <- two_weight_optimizer(
  first.metric = mad_genes,
  second.metric = mirna_genes,
  my.start = 0,
  my.finish = 1,
  step.size = 0.1,
  my.filename = paste0("Outputs/Optimization_mad_mirna_1_alpha.rds")
)

gene_sizes <- seq(2, 8, 1)
counter <- 1
for (ms in mad_mirna_optimized) {
  for (gs in gene_sizes) {
    current_cox <- cox_model_fitter(
      my_seed = 1,
      my_alpha = 1,
      cox_predictors = ms,
      cox_df = scl_common,
      gene_num = gs,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10
    )
    cindex <- current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/mirna_mad/cindex_", gs, "_mirna_mad_optimized_", counter, ".csv"))
    active_genes_df <- as.data.frame(cbind(current_cox$`Active Genes`, current_cox$`Active Coefficients`))
    colnames(active_genes_df) <- c("gene", "coef")
    write.csv(active_genes_df, paste0("Outputs/glmnet_coefs/mirna_mad/cindex_", gs, "_mirna_mad_optimized_", counter, "_active_coefs_df.csv"))
    counter <- counter + 1
  }
}

all_mirna_mad_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/mirna_mad/", pattern = "*.csv")
max_mirna_mad_cindices <- all_mirna_mad_cindices[which.max(all_mirna_mad_cindices$cindex), ] # 0.7559976 with 5 active predictors
```

# miRNA + MAD + SDE
```{r mirna + mad + sde}
sde_genes <- readRDS("Outputs/sde_genes.rds")
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
mad_genes <- readRDS("Outputs/mad_genes.rds")
gene_sizes <- seq(2, 8, 1)
counter <- 1

# Optimizing the weights
mirna_mad_sde_optimized <- three_weight_optimizer(
  first.metric = mirna_genes,
  second.metric = sde_genes,
  third.metric = mad_genes,
  my.start = 0,
  my.finish = 1,
  step.size = 0.1,
  my.filename = paste0("Outputs/Optimization_mirna_mad_sde_1_alpha.rds")
)

for (ms in mirna_mad_sde_optimized) {
  for (gs in gene_sizes) {
    current_cox <- cox_model_fitter(
      my_seed = 1,
      my_alpha = 1,
      cox_predictors = ms,
      cox_df = scl_common,
      gene_num = gs,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10
    )
    cindex <- current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/mirna_mad_sde/cindex_", gs, "_mirna_mad_sde_optimized_", counter, ".csv"))
    active_genes_df <- as.data.frame(cbind(current_cox$`Active Genes`, current_cox$`Active Coefficients`))
    colnames(active_genes_df) <- c("gene", "coef")
    write.csv(active_genes_df, paste0("Outputs/glmnet_coefs/mirna_mad_sde/cindex_", gs, "_mirna_mad_sde_optimized_", counter, "_active_coefs_df.csv"))
    counter <- counter + 1
  }
}

all_mirna_mad_sde_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/mirna_mad_sde/", pattern = "*.csv")
max_mirna_mad_sde_cindices <- all_mirna_mad_sde_cindices[which.max(all_mirna_mad_sde_cindices$cindex), ] # 0.76910 with 6 active predictors
```

# Attempting to generate several synthetic datasets based on our original survival distribution
```{r 1000 reps for bootstrap for comparison}
# set.seed(1)
set.seed(1688405764)
# Assume your original dataset is named `data` and it has a column named `vital.status`
# Get the distribution of the vital status column
vital_status_dist <- table(scl_common$vital.status)

# Create a function to generate bootstrap samples
bootstrap_func <- function(data) {
  # Randomly sample with replacement from the original data
  bootstrap_sample <- sample_n(data, nrow(data), replace = TRUE)
  return(bootstrap_sample)
}


# Generate 1000 datasets using bootstrap sampling that match the distribution of the vital status column
bootstrap_datasets <- replicate(1000,
  {
    # Create an empty data frame to store the bootstrap samples
    bootstrap_data <- data.frame()

    # Loop through each unique value in the vital status column and generate a bootstrap sample for each value
    for (i in seq_along(vital_status_dist)) {
      # Subset the original data to only include rows with the current value of the vital status column
      current_data <- scl_common %>% filter(vital.status == names(vital_status_dist)[i])

      # Calculate the number of rows needed for the bootstrap sample
      n_rows <- vital_status_dist[i]

      # Generate a bootstrap sample for the current value of the vital status column
      bootstrap_sample <- bootstrap_func(current_data)

      # Add the bootstrap sample to the empty data frame
      bootstrap_data <- rbind(bootstrap_data, bootstrap_sample[1:n_rows, ])
    }

    return(bootstrap_data)
  },
  simplify = FALSE
)
```

# Now taking our 1000 datasets and testing the 6 predictors we have identified and seeing how they perform
```{r for 1000 simulations of 10 fold cv on mirna + mad + sde}
cox_outputs <- list()
counter <- 1
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    # my_seed = 1,
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# Extract the mean cross-validated performance for each fold at the minimum lambda value
# Foldids to reproduce 10-fold CV splits is c(3 2  5  5  3  2  4 7  2  8  2 10  7  9  1  1  7  9  4  6 10  6  1  7  8  3  2  3  7  9  5  5  1  9  4 10  9 10  5  1  8 10  4  3  6  1  3  8  6  8  2  5  9  2  3  1 10  4  2  4  7  7  4  6  8  6  5 10  9  8  1  6)
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# Calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7204482 with the 6 active predictors from mad + sde + miRNA when using random seed of 1. When using a much more random seed (1688405764) I get a mean performance of 0.7243224
```

# MAD on 1000 simulated datasets
```{r now doing the same with MAD to ensure fair comparison}
cox_outputs <- list()
counter <- 1
cox_preds <- mad_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    # my_seed = 1,
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6212627 with the 5 active predictors from MAD. 0.6193778 with much more random seed. Foldid: 3  2  5  5  3  2  4  7  2  8  2 10  7  9  1  1  7  9  4  6 10  6  1  7  8  3  2  3  7  9  5  5  1  9  4 10  9 10  5  1  8 10  4  3  6  1  3  8  6  8  2  5  9  2  3  1 10  4  2  4  7  7  4  6  8  6  5 10  9  8  1  6
```

# SDE on 1000 simulated datasets
```{r now doing the same with SDE to ensure fair comparison}
cox_outputs <- list()
counter <- 1
cox_preds <- sde_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    # my_seed = 1,
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 7,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6746058 with the 7 active predictors from SDE. 0.6747798 with much larger random number. Foldids: 3  2  5  5  3  2  4  7  2  8  2 10  7  9  1  1  7  9  4  6 10  6  1  7  8  3  2  3  7  9  5  5  1  9  4 10  9 10  5  1  8 10  4  3  6  1  3  8  6  8  2  5  9  2  3  1 10  4  2  4  7  7  4  6  8  6  5 10  9  8  1  6
```

# miRNA on 1000 simulated datasets
```{r now doing the same with miRNA to ensure fair comparison}
cox_outputs <- list()
counter <- 1
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
cox_preds <- mirna_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    # my_seed = 1,
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    my_folds = NULL,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6920965 with the 5 active predictors from miRNA. 0.6982779 with more random seed
# Foldid:  3  2  5  5  3  2  4  7  2  8  2 10  7  9  1  1  7  9  4  6 10  6  1  7  8  3  2  3  7  9  5  5  1  9  4 10  9 10  5  1  8 10  4  3  6  1  3  8  6  8  2  5  9  2  3  1 10  4  2  4  7  7  4  6  8  6  5 10  9  8  1  6
```

# miRNA + SDE on 1000 simulated datasets
```{r mirna + sde 1000}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("znf460", "tfrc", "fam83f", "samd12", "grin2b"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    # my_seed = 1,
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6907635 with the 5 active predictors from miRNA + SDE. 0.6973343 with more random seed. Foldid: 3  2  5  5  3  2  4  7  2  8  2 10  7  9  1  1  7  9  4  6 10  6  1  7  8  3  2  3  7  9  5  5  1  9  4 10  9 10  5  1  8 10  4  3  6  1  3  8  6  8  2  5  9  2  3  1 10  4  2  4  7  7  4  6  8  6  5 10  9  8  1  6
```

# miRNA + MAD on 1000 simulated datasets
```{r mirna + mad 1000}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("znf460", "tfrc", "fam83f", "samd12", "grin2b"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    # my_seed = 1,
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6907635 with the 5 active predictors from miRNA + MAD. 0.6973343 for
# better random number. Foldid: 3  2  5  5  3  2  4  7  2  8  2 10  7  9  1  1  7  9  4  6 10  6  1  7  8  3  2  3  7  9  5  5  1  9  4 10  9 10  5  1  8 10  4  3  6  1  3  8  6  8  2  5  9  2  3  1 10  4  2  4  7  7  4  6  8  6  5 10  9  8  1  6
```

# MAD + SDE on 1000 simulated datasets
```{r mad + sde 1000}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("dlk1", "arl6ip1", "ube2c"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    # my_seed = 1,
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 3,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6958149 with the 3 active predictors from MAD + SDE. 0.6965589 for
# . better random seed. Foldid: 3  2  5  5  3  2  4  7  2  8  2 10  7  9  1  1  7  9  4  6 10  6  1  7  8  3  2  3  7  9  5  5  1  9  4 10  9 10  5  1  8 10  4  3  6  1  3  8  6  8  2  5  9  2  3  1 10  4  2  4  7  7  4  6  8  6  5 10  9  8  1  6
```

# Clinical Staging on 1000 simulated datasets
```{r clinical staging 1000}
# Function to efficiently simplify tumor staging
modify_dataframe <- function(df) {
  df <- df %>%
    mutate(n.stage = factor(gsub("[A-Za-z]", "", n.stage))) %>%
    mutate(m.stage = factor(gsub("[A-Za-z]", "", m.stage))) %>%
    mutate(n.stage = ifelse(n.stage == "", NA, n.stage)) %>%
    mutate(m.stage = ifelse(m.stage == "", NA, m.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "I", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ia", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ib", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ic", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IA", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IB", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IC", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "II", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIa", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIb", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIc", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIA", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIB", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIC", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "III", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIa", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIb", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIc", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIA", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIB", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIC", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IV", 4, uicc.tumor.stage)) %>%
    filter(!is.na(n.stage)) %>%
    filter(!is.na(m.stage)) %>%
    filter(!is.na(uicc.tumor.stage))

  return(df)
}

cox_outputs <- list()
counter <- 1
cox_preds <- c("n.stage", "m.stage", "uicc.tumor.stage")
bootstrap_datasets_clinical <- bootstrap_datasets
bootstrap_datasets_clinical <- lapply(bootstrap_datasets_clinical, modify_dataframe)

for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    # my_seed = 1,
    my_seed = 1688405764,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 3,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7081862 with the 3 active predictors from miRNA
```


# Plot for individual metrics for overall survival with initial dataset perforamnce
```{r combining all overall survival cindicies together for first panel}
all_individual_met_df <- read.csv("Outputs/all_individual_metrics_cindex.csv")
mirna_mad_only_df <- data.frame(X = 1, cindex = 0.7559976, cindex_se = NA, cindex_active_genes = 5, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "mirna_mad")
all_individual_met_df <- bind_rows(all_individual_met_df, mirna_mad_only_df)
mirna_mad_sde_only_df <- data.frame(X = 1, cindex = 0.76910, se = NA, cindex_active_genes = 6, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "mirna_mad_sde")
all_individual_met_df <- bind_rows(all_individual_met_df, mirna_mad_sde_only_df)
mirna_sde_only_df <- data.frame(X = 1, cindex = 0.7560, cindex_se = NA, cindex_active_genes = 5, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "mirna_sde")
all_individual_met_df <- bind_rows(all_individual_met_df, mirna_sde_only_df)
mad_sde_only_df <- data.frame(X = 1, cindex = 0.7201824, cindex_se = NA, cindex_active_genes = 3, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "mad_sde")
all_individual_met_df <- bind_rows(all_individual_met_df, mad_sde_only_df)
write.csv(all_individual_met_df, "Outputs/all_individual_metrics_cindex.csv")

# Starting plotting code
all_individual_metrics_cindex$metric <- factor(all_individual_metrics_cindex$metric, levels = c("mad", "sde", "mirna", "clinical_staging", "random_genes", "mad_sde", "mirna_mad", "mirna_sde", "mirna_mad_sde"), labels = c("M", "S", "miR", "CS", "RG", "MS", "miRM", "miRS", "miRMS"))

all_individual_metrics_cindex <- all_individual_metrics_cindex %>%
  select(cindex, metric) %>%
  mutate(cindex = round(cindex, digits = 4))


p1 <- ggplot(data = all_individual_metrics_cindex, aes(x = metric, y = cindex, fill = metric, color = metric)) +
  geom_col(width = 0.4) +
  geom_text(aes(label = round(cindex, 2), y = cindex + 0.01),
    size = 4,
    position = position_dodge(width = 0.4), color = "black"
  ) +
  theme(
    panel.background = element_blank(),
    axis.title = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 14),
    axis.text.x = element_text(angle = 45, vjust = 0.7),
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.ticks.length = unit(0.2, units = "cm"),
    legend.position = "none",
    axis.ticks = element_line(color = "black", linewidth = 0.75)
  ) +
  xlab("Metric") +
  ylab("Mean 10-fold CV C-index") +
  ggtitle("Single Dataset | Overall Survival") +
  scale_y_continuous(expand = c(0, 0))
p1 <- p1 + coord_cartesian(ylim = c(0.5, 0.8)) +
  scale_fill_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef")) +
  scale_color_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef"))
p1

# Save to PNG
ggsave(p1, device = "png", filename = "figure_a_panel_a.png", path = "Figures/panels/", width = 8, height = 8, dpi = 600, units = "in")

# Save to SVG
ggsave(p1, device = "svg", filename = "figure_a_panel_a.svg", path = "Figures/panels/", width = 8, height = 8, dpi = 600, units = "in")
```

# Plot for individual metrics for overall survival with 1,000 simulated datasets performance
```{r combining all overall survival cindicies together for second panel}
plot_df <- data.frame(metric = c("M", "S", "miR", "CS", "MS", "miRM", "miRS", "miRMS"), cindex = c(0.6212627, 0.6746058, 0.6920965, 0.7081862, 0.6958149, 0.6907635, 0.6907635,  0.7378887))

plot_df$metric <- factor(plot_df$metric, levels = c("M", "S", "miR", "CS", "MS", "miRM", "miRS", "miRMS"), labels = c("M", "S", "miR", "CS", "MS", "miRM", "miRS", "miRMS"))
p1 <- ggplot(data = plot_df, aes(x = metric, y = cindex, fill = metric, color = metric)) +
  geom_col(width = 0.4) +
  geom_text(aes(label = round(cindex, 2), y = cindex + 0.01),
    size = 4,
    position = position_dodge(width = 0.4), color = "black"
  ) +
  theme(
    panel.background = element_blank(),
    axis.title = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 14),
    axis.text.x = element_text(angle = 45, vjust = 0.7),
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.ticks.length = unit(0.2, units = "cm"),
    legend.position = "none",
    axis.ticks = element_line(color = "black", linewidth = 0.75)
  ) +
  xlab("Metric") +
  ylab("Mean 10-fold CV C-index") +
  ggtitle("1000 Bootstrapped Datasets | Overall Survival") +
  scale_y_continuous(expand = c(0, 0))
p1 <- p1 + coord_cartesian(ylim = c(0.5, 0.8)) +
  scale_fill_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef")) +
  scale_color_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef"))
p1

# Save to PNG
ggsave(p1, device = "png", filename = "figure_a_panel_b_4_predictors.png", path = "Figures/panels/", width = 8, height = 8, dpi = 600, units = "in")

# Save to SVG
ggsave(p1, device = "svg", filename = "figure_a_panel_b_4_predictors.svg", path = "Figures/panels/", width = 8, height = 8, dpi = 600, units = "in")
```


# Simulated datasets with progress free survival for the identified signatures
# miRNA + MAD + SDE
```{r mirna + mad + sde progress free}
cox_outputs <- list()
counter <- 1
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    # my_seed = 1,
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7460983 with the 6 active predictors from MAD + SDE + miRNA
```

```{r MAD progress free}
cox_outputs <- list()
counter <- 1
mad_genes <- readRDS("Outputs/mad_genes.rds")
cox_preds <- mad_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7001656 with the 6 active predictors from MAD
```

# SDE
```{r sde progress free}
cox_outputs <- list()
counter <- 1
cox_preds <- sde_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 7,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.749532 with the 7 active predictors from SDE
```

# miRNA
```{r mirna progress free}
cox_outputs <- list()
counter <- 1
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
cox_preds <- mirna_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7488896 with the 5 active predictors from miRNA
```

# miRNA + SDE
```{r mirna + sde progress free}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("znf460", "tfrc", "fam83f", "samd12", "grin2b"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7463801 with the 5 active predictors from miRNA + SDE
```

# miRNA + MAD
```{r mirna + mad progress free}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("znf460", "tfrc", "fam83f", "samd12", "grin2b"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7463801 with the 5 active predictors from miRNA + MAD
```

# MAD + SDE
```{r mad + sde progress free}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("dlk1", "arl6ip1", "ube2c"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 3,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.732993 with the 3 active predictors from MAD + SDE
```

# Clinical staging
```{r clinical staging progress free}
# Function to efficiently simplify tumor staging
modify_dataframe <- function(df) {
  df <- df %>%
    mutate(n.stage = factor(gsub("[A-Za-z]", "", n.stage))) %>%
    mutate(m.stage = factor(gsub("[A-Za-z]", "", m.stage))) %>%
    mutate(n.stage = ifelse(n.stage == "", NA, n.stage)) %>%
    mutate(m.stage = ifelse(m.stage == "", NA, m.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "I", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ia", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ib", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ic", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IA", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IB", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IC", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "II", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIa", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIb", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIc", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIA", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIB", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIC", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "III", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIa", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIb", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIc", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIA", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIB", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIC", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IV", 4, uicc.tumor.stage)) %>%
    filter(!is.na(n.stage)) %>%
    filter(!is.na(m.stage)) %>%
    filter(!is.na(uicc.tumor.stage))

  return(df)
}

cox_outputs <- list()
counter <- 1
cox_preds <- c("n.stage", "m.stage", "uicc.tumor.stage")
bootstrap_datasets_clinical <- bootstrap_datasets
bootstrap_datasets_clinical <- lapply(bootstrap_datasets_clinical, modify_dataframe)

for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    progress_free = TRUE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 3,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7208957 with the 3 active predictors from clinical staging
```

# Plot for individual metrics for progress free survival with 1,000 simulated datasets performance
```{r combining all overall survival cindicies together for third panel}
plot_df <- data.frame(
  metric = c("M", "S", "miR", "CS", "MS", "miRM", "miRS", "miRMS"),
  cindex = c(0.7001656, 0.749532, 0.7488896, 0.7208957, 0.732993, 0.7463801, 0.7463801, 0.7567699)
)

plot_df$metric <- factor(plot_df$metric, levels = c("M", "S", "miR", "CS", "MS", "miRM", "miRS", "miRMS"), labels = c("M", "S", "miR", "CS", "MS", "miRM", "miRS", "miRMS"))
p1 <- ggplot(data = plot_df, aes(x = metric, y = cindex, fill = metric, color = metric)) +
  geom_col(width = 0.4) +
  geom_text(aes(label = round(cindex, 2), y = cindex + 0.01),
    size = 4,
    position = position_dodge(width = 0.4), color = "black"
  ) +
  theme(
    panel.background = element_blank(),
    axis.title = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 14),
    axis.text.x = element_text(angle = 45, vjust = 0.7),
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.ticks.length = unit(0.2, units = "cm"),
    legend.position = "none",
    axis.ticks = element_line(color = "black", linewidth = 0.75)
  ) +
  xlab("Metric") +
  ylab("Mean 10-fold CV C-index") +
  ggtitle("1000 Bootstrapped Datasets | Progress Free Survival") +
  scale_y_continuous(expand = c(0, 0))
p1 <- p1 + coord_cartesian(ylim = c(0.5, 0.8)) +
  scale_fill_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef")) +
  scale_color_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef"))
p1

# Save to PNG
ggsave(p1, device = "png", filename = "figure_a_panel_c_4_gene_signature.png", path = "Figures/panels/", width = 9, height = 9, dpi = 600, units = "in")

# Save to SVG
ggsave(p1, device = "svg", filename = "figure_a_panel_c_4_gene_signature.svg", path = "Figures/panels/", width = 9, height = 9, dpi = 600, units = "in")
```

# Simulating survival data
```{r simulating survival data}
preds <- c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13")
top_pred_df <- select(scl_common, all_of(preds))
simdata <- sim.survdata(N = 1000, T = 4920, X = top_pred_df, num.data.frames = 1000, beta = c(-0.75737985824054, -0.0706471525401676, -0.16554139965723, 0.305795111401098, -0.000374799303479439, -0.027261204056091), censor = 0.18)

# First, let's assume your coefficients for each gene are stored in a vector like this:
coef <- c(-0.75737985824054, -0.0706471525401676, -0.16554139965723, 0.305795111401098, -0.000374799303479439, -0.027261204056091)

# And your data frame `data` has columns named after the genes
genes <- c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13")

# Then, you can calculate the risk score like this:
test <- simdata[[1]]$data
test2 <- simdata[[25]]$data
test$risk_score <- rowSums(sapply(seq_along(genes), function(i) test[, genes[i]] * coef[i]))
test2$risk_score <- rowSums(sapply(seq_along(genes), function(i) test2[, genes[i]] * coef[i]))

# Now, you may want to binarize the risk score into high and low risk groups, using median risk as a threshold:
median_risk <- median(test$risk_score)
median_risk <- median(test2$risk_score)
test$risk <- ifelse(test$risk_score > median_risk, "high", "low")
test2$risk <- ifelse(test2$risk_score > median_risk, "high", "low")
```

# miRNA + MAD + SDE Overall survival KM plot
```{r original data risk score and km plot for miRNA + MAD + SDE}
# Original data risk score
# First, let's assume your coefficients for each gene are stored in a vector like this:
coef <- c(-0.75737985824054, -0.0706471525401676, -0.16554139965723, 0.305795111401098, -0.000374799303479439, -0.027261204056091)

# And your data frame `data` has columns named after the genes
genes <- c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13")

scl_common$risk_score <- rowSums(sapply(seq_along(genes), function(i) scl_common[, genes[i]] * coef[i]))
median_risk <- median(scl_common$risk_score)
scl_common$risk <- ifelse(scl_common$risk_score > median_risk, "high", "low")

scl_common <- scl_common %>%
  select(patient.id, sex, smoker, vital.status, time, n.stage, m.stage, uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy, risk_score, risk, everything())

# Function to compute p-value from Kaplan-Meier fit
compute_p_value <- function(data, progress_free = FALSE) {
  if (progress_free) {
    fit <- survfit(Surv(data$time2, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time2, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  } else {
    fit <- survfit(Surv(data$time, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  }
}

# Compute observed p-value
observed_p_value <- compute_p_value(scl_common)

# Permutation test
set.seed(1)
n_permutations <- 1000
permuted_p_values <- replicate(n_permutations, {
  permuted_data <- scl_common
  permuted_data$risk <- sample(scl_common$risk) # Randomly permute risk labels
  compute_p_value(permuted_data)
})

# Compute p-value of permutation test
perm_p_value <- mean(permuted_p_values <= observed_p_value)


# Plotting the KM curve
fit <- survfit(Surv(scl_common$time, scl_common$vital.status) ~ risk, data = scl_common)
p1 <- ggsurvplot(
  fit = fit,
  data = scl_common,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(3500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Risk",
  title = "Single Dataset | miRMS",
  legend.labs = c("High risk", "Low risk"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)


# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_d.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_d.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```

# miRNA Overall survival KM plot
```{r miRNA alone overall survival KM plot}
# Original data risk score
# First, let's assume your coefficients for each gene are stored in a vector like this:
coef <- c(-0.0175147427192908, -0.813624034216674, -0.0808400629378394, -0.175783984675757, 0.59820613021554)

# And your data frame `data` has columns named after the genes
genes <- c("znf460", "tfrc", "fam83f", "samd12", "grin2b")

scl_common$risk_score <- rowSums(sapply(seq_along(genes), function(i) scl_common[, genes[i]] * coef[i]))
median_risk <- median(scl_common$risk_score)
scl_common$risk <- ifelse(scl_common$risk_score > median_risk, "high", "low")

scl_common <- scl_common %>%
  select(patient.id, sex, smoker, vital.status, time, n.stage, m.stage, uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy, risk_score, risk, everything())

# Function to compute p-value from Kaplan-Meier fit
compute_p_value <- function(data, progress_free = FALSE) {
  if (progress_free) {
    fit <- survfit(Surv(data$time2, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time2, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  } else {
    fit <- survfit(Surv(data$time, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  }
}

# Compute observed p-value
observed_p_value <- compute_p_value(scl_common)


# Plotting the KM curve
fit <- survfit(Surv(scl_common$time, scl_common$vital.status) ~ risk, data = scl_common)
p1 <- ggsurvplot(
  fit = fit,
  data = scl_common,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(3500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Risk",
  title = "Single Dataset | miRNA",
  legend.labs = c("High risk", "Low risk"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)


# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_e.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_e.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```

# miRNA Progress free survival KM plot
```{r miRNA alone progress free survival KM plot}
# Original data risk score
# First, let's assume your coefficients for each gene are stored in a vector like this:
coef <- c(-0.0175147427192908, -0.813624034216674, -0.0808400629378394, -0.175783984675757, 0.59820613021554)

# And your data frame `data` has columns named after the genes
genes <- c("znf460", "tfrc", "fam83f", "samd12", "grin2b")

scl_common$risk_score <- rowSums(sapply(seq_along(genes), function(i) scl_common[, genes[i]] * coef[i]))
median_risk <- median(scl_common$risk_score)
scl_common$risk <- ifelse(scl_common$risk_score > median_risk, "high", "low")

scl_common <- scl_common %>%
  select(patient.id, sex, smoker, vital.status, time, time2, n.stage, m.stage, uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy, risk_score, risk, everything())

# Function to compute p-value from Kaplan-Meier fit
compute_p_value <- function(data, progress_free = FALSE) {
  if (progress_free) {
    fit <- survfit(Surv(data$time2, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time2, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  } else {
    fit <- survfit(Surv(data$time, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  }
}

# Compute observed p-value
observed_p_value <- compute_p_value(scl_common, progress_free = TRUE)


# Plotting the KM curve
fit <- survfit(Surv(scl_common$time2, scl_common$vital.status) ~ risk, data = scl_common)
p1 <- ggsurvplot(
  fit = fit,
  data = scl_common,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(2500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Risk",
  title = "Single Dataset | miRNA | Progress Free",
  legend.labs = c("High risk", "Low risk"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)


# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_f.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_f.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```

# All 3 metrics Progress free survival KM plot
```{r miRNA alone progress free survival KM plot}

cox_mod_pf <- coxph(Surv(scl_common$time2, scl_common$vital.status)~tfrc+fam83f+dlk1+gng13, data = scl_common)
summary(cox_mod_pf)

# Original data risk score
coef <- c(-0.7545838, -0.0704319, -0.0013110, -0.3618293)

# And your data frame `data` has columns named after the genes
genes <- c("tfrc", "fam83f", "dlk1", "gng13")


scl_common$risk_score <- rowSums(sapply(seq_along(genes), function(i) scl_common[, genes[i]] * coef[i]))
median_risk <- median(scl_common$risk_score)
scl_common$risk <- ifelse(scl_common$risk_score > median_risk, "high", "low")

scl_common <- scl_common %>%
  select(
    patient.id, sex, smoker, vital.status, time, time2, n.stage, m.stage,
    uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy,
    risk_score, risk, everything()
  )

# Function to compute p-value from Kaplan-Meier fit
compute_p_value <- function(data, progress_free = FALSE) {
  if (progress_free) {
    fit <- survfit(Surv(data$time2, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time2, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  } else {
    fit <- survfit(Surv(data$time, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  }
}

# Compute observed p-value
observed_p_value <- compute_p_value(scl_common, progress_free = TRUE)


# Plotting the KM curve
fit <- survfit(Surv(scl_common$time2, scl_common$vital.status) ~ risk, data = scl_common)
p1 <- ggsurvplot(
  fit = fit,
  data = scl_common,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(2500, 0.9),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Risk",
  title = "Single Dataset | miRMS | Progress Free",
  legend.labs = c("High risk", "Low risk"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)


# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_g_4_gene_signature.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_g_4_gene_signature.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")


# Permuted p-value
# Create a data frame with the p-values
df <- data.frame(p_value = permuted_p_values)

# Plot the histogram
hist <- ggplot(df, aes(x = p_value)) +
  geom_histogram(binwidth = 0.05, fill = "steelblue", color = "black") +
  labs(x = "P-value", y = "Frequency") +
  ggtitle("1,000 Permutations | miRMS | Progress Free") +
  geom_vline(xintercept = observed_p_value, linetype = "solid", color = "red", linewidth = 1.25) +
  theme(
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    axis.title = element_text(size = 20, face = "bold"),
    axis.text = element_text(size = 18),
    axis.line = element_line(color = "black", size = 1.25, lineend = "round"),
    axis.ticks = element_line(color = "black", linewidth = 1.25),
    panel.background = element_blank(),
    panel.grid.major.y = element_line(color = "black", linewidth = 1.25),
    panel.grid.major.x = element_blank()
  ) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0))

hist


# Saving as PNG
ggsave(hist, path = "Figures/panels/", filename = "figure_a_panel_h.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(hist, path = "Figures/panels/", filename = "figure_a_panel_h.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```

# miRNA only Progress free survival permutations
```{r miRNA alone progress free survival KM plot}
coef <- c(-0.0175147427192908, -0.813624034216674, -0.0808400629378394, -0.175783984675757, 0.59820613021554)

# And your data frame `data` has columns named after the genes
genes <- c("znf460", "tfrc", "fam83f", "samd12", "grin2b")


scl_common$risk_score <- rowSums(sapply(seq_along(genes), function(i) scl_common[, genes[i]] * coef[i]))
median_risk <- median(scl_common$risk_score)
scl_common$risk <- ifelse(scl_common$risk_score > median_risk, "high", "low")

scl_common <- scl_common %>%
  select(
    patient.id, sex, smoker, vital.status, time, time2, n.stage, m.stage,
    uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy,
    risk_score, risk, everything()
  )

# Function to compute p-value from Kaplan-Meier fit
compute_p_value <- function(data, progress_free = FALSE) {
  if (progress_free) {
    fit <- survfit(Surv(data$time2, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time2, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  } else {
    fit <- survfit(Surv(data$time, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  }
}

# Compute observed p-value
observed_p_value <- compute_p_value(scl_common, progress_free = TRUE)


# Permuted p-value
# Create a data frame with the p-values
df <- data.frame(p_value = permuted_p_values)

# Plot the histogram
hist <- ggplot(df, aes(x = p_value)) +
  geom_histogram(binwidth = 0.05, fill = "steelblue", color = "black") +
  labs(x = "P-value", y = "Frequency") +
  ggtitle("1,000 Permutations | miRNA | Progress Free") +
  geom_vline(xintercept = observed_p_value, linetype = "solid", color = "red", linewidth = 1.25) +
  theme(
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    axis.title = element_text(size = 20, face = "bold"),
    axis.text = element_text(size = 18),
    axis.line = element_line(color = "black", size = 1.25, lineend = "round"),
    axis.ticks = element_line(color = "black", linewidth = 1.25),
    panel.background = element_blank(),
    panel.grid.major.y = element_line(color = "black", linewidth = 1.25),
    panel.grid.major.x = element_blank()
  ) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0))

hist


# Saving as PNG
ggsave(hist, path = "Figures/panels/", filename = "figure_a_panel_i.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(hist, path = "Figures/panels/", filename = "figure_a_panel_i.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```

# Validating miRMS 6 gene signature on two other datasets
```{r validating identified signature}
# Setting the seed based on system time for reproducibility
# seed <- as.integer(Sys.time()) # Seed is: 1688405764
set.seed(1688405764)

genes <- c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13")
first_test_dataset <- read.csv("Data/GSE149507_geo_expr.csv")
first_test_dataset <- first_test_dataset %>%
  filter(!is.na(Symbol))
rownames(first_test_dataset) <- first_test_dataset$Symbol
first_test_dataset <- first_test_dataset %>%
  select(-EntrezID, -Symbol) %>%
  select(contains("_ca")) %>%
  t() %>%
  as.data.frame()

# Getting survival model information from initial dataset
surv_model <- coxph(Surv(time, vital.status) ~ tfrc + fam83f + samd12 + grin2b + dlk1 + gng13, data = scl_common)

# We see our initial performance of 0.738 for our identified predictors
summary(surv_model)

# Extract the estimated survival probabilities and time points
surv_prob <- survfit(surv_model)$surv
time_points <- survfit(surv_model)$time


# Bootstrapping the first validation dataset
# Generate 1000 datasets using bootstrap sampling that match the distribution of the vital status column of our initial set
# Assuming you have two dataframes: 'gene_expression_data' and 'survival_data'
# 'gene_expression_data' contains the gene expression information (without survival information)
# 'survival_data' contains the distribution of survival times and statuses

# Extract survival times and statuses from the survival data
survival_times <- scl_common$time
statuses <- scl_common$vital.status

# Set the number of bootstraps
num_bootstraps <- 1000

# Set the number of cores to be used for parallel processing
num_cores <- 11 # Set it based on your available resources

# Initialize parallel backend
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# Perform bootstrapping and generate the simulated datasets in parallel
bootstrapped_datasets <- foreach(i = 1:num_bootstraps, .combine = "c") %dopar% {
  library(dplyr)
  # Generate bootstrap indices
  bootstrap_indices <- sample(nrow(first_test_dataset), replace = TRUE)

  # Create a bootstrap dataset by sampling from the original dataset using the bootstrap indices
  bootstrap_expression <- first_test_dataset[bootstrap_indices, , drop = FALSE]

  # Generate simulated survival times and statuses for this bootstrap iteration
  bootstrap_times <- sample(survival_times, size = nrow(bootstrap_expression), replace = TRUE)
  bootstrap_statuses <- sample(statuses, size = nrow(bootstrap_expression), replace = TRUE)

  # Create a new dataframe for the bootstrap dataset
  bootstrap_dataset <- data.frame(
    expression_data = bootstrap_expression,
    survival_time = bootstrap_times,
    status = bootstrap_statuses
  )
  colnames(bootstrap_dataset)[20193:20194] <- c("time", "vital.status")
  colnames(bootstrap_dataset)[1:length(bootstrap_expression)] <- colnames(bootstrap_expression)
  colnames(bootstrap_dataset) <- tolower(colnames(bootstrap_dataset))

  # Return the bootstrap dataset
  list(bootstrap_dataset)
}

# Stop the parallel backend
stopCluster(cl)


# Generating several random seeds
# Set the number of random seeds to generate
num_seeds <- 1000

# Generate random seeds and store them in a list
random_seeds <- replicate(num_seeds, sample.int(10^6, 1), simplify = FALSE)

# Print the list of random seeds
print(random_seeds)
random_seeds <- as.vector(unlist(random_seeds))

# Now doing the Cox model
cox_outputs <- list()
counter <- 1
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
for (s in random_seeds) {
  for (d in 1:length(bootstrapped_datasets)) {
    current_dataset <- bootstrapped_datasets[[d]]
    current_cox <- cox_model_fitter(
      # my_seed = 1,
      my_seed = 1688405764,
      my_seed = s,
      my_alpha = 0,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = current_dataset,
      gene_num = 6,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 5,
      my_folds = NULL
    )

    cox_outputs[[counter]] <- current_cox
    counter <- counter + 1
  }
}


# Extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# Calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7204482 with the 6 active predictors from mad + sde + miRNA when using random seed of 1. When using a much more random seed (1688405764) I get a mean performance of 0.7243224



# Simulate survival times for the new gene expression dataset
n <- nrow(first_test_dataset) # Number of individuals in the new dataset
simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

# Optionally, simulate censoring based on a desired censoring rate
censoring_rate <- 0.07 # Desired censoring rate of 7% based on all combined SEER stages from (https://www.cancer.org/cancer/types/lung-cancer/detection-diagnosis-staging/survival-rates.html)
censoring_status <- ifelse(runif(n) < censoring_rate, 0, 1) # 0 represents censoring, 1 represents event


# Create a simulated dataset with gene expression and simulated survival information
simulated_dataset <- cbind(first_test_dataset, time = simulated_times, status = censoring_status)
colnames(simulated_dataset) <- tolower(colnames(simulated_dataset))


# Now testing the signature. C-index is 0.803 [se = 0.074] for 7% survival.
cox_mod_test <- coxph(data = simulated_dataset, Surv(time, status) ~ tfrc + fam83f + samd12 + grin2b + dlk1 + gng13)

# Summary of the first validation dataset performance
summary(cox_mod_test)

# 5 fold CV because of small size of sample folds
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
simulated_dataset_glmnet <- simulated_dataset
colnames(simulated_dataset_glmnet)[20194] <- "vital.status"

# C-index for 5-fold CV is 0.863 for 7% survival. With foldid:  1 2 2 3 4 1 3 4 5 2 4 5 3 2 1 1 5 3.
current_cox <- cox_model_fitter(
  my_seed = 1688405764,
  my_alpha = 0,
  progress_free = FALSE,
  sim_testing = TRUE,
  cox_predictors = cox_preds,
  cox_df = simulated_dataset_glmnet,
  gene_num = 6,
  save_coefs = FALSE,
  tumor_stage = FALSE,
  tumor_n = FALSE,
  tumor_m = FALSE,
  calc_auc = FALSE,
  cat_preds = FALSE,
  n_folds = 5,
  my_folds = c(1, 2, 2, 3, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 1, 1, 5, 3)
)

current_cox$CV


# Second validation dataset (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE110853 [GEO: GSE110853])
second_test_df <- read.csv("Data/GSE110853_TPM_finished_matrix_GEO.csv")
rownames(second_test_df) <- second_test_df$X
second_test_df <- second_test_df %>%
  select(-X)

# Simulate survival times for the new gene expression dataset
n <- nrow(second_test_df) # Number of individuals in the new dataset
simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

# Simulate censoring based on a desired censoring rate
censoring_rate <- 0.07
censoring_status <- ifelse(runif(n) < censoring_rate, 0, 1) # 0 represents censoring, 1 represents event


# Create a simulated dataset with gene expression and simulated survival information
simulated_dataset2 <- data.frame(second_test_df, time = simulated_times, status = censoring_status)
colnames(simulated_dataset2) <- tolower(colnames(simulated_dataset2))

# Now testing the signature. grin2b isn't in this dataset so I test other genes. C-index is 0.762 for 7% survival rate.
cox_mod_test2 <- coxph(data = simulated_dataset2, Surv(time, status) ~ tfrc + fam83f + samd12 + dlk1 + gng13)

# Seeing the results of the second dataset
summary(cox_mod_test2)

# Making the glmnet version of the second dataset
simulated_dataset2_glmnet <- simulated_dataset2
colnames(simulated_dataset2_glmnet)[22282] <- "vital.status"

# 5 fold CV (foldid: c(1, 2, 4, 5, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 3, 3, 1, 1, 2), 7% C-index: 0.7123)
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
current_cox <- cox_model_fitter(
  my_seed = 1688405764,
  my_alpha = 0,
  sim_testing = TRUE,
  progress_free = FALSE,
  cox_predictors = cox_preds,
  cox_df = simulated_dataset2_glmnet,
  gene_num = 5,
  save_coefs = FALSE,
  tumor_stage = FALSE,
  tumor_n = FALSE,
  tumor_m = FALSE,
  calc_auc = FALSE,
  cat_preds = FALSE,
  my_folds = c(1, 2, 4, 5, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 3, 3, 1, 1, 2),
  n_folds = 5
)

# Seeing the CV performance
current_cox$CV

# Third validation dataset
third_df <- read.csv("Data/GSE60052_79tumor.7normal.normalized.log2.data.Rda_finished.csv", sep = ",")
rownames(third_df) <- third_df$X
third_df <- third_df %>%
  select(-X)
colnames(third_df) <- tolower(colnames(third_df))

# Loading in protein-coding genes to get proper names for dataset
hgnc_names <- read.csv("Data/hgnc_results.txt", sep = "\t")
hgnc_names <- hgnc_names %>%
  select(-HGNC.ID) %>%
  select(-Approved.name) %>%
  filter(Status == "Approved")

common_genes <- intersect(tolower(hgnc_names$Approved.symbol), colnames(third_df))

# Subsetting to just HGNC approved genes
third_df <- third_df %>%
  select(all_of(common_genes))


# Results are seed dependent. Generating 10,000 random seeds
random_seeds <- randomNumbers(n = 10000, min = 1, max = 10^6, col = 5, base = 10)
random_seeds <- as.vector(random_seeds)
c_indicies <- c()


for (s in random_seeds) {
  set.seed(s)
  # Simulate survival times for the new gene expression dataset
  n <- nrow(third_df) # Number of individuals in the new dataset
  simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

  # Simulate censoring based on a desired censoring rate
  censoring_rate <- 0.07 # Desired censoring rate
  censoring_status <- ifelse(runif(n) < censoring_rate, 0, 1) # 0 represents censoring, 1 represents event

  # Create a simulated dataset with gene expression and simulated survival information
  simulated_dataset3 <- data.frame(third_df, time = simulated_times, status = censoring_status)

  # Just regular cox model
  cox_mod_test3 <- coxph(data = simulated_dataset3, Surv(time, status) ~ tfrc + fam83f + samd12 + dlk1 + gng13 + grin2b)

  # Seeing the detailed performance
  test <- summary(cox_mod_test3)
  test <- test$concordance[1]
  c_indicies <- c(c_indicies, test)
}



simulated_dataset3_glmnet <- simulated_dataset3
colnames(simulated_dataset3_glmnet)[23461] <- "vital.status"


# 10 fold cv (foldid:, 7% C-index: 0.X)
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "dlk1", "gng13", "grin2b"))
rownames(cox_preds) <- cox_preds$preds
for (n in 1:1000) {
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = FALSE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset3_glmnet,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    my__folds = NULL,
    n_folds = 10
  )

  print(current_cox$CV)
}
```


# Validating miRMS 6 gene signature on first simulated datasets with different censoring rates that are inline with SEER survival rates
```{r validating identified signature at 3% survival. 0.7380741 C-index}
# Setting the seed based on system time for reproducibility
# seed <- as.integer(Sys.time()) # Seed is: 1688405764
set.seed(1688405764)

genes <- c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13")
first_test_dataset <- read.csv("Data/GSE149507_geo_expr.csv")
first_test_dataset <- first_test_dataset %>%
  filter(!is.na(Symbol))
rownames(first_test_dataset) <- first_test_dataset$Symbol
first_test_dataset <- first_test_dataset %>%
  select(-EntrezID, -Symbol) %>%
  select(contains("_ca")) %>%
  t() %>%
  as.data.frame()

# Getting survival model information from initial dataset
surv_model <- coxph(Surv(time, vital.status) ~ tfrc + fam83f + samd12 + grin2b + dlk1 + gng13, data = scl_common)

# We see our initial performance of 0.738 for our identified predictors
summary(surv_model)

# Extract the estimated survival probabilities and time points
surv_prob <- survfit(surv_model)$surv
time_points <- survfit(surv_model)$time


# Bootstrapping the first validation dataset
# Generate 1000 datasets using bootstrap sampling that match the distribution of the vital status column of our initial set
# Assuming you have two dataframes: 'gene_expression_data' and 'survival_data'
# 'gene_expression_data' contains the gene expression information (without survival information)
# 'survival_data' contains the distribution of survival times and statuses

# Extract survival times and statuses from the survival data
survival_times <- scl_common$time
statuses <- scl_common$vital.status


# Simulate survival times for the new gene expression dataset
n <- nrow(first_test_dataset) # Number of individuals in the new dataset
simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

# Optionally, simulate censoring based on a desired censoring rate
censoring_rate <- 0.03 # Desired censoring rate of 3% based on distant SEER stages from (https://www.cancer.org/cancer/types/lung-cancer/detection-diagnosis-staging/survival-rates.html)
censoring_status <- ifelse(runif(n) < censoring_rate, 0, 1) # 0 represents censoring, 1 represents event


# Create a simulated dataset with gene expression and simulated survival information
simulated_dataset <- cbind(first_test_dataset, time = simulated_times, status = censoring_status)
colnames(simulated_dataset) <- tolower(colnames(simulated_dataset))

# write.csv(simulated_dataset, "Outputs/first_simulated_validation_dataset.csv")


# Now testing the signature. C-index is 0.777 [se = 0.07] for 3% survival.
cox_mod_test <- coxph(data = simulated_dataset, Surv(time, status) ~ tfrc + fam83f + samd12 + grin2b + dlk1 + gng13)

# Summary of the first validation dataset performance
summary(cox_mod_test)

# 5 fold CV because of small size of sample folds
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
simulated_dataset_glmnet <- simulated_dataset
colnames(simulated_dataset_glmnet)[20194] <- "vital.status"

# C-index for 5-fold CV is  0.7333 for 3% survival. With foldid:  1 2 2 3 4 1 3 4 5 2 4 5 3 2 1 1 5 3.
current_cox <- cox_model_fitter(
  my_seed = 1688405764,
  # my_seed = 1692724191,
  my_alpha = 0,
  progress_free = FALSE,
  sim_testing = TRUE,
  cox_predictors = cox_preds,
  cox_df = simulated_dataset_glmnet,
  gene_num = 6,
  save_coefs = FALSE,
  tumor_stage = FALSE,
  tumor_n = FALSE,
  tumor_m = FALSE,
  calc_auc = FALSE,
  cat_preds = FALSE,
  n_folds = 5,
  my_folds = NULL
  # my_folds = c(1, 2, 2, 3, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 1, 1, 5, 3)
)

current_cox$CV

# When using many random seeds we get a mean performance of 0.7265444 for 3% survival. 
# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_first_validation_dataset_3_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset_glmnet,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)



# Second validation dataset (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE110853 [GEO: GSE110853])
second_test_df <- read.csv("Data/GSE110853_TPM_finished_matrix_GEO.csv")
rownames(second_test_df) <- second_test_df$X
second_test_df <- second_test_df %>%
  select(-X)

# Simulate survival times for the new gene expression dataset
n <- nrow(second_test_df) # Number of individuals in the new dataset
simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

# Simulate censoring based on a desired censoring rate
censoring_rate <- 0.07
censoring_status <- ifelse(runif(n) < censoring_rate, 0, 1) # 0 represents censoring, 1 represents event


# Create a simulated dataset with gene expression and simulated survival information
simulated_dataset2 <- data.frame(second_test_df, time = simulated_times, status = censoring_status)
colnames(simulated_dataset2) <- tolower(colnames(simulated_dataset2))

# Now testing the signature. grin2b isn't in this dataset so I test other genes. C-index is 0.762 for 7% survival rate.
cox_mod_test2 <- coxph(data = simulated_dataset2, Surv(time, status) ~ tfrc + fam83f + samd12 + dlk1 + gng13)

# Seeing the results of the second dataset
summary(cox_mod_test2)

# Making the glmnet version of the second dataset
simulated_dataset2_glmnet <- simulated_dataset2
colnames(simulated_dataset2_glmnet)[22282] <- "vital.status"

# 5 fold CV (foldid: c(1, 2, 4, 5, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 3, 3, 1, 1, 2), 7% C-index: 0.7123)
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
current_cox <- cox_model_fitter(
  my_seed = 1688405764,
  my_alpha = 0,
  sim_testing = TRUE,
  progress_free = FALSE,
  cox_predictors = cox_preds,
  cox_df = simulated_dataset2_glmnet,
  gene_num = 5,
  save_coefs = FALSE,
  tumor_stage = FALSE,
  tumor_n = FALSE,
  tumor_m = FALSE,
  calc_auc = FALSE,
  cat_preds = FALSE,
  my_folds = c(1, 2, 4, 5, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 3, 3, 1, 1, 2),
  n_folds = 5
)

# Seeing the CV performance
current_cox$CV

# Third validation dataset
third_df <- read.csv("Data/GSE60052_79tumor.7normal.normalized.log2.data.Rda_finished.csv", sep = ",")
rownames(third_df) <- third_df$X
third_df <- third_df %>%
  select(-X)
colnames(third_df) <- tolower(colnames(third_df))

# Loading in protein-coding genes to get proper names for dataset
hgnc_names <- read.csv("Data/hgnc_results.txt", sep = "\t")
hgnc_names <- hgnc_names %>%
  select(-HGNC.ID) %>%
  select(-Approved.name) %>%
  filter(Status == "Approved")

common_genes <- intersect(tolower(hgnc_names$Approved.symbol), colnames(third_df))

# Subsetting to just HGNC approved genes
third_df <- third_df %>%
  select(all_of(common_genes))


# Results are seed dependent. Generating 10,000 random seeds
random_seeds <- randomNumbers(n = 10000, min = 1, max = 10^6, col = 5, base = 10)
random_seeds <- as.vector(random_seeds)
c_indicies <- c()


for (s in random_seeds) {
  set.seed(s)
  # Simulate survival times for the new gene expression dataset
  n <- nrow(third_df) # Number of individuals in the new dataset
  simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

  # Simulate censoring based on a desired censoring rate
  censoring_rate <- 0.07 # Desired censoring rate
  censoring_status <- ifelse(runif(n) < censoring_rate, 0, 1) # 0 represents censoring, 1 represents event

  # Create a simulated dataset with gene expression and simulated survival information
  simulated_dataset3 <- data.frame(third_df, time = simulated_times, status = censoring_status)

  # Just regular cox model
  cox_mod_test3 <- coxph(data = simulated_dataset3, Surv(time, status) ~ tfrc + fam83f + samd12 + dlk1 + gng13 + grin2b)

  # Seeing the detailed performance
  test <- summary(cox_mod_test3)
  test <- test$concordance[1]
  c_indicies <- c(c_indicies, test)
}



simulated_dataset3_glmnet <- simulated_dataset3
colnames(simulated_dataset3_glmnet)[23461] <- "vital.status"


# 10 fold cv (foldid:, 7% C-index: 0.X)
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "dlk1", "gng13", "grin2b"))
rownames(cox_preds) <- cox_preds$preds
for (n in 1:1000) {
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = FALSE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset3_glmnet,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    my__folds = NULL,
    n_folds = 10
  )

  print(current_cox$CV)
}
```

```{r validating identified signature at 7% survival. 0.7802726 C-index}
# Setting the seed based on system time for reproducibility
# seed <- as.integer(Sys.time()) # Seed is: 1688405764
set.seed(1688405764)

genes <- c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13")
first_test_dataset <- read.csv("Data/GSE149507_geo_expr.csv")
first_test_dataset <- first_test_dataset %>%
  filter(!is.na(Symbol))
rownames(first_test_dataset) <- first_test_dataset$Symbol
first_test_dataset <- first_test_dataset %>%
  select(-EntrezID, -Symbol) %>%
  select(contains("_ca")) %>%
  t() %>%
  as.data.frame()

# Getting survival model information from initial dataset
surv_model <- coxph(Surv(time, vital.status) ~ tfrc + fam83f + samd12 + grin2b + dlk1 + gng13, data = scl_common)

# We see our initial performance of 0.738 for our identified predictors
summary(surv_model)

# Extract the estimated survival probabilities and time points
surv_prob <- survfit(surv_model)$surv
time_points <- survfit(surv_model)$time


# Extract survival times and statuses from the survival data
survival_times <- scl_common$time
statuses <- scl_common$vital.status


# Simulate survival times for the new gene expression dataset
n <- nrow(first_test_dataset) # Number of individuals in the new dataset
simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

# Optionally, simulate censoring based on a desired censoring rate
censoring_rate <- 0.07 # Desired censoring rate of 7% based on distant SEER stages from (https://www.cancer.org/cancer/types/lung-cancer/detection-diagnosis-staging/survival-rates.html)
censoring_status <- ifelse(runif(n) < censoring_rate, 0, 1) # 0 represents censoring, 1 represents event


# Create a simulated dataset with gene expression and simulated survival information
simulated_dataset <- cbind(first_test_dataset, time = simulated_times, status = censoring_status)
colnames(simulated_dataset) <- tolower(colnames(simulated_dataset))

write.csv(simulated_dataset, "Outputs/first_simulated_validation_7_percent_dataset.csv")

# Now testing the signature. C-index is 0.803 [se = 0.074] for 7% survival.
cox_mod_test <- coxph(data = simulated_dataset, Surv(time, status) ~ tfrc + fam83f + samd12 + grin2b + dlk1 + gng13)

# Summary of the first validation dataset performance
summary(cox_mod_test)

# 5 fold CV because of small size of sample folds
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
simulated_dataset_glmnet <- simulated_dataset
colnames(simulated_dataset_glmnet)[20194] <- "vital.status"

# C-index for 5-fold CV is  0.8148 for 7% survival.
current_cox <- cox_model_fitter(
  my_seed = 1688405764,
  # my_seed = 1692724191,
  my_alpha = 0,
  progress_free = FALSE,
  sim_testing = TRUE,
  cox_predictors = cox_preds,
  cox_df = simulated_dataset_glmnet,
  gene_num = 6,
  save_coefs = FALSE,
  tumor_stage = FALSE,
  tumor_n = FALSE,
  tumor_m = FALSE,
  calc_auc = FALSE,
  cat_preds = FALSE,
  n_folds = 5,
  my_folds = NULL
)

current_cox$CV



# When using many random seeds we get a mean performance of X for 7% survival. 
# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_first_validation_dataset_7_percent_final.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset_glmnet,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector) # X at 7%

```

```{r validating identified signature at 18% survival. 0.646726 C-index}
# Setting the seed based on system time for reproducibility
# seed <- as.integer(Sys.time()) # Seed is: 1688405764
set.seed(1688405764)

genes <- c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13")
first_test_dataset <- read.csv("Data/GSE149507_geo_expr.csv")
first_test_dataset <- first_test_dataset %>%
  filter(!is.na(Symbol))
rownames(first_test_dataset) <- first_test_dataset$Symbol
first_test_dataset <- first_test_dataset %>%
  select(-EntrezID, -Symbol) %>%
  select(contains("_ca")) %>%
  t() %>%
  as.data.frame()

# Getting survival model information from initial dataset
surv_model <- coxph(Surv(time, vital.status) ~ tfrc + fam83f + samd12 + grin2b + dlk1 + gng13, data = scl_common)

# We see our initial performance of 0.738 for our identified predictors
summary(surv_model)

# Extract the estimated survival probabilities and time points
surv_prob <- survfit(surv_model)$surv
time_points <- survfit(surv_model)$time


# Extract survival times and statuses from the survival data
survival_times <- scl_common$time
statuses <- scl_common$vital.status


# Simulate survival times for the new gene expression dataset
n <- nrow(first_test_dataset) # Number of individuals in the new dataset
simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

# Optionally, simulate censoring based on a desired censoring rate
censoring_rate <- 0.18 # Desired censoring rate of 18% based on distant SEER stages from (https://www.cancer.org/cancer/types/lung-cancer/detection-diagnosis-staging/survival-rates.html)
censoring_status <- ifelse(runif(n) < censoring_rate, 0, 1) # 0 represents censoring, 1 represents event


# Create a simulated dataset with gene expression and simulated survival information
simulated_dataset <- cbind(first_test_dataset, time = simulated_times, status = censoring_status)
colnames(simulated_dataset) <- tolower(colnames(simulated_dataset))

write.csv(simulated_dataset, "Outputs/first_simulated_validation_30_percent_dataset.csv")

# Now testing the signature. C-index is 0.73 [se = 0.068] for 18% survival.
cox_mod_test <- coxph(data = simulated_dataset, Surv(time, status) ~ tfrc + fam83f + samd12 + grin2b + dlk1 + gng13)

# Summary of the first validation dataset performance
summary(cox_mod_test)

# 5 fold CV because of small size of sample folds
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
simulated_dataset_glmnet <- simulated_dataset
colnames(simulated_dataset_glmnet)[20194] <- "vital.status"

# C-index for 5-fold CV is  0.7037 for 18% survival.
current_cox <- cox_model_fitter(
  my_seed = 1688405764,
  # my_seed = 1692724191,
  my_alpha = 0,
  progress_free = FALSE,
  sim_testing = TRUE,
  cox_predictors = cox_preds,
  cox_df = simulated_dataset_glmnet,
  gene_num = 6,
  save_coefs = FALSE,
  tumor_stage = FALSE,
  tumor_n = FALSE,
  tumor_m = FALSE,
  calc_auc = FALSE,
  cat_preds = FALSE,
  n_folds = 5,
  my_folds = NULL
)

current_cox$CV



# When using many random seeds we get a mean performance of 0.6830575 for 18% survival. 
# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_first_validation_dataset_18_percent_final.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset_glmnet,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector) # 0.6830575 at 18%

```

```{r validating identified signature at 30% survival. 0.6092868 C-index}
# Setting the seed based on system time for reproducibility
# seed <- as.integer(Sys.time()) # Seed is: 1688405764
set.seed(1688405764)

genes <- c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13")
first_test_dataset <- read.csv("Data/GSE149507_geo_expr.csv")
first_test_dataset <- first_test_dataset %>%
  filter(!is.na(Symbol))
rownames(first_test_dataset) <- first_test_dataset$Symbol
first_test_dataset <- first_test_dataset %>%
  select(-EntrezID, -Symbol) %>%
  select(contains("_ca")) %>%
  t() %>%
  as.data.frame()

# Getting survival model information from initial dataset
surv_model <- coxph(Surv(time, vital.status) ~ tfrc + fam83f + samd12 + grin2b + dlk1 + gng13, data = scl_common)

# We see our initial performance of 0.738 for our identified predictors
summary(surv_model)

# Extract the estimated survival probabilities and time points
surv_prob <- survfit(surv_model)$surv
time_points <- survfit(surv_model)$time


# Extract survival times and statuses from the survival data
survival_times <- scl_common$time
statuses <- scl_common$vital.status


# Simulate survival times for the new gene expression dataset
n <- nrow(first_test_dataset) # Number of individuals in the new dataset
simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

# Optionally, simulate censoring based on a desired censoring rate
censoring_rate <- 0.30 # Desired censoring rate of 7% based on distant SEER stages from (https://www.cancer.org/cancer/types/lung-cancer/detection-diagnosis-staging/survival-rates.html)
censoring_status <- ifelse(runif(n) < censoring_rate, 0, 1) # 0 represents censoring, 1 represents event


# Create a simulated dataset with gene expression and simulated survival information
simulated_dataset <- cbind(first_test_dataset, time = simulated_times, status = censoring_status)
colnames(simulated_dataset) <- tolower(colnames(simulated_dataset))


# Now testing the signature. C-index is 0.733 [se = 0.095] for 30% survival.
cox_mod_test <- coxph(data = simulated_dataset, Surv(time, status) ~ tfrc + fam83f + samd12 + grin2b + dlk1 + gng13)

# Summary of the first validation dataset performance
summary(cox_mod_test)

# 5 fold CV because of small size of sample folds
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
simulated_dataset_glmnet <- simulated_dataset
colnames(simulated_dataset_glmnet)[20194] <- "vital.status"

# C-index for 5-fold CV is  0.6667 for 30% survival.
current_cox <- cox_model_fitter(
  my_seed = 1688405764,
  # my_seed = 1692724191,
  my_alpha = 0,
  progress_free = FALSE,
  sim_testing = TRUE,
  cox_predictors = cox_preds,
  cox_df = simulated_dataset_glmnet,
  gene_num = 6,
  save_coefs = FALSE,
  tumor_stage = FALSE,
  tumor_n = FALSE,
  tumor_m = FALSE,
  calc_auc = FALSE,
  cat_preds = FALSE,
  n_folds = 5,
  my_folds = NULL
)

current_cox$CV



# When using many random seeds we get a mean performance of 0.7808408 for 30% survival. 
# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_first_validation_dataset_30_percent_final.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset_glmnet,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector) 

```

# Plotting results of validation of signature on first dataset at different censoring rates
```{r plotting results of validation of signature}
# validation_df <- data.frame(dataset = c(1, 2), c_index = c(0.803, 0.762), c_index_cv = c(0.863, 0.7123))
validation_df <- data.frame(censoring_rate = c(3, 7, 18, 30), c_index_cv = c(0.7380741,  0.7802726, 0.646726, 0.6092868), dataset = c(1,2,3,4))
p1 <- ggplot(data = validation_df, aes(x = dataset, y = c_index_cv)) +
  geom_col(width = 0.4, fill = "skyblue") +
  theme(
    panel.background = element_blank(),
    legend.position = "none",
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    axis.title = element_text(size = 16, face = "bold"),
    axis.text = element_text(size = 14)
  ) +
  xlab("Survival Rate") +
  ylab("Mean C-index of 1,000 5-fold CVs") +
  scale_y_continuous(expand = c(0, 0)) +
  ggtitle("First Dataset") +
  coord_cartesian(ylim = c(0.50, 0.90))

p1


# Saving as PNG
ggsave(p1, path = "Figures/panels/", filename = "figure_3_a_improved_final.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1, path = "Figures/panels/", filename = "figure_3_a_improved_final.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```

# Second validation dataset
```{r second validation dataset 3% survival. 0.7410789 C-index}
# Second validation dataset (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE110853 [GEO: GSE110853])
second_test_df <- read.csv("Data/GSE110853_TPM_finished_matrix_GEO.csv")
rownames(second_test_df) <- second_test_df$X
second_test_df <- second_test_df %>%
  select(-X)

set.seed(1688405764)

# Simulate survival times for the new gene expression dataset
n <- nrow(second_test_df) # Number of individuals in the new dataset
simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

# Simulate censoring based on a desired censoring rate
censoring_rate <- 0.03
censoring_status <- ifelse(runif(n) < censoring_rate, 0, 1) # 0 represents censoring, 1 represents event


# Create a simulated dataset with gene expression and simulated survival information
simulated_dataset2 <- data.frame(second_test_df, time = simulated_times, status = censoring_status)
colnames(simulated_dataset2) <- tolower(colnames(simulated_dataset2))

write.csv(simulated_dataset, "Outputs/second_simulated_validation_dataset.csv")

# Now testing the signature. grin2b isn't in this dataset so I test other genes. C-index is 0.766 for 3% survival rate.
cox_mod_test2 <- coxph(data = simulated_dataset2, Surv(time, status) ~ tfrc + fam83f + samd12 + dlk1 + gng13)

# Seeing the results of the second dataset (0.747 C-index. SE = 0.036)
summary(cox_mod_test2)

# Making the glmnet version of the second dataset
simulated_dataset2_glmnet <- simulated_dataset2
colnames(simulated_dataset2_glmnet)[22282] <- "vital.status"

# 5 fold CV (foldid: c(1, 2, 4, 5, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 3, 3, 1, 1, 2), 3% C-index: 0.8456)
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
current_cox <- cox_model_fitter(
  my_seed = 1688405764,
  my_alpha = 0,
  sim_testing = TRUE,
  progress_free = FALSE,
  cox_predictors = cox_preds,
  cox_df = simulated_dataset2_glmnet,
  gene_num = 5,
  save_coefs = FALSE,
  tumor_stage = FALSE,
  tumor_n = FALSE,
  tumor_m = FALSE,
  calc_auc = FALSE,
  cat_preds = FALSE,
  my_folds = NULL,
  # my_folds = c(1, 2, 4, 5, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 3, 3, 1, 1, 2),
  n_folds = 5
)

# Seeing the CV performance
current_cox$CV

# When using many random seeds we get a mean performance of 0.X for 3% survival. 
# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_second_validation_dataset_3_percent_final.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset2_glmnet,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)

```

```{r second validation dataset 7% survival. 0.8236079 C-index}
# Second validation dataset (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE110853 [GEO: GSE110853])
second_test_df <- read.csv("Data/GSE110853_TPM_finished_matrix_GEO.csv")
rownames(second_test_df) <- second_test_df$X
second_test_df <- second_test_df %>%
  select(-X)

# Simulate survival times for the new gene expression dataset
n <- nrow(second_test_df) # Number of individuals in the new dataset
simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

# Simulate censoring based on a desired censoring rate
censoring_rate <- 0.07
censoring_status <- ifelse(runif(n) < censoring_rate, 0, 1) # 0 represents censoring, 1 represents event


# Create a simulated dataset with gene expression and simulated survival information
simulated_dataset2 <- data.frame(second_test_df, time = simulated_times, status = censoring_status)
colnames(simulated_dataset2) <- tolower(colnames(simulated_dataset2))

write.csv(simulated_dataset2, "Outputs/second_simulated_validation_7_percent_dataset.csv")

# Now testing the signature. grin2b isn't in this dataset so I test other genes. C-index is 0.762 for 7% survival rate.
cox_mod_test2 <- coxph(data = simulated_dataset2, Surv(time, status) ~ tfrc + fam83f + samd12 + dlk1 + gng13)

# Seeing the results of the second dataset (0.818 C-index. SE = 0.045)
summary(cox_mod_test2)

# Making the glmnet version of the second dataset
simulated_dataset2_glmnet <- simulated_dataset2
colnames(simulated_dataset2_glmnet)[22282] <- "vital.status"

# 5 fold CV (foldid: c(1, 2, 4, 5, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 3, 3, 1, 1, 2), 7% C-index: 0.8877)
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
current_cox <- cox_model_fitter(
  my_seed = 1688405764,
  my_alpha = 0,
  sim_testing = TRUE,
  progress_free = FALSE,
  cox_predictors = cox_preds,
  cox_df = simulated_dataset2_glmnet,
  gene_num = 5,
  save_coefs = FALSE,
  tumor_stage = FALSE,
  tumor_n = FALSE,
  tumor_m = FALSE,
  calc_auc = FALSE,
  cat_preds = FALSE,
  my_folds = NULL,
  # my_folds = c(1, 2, 4, 5, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 3, 3, 1, 1, 2),
  n_folds = 5
)

# Seeing the CV performance
current_cox$CV

# When using many random seeds we get a mean performance of 0.X for 3% survival. 
# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_second_validation_dataset_7_percent_final.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset2_glmnet,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)

```

```{r second validation dataset 18% survival. 0.8635586 C-index}
# Second validation dataset (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE110853 [GEO: GSE110853])
second_test_df <- read.csv("Data/GSE110853_TPM_finished_matrix_GEO.csv")
rownames(second_test_df) <- second_test_df$X
second_test_df <- second_test_df %>%
  select(-X)

# Simulate survival times for the new gene expression dataset
n <- nrow(second_test_df) # Number of individuals in the new dataset
simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

# Simulate censoring based on a desired censoring rate
censoring_rate <- 0.18
censoring_status <- ifelse(runif(n) < censoring_rate, 0, 1) # 0 represents censoring, 1 represents event


# Create a simulated dataset with gene expression and simulated survival information
simulated_dataset2 <- data.frame(second_test_df, time = simulated_times, status = censoring_status)
colnames(simulated_dataset2) <- tolower(colnames(simulated_dataset2))

write.csv(simulated_dataset2, "Outputs/second_simulated_validation_18_percent_dataset.csv")

# Now testing the signature. grin2b isn't in this dataset so I test other genes. C-index is 0.762 for 7% survival rate.
cox_mod_test2 <- coxph(data = simulated_dataset2, Surv(time, status) ~ tfrc + fam83f + samd12 + dlk1 + gng13)

# Seeing the results of the second dataset (0.847 C-index. SE = 0.053)
summary(cox_mod_test2)

# Making the glmnet version of the second dataset
simulated_dataset2_glmnet <- simulated_dataset2
colnames(simulated_dataset2_glmnet)[22282] <- "vital.status"

# 5 fold CV (foldid: c(1, 2, 4, 5, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 3, 3, 1, 1, 2), 3% C-index: 0.7018)
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
current_cox <- cox_model_fitter(
  my_seed = 1688405764,
  my_alpha = 0,
  sim_testing = TRUE,
  progress_free = FALSE,
  cox_predictors = cox_preds,
  cox_df = simulated_dataset2_glmnet,
  gene_num = 5,
  save_coefs = FALSE,
  tumor_stage = FALSE,
  tumor_n = FALSE,
  tumor_m = FALSE,
  calc_auc = FALSE,
  cat_preds = FALSE,
  my_folds = NULL,
  # my_folds = c(1, 2, 4, 5, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 3, 3, 1, 1, 2),
  n_folds = 5
)

# Seeing the CV performance
current_cox$CV

# When using many random seeds we get a mean performance of 0.X for 3% survival. 
# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_second_validation_dataset_18_percent_final.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset2_glmnet,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)

```

```{r second validation dataset 30% survival. 0.8081917 C-index}
# Second validation dataset (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE110853 [GEO: GSE110853])
second_test_df <- read.csv("Data/GSE110853_TPM_finished_matrix_GEO.csv")
rownames(second_test_df) <- second_test_df$X
second_test_df <- second_test_df %>%
  select(-X)

# Simulate survival times for the new gene expression dataset
n <- nrow(second_test_df) # Number of individuals in the new dataset
simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

# Simulate censoring based on a desired censoring rate
censoring_rate <- 0.30
censoring_status <- ifelse(runif(n) < censoring_rate, 0, 1) # 0 represents censoring, 1 represents event


# Create a simulated dataset with gene expression and simulated survival information
simulated_dataset2 <- data.frame(second_test_df, time = simulated_times, status = censoring_status)
colnames(simulated_dataset2) <- tolower(colnames(simulated_dataset2))

write.csv(simulated_dataset2, "Outputs/second_simulated_validation_30_percent_dataset.csv")

# Now testing the signature. grin2b isn't in this dataset so I test other genes. C-index is 0.762 for 7% survival rate.
cox_mod_test2 <- coxph(data = simulated_dataset2, Surv(time, status) ~ tfrc + fam83f + samd12 + dlk1 + gng13)

# Seeing the results of the second dataset (0.839 C-index. SE = 0.066)
summary(cox_mod_test2)

# Making the glmnet version of the second dataset
simulated_dataset2_glmnet <- simulated_dataset2
colnames(simulated_dataset2_glmnet)[22282] <- "vital.status"

# 5 fold CV (foldid: c(1, 2, 4, 5, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 3, 3, 1, 1, 2), 30% C-index: 0.8772)
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
current_cox <- cox_model_fitter(
  my_seed = 1688405764,
  my_alpha = 0,
  sim_testing = TRUE,
  progress_free = FALSE,
  cox_predictors = cox_preds,
  cox_df = simulated_dataset2_glmnet,
  gene_num = 5,
  save_coefs = FALSE,
  tumor_stage = FALSE,
  tumor_n = FALSE,
  tumor_m = FALSE,
  calc_auc = FALSE,
  cat_preds = FALSE,
  my_folds = NULL,
  # my_folds = c(1, 2, 4, 5, 4, 1, 3, 4, 5, 2, 4, 5, 3, 2, 3, 3, 1, 1, 2),
  n_folds = 5
)

# Seeing the CV performance
current_cox$CV

# When using many random seeds we get a mean performance of 0.X for 3% survival. 
# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_second_validation_dataset_30_percent_final.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset2_glmnet,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)

```

# Plotting results of validation of signature on second dataset at different censoring rates
```{r plotting results of validation of signature on second dataset}
validation_df <- data.frame(censoring_rate = c(3, 7, 18, 30), c_index_cv = c(0.7410789, 0.8236079, 0.8635586, 0.8081917), dataset = c(1,2,3,4))
p2 <- ggplot(data = validation_df, aes(x = dataset, y = c_index_cv)) +
  geom_col(width = 0.4, fill = "skyblue") +
  theme(
    panel.background = element_blank(),
    legend.position = "none",
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    axis.title = element_text(size = 16, face = "bold"),
    axis.text = element_text(size = 14)
  ) +
  xlab("Survival Rate") +
  ylab("Mean C-index of 1,000 5-fold CVs") +
  scale_y_continuous(expand = c(0, 0)) +
  ggtitle("Second Dataset") +
  coord_cartesian(ylim = c(0.50, 0.90))

p2


# Saving as PNG
ggsave(p1, path = "Figures/panels/", filename = "figure_3_b_improved_final.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1, path = "Figures/panels/", filename = "figure_3_b_improved_final.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```


```{r combining the datasets together}
combo_plot <- ggarrange(p1, p2,  ncol = 2, nrow = 1, labels = "AUTO", align = "hv", font.label = list(size = 18, face = "bold"))

ggsave(combo_plot, path = "Figures/panels/", filename = "validation_datasets.png", dpi = 600, width = 8, height = 8, units = "in")
```


# Another dataset to show that our pipeline works well. We combine the simulation approach with pipeline to find a new signature on this much larger dataset
```{r another dataset}
# Third validation dataset
third_df <- read.csv("Data/GSE60052_79tumor.7normal.normalized.log2.data.Rda_finished.csv", sep = ",")
rownames(third_df) <- third_df$X
third_df <- third_df %>%
  select(-X)
colnames(third_df) <- tolower(colnames(third_df))

# Loading in protein-coding genes to get proper names for dataset
hgnc_names <- read.csv("Data/hgnc_results.txt", sep = "\t")
hgnc_names <- hgnc_names %>%
  select(-HGNC.ID) %>%
  select(-Approved.name) %>%
  filter(Status == "Approved")

common_genes <- intersect(tolower(hgnc_names$Approved.symbol), colnames(third_df))

# Subsetting to just HGNC approved genes
third_df <- third_df %>%
  select(all_of(common_genes))

# Simulate survival times for the new gene expression dataset

set.seed(1688405764)
n <- nrow(third_df) # Number of individuals in the new dataset
simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

# Simulate censoring based on a desired censoring rate
censoring_status <- ifelse(runif(n) < 0.93, 1, 0) # 1 represents event, 0 represents censoring


# Create a simulated dataset with gene expression and simulated survival information
simulated_dataset3 <- data.frame(third_df, time = simulated_times, status = censoring_status)
colnames(simulated_dataset3) <- tolower(colnames(simulated_dataset3))

write.csv(simulated_dataset3, "Outputs/third_dataset_baseline_survival_data.csv")
```

# Pathway enrichment
```{r pathway enrichment}
enrichment_df <- read.csv("Data/mirms_enrichment.csv") 
enrichment_df <- enrichment_df %>%
  select(Pathway.name, Entities.FDR) %>%
  filter(Entities.FDR < 0.05)


enrichment_df <- enrichment_df %>%
  arrange(Entities.FDR) %>%
  head(n = 10)

enrichment_plot <- ggplot(data = enrichment_df, aes(x = reorder(Pathway.name, Entities.FDR, decreasing = TRUE), y = Entities.FDR, fill = Entities.FDR))+
  geom_col()+
  coord_flip()+
  scale_y_continuous(expand = c(0,0))+
  scale_fill_continuous("FDR\np-value")+
  xlab("Pathway")+
  ylab("FDR p-value")+
  theme(panel.background = element_blank(),
        axis.title = element_text(size = 18, face = "bold"),
        axis.text = element_text(size = 16),
        legend.title = element_text(size = 18, face = "bold"),
        legend.text = element_text(size = 16))

ggsave(enrichment_plot, filename = "enrichment_plot.png", path = "Figures/panels/", dpi = 600, height = 12, width = 12, bg = "white", units = "in")

ggsave(enrichment_plot, filename = "enrichment_plot.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 12, width = 12, bg = "white", units = "in")

```

# Forestplot of Initial Cox model
```{r forestplot}
cox_mod <- coxph(Surv(time, vital.status) ~ tfrc + fam83f + samd12 + grin2b + dlk1 + gng13, data = scl_common)
forest_plot <- ggforest(model = cox_mod, data = scl_common)

# Saving as PNG
ggsave(forest_plot, path = "Figures/panels/", filename = "forestplot_main_model.png", width = 8, height = 8, units = "in", dpi = 600)

# Saving as SVG
ggsave(forest_plot, path = "Figures/panels/", filename = "forestplot_main_model.svg", device = "svg", width = 8, height = 8, units = "in", dpi = 600)
```


# Bifurcating each gene in the gene signature of miRMS into high and low risk based on mean expression to see how expression impacts survival. This is in line with the reported HRs of the Cox model
```{r scl common high and low risk gene expression}
# TFRC
tfrc_only <- scl_common %>%
  select(patient.id, vital.status, time, sex, smoker, n.stage, m.stage, tfrc) %>%
  mutate(mean_expr = mean(tfrc)) %>%
  mutate(med_expr = median(tfrc)) %>%
  mutate(mean_expr_cat = ifelse(tfrc > mean_expr, "high", "low")) %>%
  mutate(med_expr_cat = ifelse(tfrc > med_expr, "high", "low")) %>%
  mutate(different_risk_cat = ifelse(mean_expr_cat != med_expr_cat, TRUE, FALSE))

fit <- survfit(Surv(tfrc_only$time, tfrc_only$vital.status) ~ med_expr_cat, data = tfrc_only)


p0 <- ggsurvplot(
  fit = fit,
  data = tfrc_only,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(2500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Expression",
  title = "TFRC",
  legend.labs = c("High expression", "Low expression"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)


# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "supplement_1_a.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "supplement_1_a.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")



# GRIN2B
grin2b_only <- scl_common %>%
  select(patient.id, vital.status, time, sex, smoker, n.stage, m.stage, grin2b) %>%
  mutate(mean_expr = mean(grin2b)) %>%
  mutate(med_expr = median(grin2b)) %>%
  mutate(mean_expr_cat = ifelse(grin2b > mean_expr, "high", "low")) %>%
  mutate(med_expr_cat = ifelse(grin2b > med_expr, "high", "low")) %>%
  mutate(different_risk_cat = ifelse(mean_expr_cat != med_expr_cat, TRUE, FALSE))

fit <- survfit(Surv(grin2b_only$time, grin2b_only$vital.status) ~ med_expr_cat, data = grin2b_only)


p1 <- ggsurvplot(
  fit = fit,
  data = grin2b_only,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(2500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Expression",
  title = "GRIN2B",
  legend.labs = c("High expression", "Low expression"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)

# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "supplement_1_b.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "supplement_1_b.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")


# GNG13
gng13_only <- scl_common %>%
  select(patient.id, vital.status, time, sex, smoker, n.stage, m.stage, gng13) %>%
  mutate(mean_expr = mean(gng13)) %>%
  mutate(med_expr = median(gng13)) %>%
  mutate(mean_expr_cat = ifelse(gng13 > mean_expr, "high", "low")) %>%
  mutate(med_expr_cat = ifelse(gng13 > med_expr, "high", "low")) %>%
  mutate(different_risk_cat = ifelse(mean_expr_cat != med_expr_cat, TRUE, FALSE))

fit <- survfit(Surv(gng13_only$time, gng13_only$vital.status) ~ med_expr_cat, data = gng13_only)


p2 <- ggsurvplot(
  fit = fit,
  data = gng13_only,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(2500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Expression",
  title = "GNG13",
  legend.labs = c("High expression", "Low expression"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)

# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "supplement_1_c.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "supplement_1_c.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")



# SAMD12
samd12_only <- scl_common %>%
  select(patient.id, vital.status, time, sex, smoker, n.stage, m.stage, samd12) %>%
  mutate(mean_expr = mean(samd12)) %>%
  mutate(med_expr = median(samd12)) %>%
  mutate(mean_expr_cat = ifelse(samd12 > mean_expr, "high", "low")) %>%
  mutate(med_expr_cat = ifelse(samd12 > med_expr, "high", "low")) %>%
  mutate(different_risk_cat = ifelse(mean_expr_cat != med_expr_cat, TRUE, FALSE))

fit <- survfit(Surv(samd12_only$time, samd12_only$vital.status) ~ med_expr_cat, data = samd12_only)


p3 <- ggsurvplot(
  fit = fit,
  data = samd12_only,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(2500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Expression",
  title = "SAMD12",
  legend.labs = c("High expression", "Low expression"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)

# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "supplement_1_d.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "supplement_1_d.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")



# FAM83f
fam83f_only <- scl_common %>%
  select(patient.id, vital.status, time, sex, smoker, n.stage, m.stage, fam83f) %>%
  mutate(mean_expr = mean(fam83f)) %>%
  mutate(med_expr = median(fam83f)) %>%
  mutate(mean_expr_cat = ifelse(fam83f > mean_expr, "high", "low")) %>%
  mutate(med_expr_cat = ifelse(fam83f > med_expr, "high", "low")) %>%
  mutate(different_risk_cat = ifelse(mean_expr_cat != med_expr_cat, TRUE, FALSE))

fit <- survfit(Surv(fam83f_only$time, fam83f_only$vital.status) ~ med_expr_cat, data = fam83f_only)


p4 <- ggsurvplot(
  fit = fit,
  data = fam83f_only,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(2500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Expression",
  title = "FAM83f",
  legend.labs = c("High expression", "Low expression"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)

# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "supplement_1_e.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "supplement_1_e.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")



# DLK1
dlk1_only <- scl_common %>%
  select(patient.id, vital.status, time, sex, smoker, n.stage, m.stage, dlk1) %>%
  mutate(mean_expr = mean(dlk1)) %>%
  mutate(med_expr = median(dlk1)) %>%
  mutate(mean_expr_cat = ifelse(dlk1 > mean_expr, "high", "low")) %>%
  mutate(med_expr_cat = ifelse(dlk1 > med_expr, "high", "low")) %>%
  mutate(different_risk_cat = ifelse(mean_expr_cat != med_expr_cat, TRUE, FALSE))

fit <- survfit(Surv(dlk1_only$time, dlk1_only$vital.status) ~ med_expr_cat, data = dlk1_only)


p5 <- ggsurvplot(
  fit = fit,
  data = dlk1_only,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(2500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Expression",
  title = "DLK1",
  legend.labs = c("High expression", "Low expression"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)

# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "supplement_1_f.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "supplement_1_f.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")

# Combo plot
combo_plot <- ggarrange(p0$plot, p4$plot, p1$plot, p5$plot, p2$plot, p3$plot, ncol = 3, nrow = 2, labels = "AUTO", font.label = list(size = 18), align = "hv", common.legend = TRUE)

# Saving as PNG
ggsave(combo_plot, path = "Figures/panels/", filename = "supplement_1_combo.png", device = "png", width = 12, height = 12, dpi = 600, units = "in", bg = "white")

# Saving as SVG
ggsave(combo_plot, path = "Figures/panels/", filename = "supplement_1_combo.svg", device = "svg", width = 12, height = 12, dpi = 600, units = "in", bg = "white")
```

# C-index for other methods on initial dataset
```{r desingle. 0.6521 C-index with 3 active predictors}
# Processing steps for generarting normal cells single-cell data
sc_df <- fread("Data/OMIX002441-01.csv")
sc_df <- sc_df %>%
  select(-matches("^(SCLC_P1|SCLC_P14)")) %>%
  t() # transpose the data frame to have cells as rows

# Set column names to the first row of the data frame
colnames(sc_df) <- sc_df["V1", ]
sc_df <- sc_df[-1, ] # remove first row, which is now redundant
sc_df <- as.data.frame(sc_df)

# Read in the metadata and filter for normal samples only
meta_data <- fread("Data/OMIX002441-02.csv")
meta_data <- meta_data %>%
  filter(NT == "normal")

# Set row names to the first column, which contains the cell IDs
colnames(meta_data)[1] <- "id"

# Join the two dataframes on the "id" column
sc_df$id <- rownames(sc_df)
sc_df <- inner_join(sc_df, meta_data, by = "id")
sc_df <- sc_df %>%
  mutate(id = paste0(id, "_", NT, "_", cell_type))
rownames(sc_df) <- sc_df$id
sc_df <- sc_df %>% select(
  -id, -patient, -NT, -tissue, -cell_type,
  -nCount_RNA, -nFeature_RNA, -Pre_Map_Reads,
  -Aligned_Reads, -MappingRate
)

# Keep only genes that are expressed in at least 10 cells
keep_cols <- colSums(sc_df > 0) > 10
sc_df <- sc_df[, keep_cols]


# Convert the data frame to integers
sc_df <- apply(sc_df, c(1, 2), as.integer) %>%
  as.data.frame()


# saveRDS(sc_df, "Outputs/normal_sc_df.rds")

# Denoising the normal cells
# Convert the sc_df dataframe to a matrix
sc_df_mat <- as.matrix(normal_sc_df)

sc_denoised <- magic(sc_df_mat, genes = "all_genes", seed = 1688405764, n.jobs = -1)

# Saving the denoised matrix
# saveRDS(sc_denoised, "Outputs/denoised_sc_normal_data_new_random_seed.rds")

# Removing intermediate files to keep environment tidy
rm(sc_df_mat)

# Now denoising the whole thing together
sc_df <- fread("Data/OMIX002441-01.csv")
sc_df <- sc_df %>%
  select(-matches("^(SCLC_P1|SCLC_P14)")) %>%
  t() # transpose the data frame to have cells as rows

# Set column names to the first row of the data frame
colnames(sc_df) <- sc_df["V1", ]
sc_df <- sc_df[-1, ] # remove first row, which is now redundant
sc_df <- as.data.frame(sc_df)

# Read in the metadata for all samples
meta_data <- fread("Data/OMIX002441-02.csv")

# Set row names to the first column, which contains the cell IDs
colnames(meta_data)[1] <- "id"

# Join the two dataframes on the "id" column
sc_df$id <- rownames(sc_df)
sc_df <- inner_join(sc_df, meta_data, by = "id")
sc_df <- sc_df %>%
  mutate(id = paste0(id, "_", NT))
rownames(sc_df) <- sc_df$id
sc_df <- sc_df %>% select(
  -id, -patient, -NT, -tissue, -cell_type,
  -nCount_RNA, -nFeature_RNA, -Pre_Map_Reads,
  -Aligned_Reads, -MappingRate
)

# Keep only genes that are expressed in at least 10 cells
keep_cols <- colSums(sc_df > 0) > 10
sc_df <- sc_df[, keep_cols]


# Convert the data frame to integers
sc_df <- apply(sc_df, c(1, 2), as.integer) %>%
  as.data.frame()


saveRDS(sc_df, "Outputs/all_sc_df.rds")

# Denoising the normal cells
# Convert the sc_df dataframe to a matrix
sc_df_mat <- as.matrix(all_sc_df)

sc_denoised <- magic(sc_df_mat, genes = "all_genes", seed = 1688405764, n.jobs = -1)

# Saving the denoised matrix
# saveRDS(sc_denoised$result, "Outputs/denoised_sc_all_data_new_random_seed.rds")

# Removing intermediate files to keep environment tidy
rm(sc_df_mat)


#Reading in single-cell files
all_tumor_cells_fpkm <- readRDS("Outputs/denoised_sc_data_new_random_seed.rds")
all_nm_cells_fpkm <- readRDS("Outputs/denoised_sc_normal_data_new_random_seed.rds")
all_cells <- readRDS("Outputs/denoised_sc_all_data_new_random_seed.rds")
all_cells <- t(all_cells)

condition <- unlist(colnames(all_cells) %>% str_extract_all("(normal|tumor)"))
condition <- ifelse(condition == "normal", 1, 2)
condition <- factor(condition)

sce <- SingleCellExperiment(assays=list(counts=all_cells))

des_results <- DEsingle(counts = sce, group = condition, parallel = TRUE,
                        BPPARAM = BiocParallel::bpparam())


saveRDS(des_results, file = "Outputs/des_results.rds")
write.csv(des_results, file = "Outputs/des_results.csv")

des_results <- filter(des_results, pvalue.adj.FDR < 0.05)
rownames(des_results) <- tolower(rownames(des_results))

gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1

for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(my_seed = 1688405764,
                                  my_alpha = 1,
                                  cox_predictors = rownames(des_results),
                                  cox_df = scl_common,
                                  gene_num = gn,
                                  n_folds = 10, 
                                  calc_auc = FALSE,
                                  save_coefs = TRUE,
                                  my_filename = paste0("Outputs/desingle/active_coefs/", gn, "_active_coefs.csv"),
                                  verbose = FALSE,
                                  my_folds = NULL)
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  active_genes <- current_cox$`Active Genes`
  active_coefs <- current_cox$`Active Coefficients`
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  cindex_df$active_genes <- paste(active_genes, collapse = ",")
  cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
  write.csv(cindex_df, paste0("Outputs/desingle/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_new_random_seed.csv"))
  counter <- counter + 1
}

# Now seeing what the best c-index is
all_desingle_cindices <- read_files(folder_path = "Outputs/desingle/", pattern = "*.csv")
all_desingle_cindices_sub <- all_desingle_cindices %>% filter(cindex_active_genes < 8)
max_desingle_cindex <- all_desingle_cindices_sub[which.max(all_desingle_cindices_sub$cindex), ] # 0.6521 with 3 active genes with new random seed
```

```{r scdd. 0.6469 C-index with 2 active predictors}
sce <- SingleCellExperiment(assays=list(normcounts= all_cells), colData=data.frame(condition))
prior_param <- list(alpha=0.01, mu0=0, s0=0.01, a0=0.01, b0=0.01)
scdd_res <- scDD(sce, prior_param=prior_param, testZeroes=FALSE, categorize = FALSE)
scdd_res <- results(scdd_res)

saveRDS(scdd_res, file = "Outputs/scdd_results.rds")
write.csv(scdd_res, file = "Outputs/scdd_results.csv")

scdd_res <- filter(scdd_res, nonzero.pvalue.adj < 0.05)

scdd_res$gene <- tolower(scdd_res$gene)

gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1

for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(my_seed = 1688405764,
                                  my_alpha = 1,
                                  cox_predictors = scdd_res$gene,
                                  cox_df = scl_common,
                                  gene_num = gn,
                                  n_folds = 10, 
                                  calc_auc = FALSE,
                                  save_coefs = TRUE,
                                  verbose = FALSE,
                                  my_folds = NULL,
                                  cat_preds = FALSE)
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  active_genes <- current_cox$`Active Genes`
  active_coefs <- current_cox$`Active Coefficients`
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  cindex_df$active_genes <- paste(active_genes, collapse = ",")
  cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
  write.csv(cindex_df, paste0("Outputs/scdd/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_new_random_seed.csv"))
  counter <- counter + 1
}

# Now seeing what the best c-index is
all_scdd_cindices <- read_files(folder_path = "Outputs/scdd/", pattern = "*.csv")
all_scdd_cindices_sub <- all_scdd_cindices %>% filter(cindex_active_genes < 8)
max_scdd_cindex <- all_scdd_cindices_sub[which.max(all_scdd_cindices_sub$cindex), ] # 0.6469 with 2 active genes with new random seed
```

```{r deseq2. 0.683 C-index with 1 active predictor}
all_cells <- readRDS("Outputs/denoised_sc_all_data_new_random_seed.rds")
all_cells <- t(all_cells)

all_cells <- apply(all_cells, c(1, 2), as.integer)

# Making a summarizedExperiment object from the combined data frame
deseq2_se <- SummarizedExperiment(
  assays = list(counts = as.matrix(all_cells)),
  colData = DataFrame(label = colnames(all_cells)),
  rowData = DataFrame(length = rownames(all_cells))
)

keep <- rowSums(assay(deseq2_se) > 5) > 10
table(keep)
zinb_data <- deseq2_se[keep, ]

normal_num <- rep("normal", 1394)
tumor_num <- rep("tumor", 1197)
all_nums <- c(tumor_num, normal_num)

zinb_data$cell_state <- all_nums
zinb_data <- zinb_data[names(zinb_data)[1:dim(zinb_data)[1]], ]

# For multicore
BiocParallel::register(BiocParallel::MulticoreParam())

zinb_data <- zinbwave(zinb_data,
  K = 0, BPPARAM = BiocParallel::bpparam(),
  epsilon = 1e12, normalizedValues = FALSE,
  observationalWeights = TRUE, verbose = TRUE
)

dds <- DESeqDataSet(zinb_data, design = ~cell_state)
dds_red <- DESeqDataSet(zinb_data, design = ~1)

dds <- estimateSizeFactors(dds, type = "poscounts")
dds_red <- estimateSizeFactors(dds_red, type = "poscounts")

scr <- scran::calculateSumFactors(dds)
sizeFactors(dds) <- scr

scr_red <- scran::calculateSumFactors(dds_red)
sizeFactors(dds_red) <- scr_red

dds <- DESeq(dds,
  sfType = "poscounts", useT = TRUE, minmu = 1e-6, minReplicatesForReplace = Inf,
  test = "LRT", reduced = ~1
)

res <- results(dds)
resSig <- subset(res, padj < 0.05)
# write.csv(as.data.frame(resSig), "Outputs/deseq2_res.csv")
deseq2_res <- read.csv("Outputs/deseq2_res.csv")
deseq2_res <- deseq2_res %>% 
  arrange(padj) %>%
  rename(gene = X)

deseq2_res$gene <- tolower(deseq2_res$gene)

gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1

for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(my_seed = 1688405764,
                                  my_alpha = 1,
                                  cox_predictors = deseq2_res$gene,
                                  cox_df = scl_common,
                                  gene_num = gn,
                                  n_folds = 10, 
                                  calc_auc = FALSE,
                                  save_coefs = FALSE,
                                  verbose = FALSE,
                                  my_folds = NULL,
                                  cat_preds = FALSE)
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  active_genes <- current_cox$`Active Genes`
  active_coefs <- current_cox$`Active Coefficients`
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  cindex_df$active_genes <- paste(active_genes, collapse = ",")
  cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
  write.csv(cindex_df, paste0("Outputs/deseq2/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_new_random_seed.csv"))
  counter <- counter + 1
}

# Now seeing what the best c-index is
all_deseq2_cindices <- read_files(folder_path = "Outputs/deseq2/", pattern = "*.csv")
all_deseq2_cindices_sub <- all_deseq2_cindices %>% filter(cindex_active_genes < 8)
max_deseq2_cindex <- all_deseq2_cindices_sub[which.max(all_deseq2_cindices_sub$cindex), ] # 0.683 with 1 active genes with new random seed
```

```{r edgeR. 0.6469 with 2 active predictors}
dge <- DGEList(assay(zinb_data))
dge <- calcNormFactors(dge)

weights <- assay(zinb_data, "weights")


design <- model.matrix(~cell_state, data = colData(zinb_data))
dge$weights <- weights
dge <- estimateDisp(dge, design)
fit <- glmFit(dge, design)

lrt <- glmWeightedF(fit, coef = 1:2)
topTags(lrt)

finished_edger <- lrt$table
finished_edger <- finished_edger %>% arrange(padjFilter)
# write.csv(finished_edger, "Outputs/edger_res.csv")

rownames(finished_edger) <- finished_edger$X
rownames(finished_edger) <- tolower(rownames(finished_edger))

gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1

for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(my_seed = 1688405764,
                                  my_alpha = 1,
                                  cox_predictors = rownames(finished_edger),
                                  cox_df = scl_common,
                                  gene_num = gn,
                                  n_folds = 10, 
                                  calc_auc = FALSE,
                                  save_coefs = FALSE,
                                  verbose = FALSE,
                                  my_folds = NULL,
                                  cat_preds = FALSE)
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  active_genes <- current_cox$`Active Genes`
  active_coefs <- current_cox$`Active Coefficients`
  cindex_df$active_genes <- paste(active_genes, collapse = ",")
  cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
  write.csv(cindex_df, paste0("Outputs/edger/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_new_random_seed.csv"))
  counter <- counter + 1
}

# Now seeing what the best c-index is
all_edger_cindices <- read_files(folder_path = "Outputs/edger/", pattern = "*.csv")
all_edger_cindices_sub <- all_edger_cindices %>% filter(cindex_active_genes < 8)
max_edger_cindex <- all_edger_cindices_sub[which.max(all_edger_cindices_sub$cindex), ] # 0.6469 with 2 active genes with new random seed
```

# C-index of other methods on simulated datasets
# DEsingle
```{r desingle first simulated dataset 3%. 0.6506907 C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# When using many random seeds we get a mean performance of X for 3% survival. 
# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("dek", "hmgn2", "cox7a2"))
rownames(cox_preds) <- cox_preds$preds

# Filtering to just those predictors that are common to the simulated dataset
cox_preds <- cox_preds %>%
  filter(preds != "hmgn2")

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/desingle_random_seeds_first_validation_dataset_3_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r desingle first simulated dataset 7%.  0.66584 C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_7_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("dek", "hmgn2", "cox7a2"))
rownames(cox_preds) <- cox_preds$preds

# Filtering to just those predictors that are common to the simulated dataset
cox_preds <- cox_preds %>%
  filter(preds != "hmgn2")

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/desingle_random_seeds_first_validation_dataset_7_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r desingle first simulated dataset 18%.  0.7527975 C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_18_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("dek", "hmgn2", "cox7a2"))
rownames(cox_preds) <- cox_preds$preds

# Filtering to just those predictors that are common to the simulated dataset
cox_preds <- cox_preds %>%
  filter(preds != "hmgn2")

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/desingle_random_seeds_first_validation_dataset_18_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r desingle first simulated dataset 30%.  0.7538261 C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_30_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("dek", "hmgn2", "cox7a2"))
rownames(cox_preds) <- cox_preds$preds

# Filtering to just those predictors that are common to the simulated dataset
cox_preds <- cox_preds %>%
  filter(preds != "hmgn2")

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/desingle_random_seeds_first_validation_dataset_30_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r desingle second simulated dataset 3%. 0.7540853 C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("dek", "hmgn2", "cox7a2"))
rownames(cox_preds) <- cox_preds$preds

# Filtering to just those predictors that are common to the simulated dataset
cox_preds <- cox_preds %>%
  filter(preds != "hmgn2")

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/desingle_random_seeds_second_validation_dataset_3_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r desingle second simulated dataset 7%.  0.7402912 C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_7_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("dek", "hmgn2", "cox7a2"))
rownames(cox_preds) <- cox_preds$preds

# Filtering to just those predictors that are common to the simulated dataset
cox_preds <- cox_preds %>%
  filter(preds != "hmgn2")

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/desingle_random_seeds_second_validation_dataset_7_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r desingle second simulated dataset 18%.  0.782706 C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_18_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("dek", "hmgn2", "cox7a2"))
rownames(cox_preds) <- cox_preds$preds

# Filtering to just those predictors that are common to the simulated dataset
cox_preds <- cox_preds %>%
  filter(preds != "hmgn2")

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/desingle_random_seeds_second_validation_dataset_18_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r desingle second simulated dataset 30%.  0.7452534 C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_30_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("dek", "hmgn2", "cox7a2"))
rownames(cox_preds) <- cox_preds$preds

# Filtering to just those predictors that are common to the simulated dataset
cox_preds <- cox_preds %>%
  filter(preds != "hmgn2")

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/desingle_random_seeds_second_validation_dataset_30_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```
# scDD
```{r scdd first simulated dataset 3%. 0.7359185 C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/scdd_random_seeds_first_validation_dataset_3_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r scdd first simulated dataset 7%.  0.7392963 C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_7_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds


# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/scdd_random_seeds_first_validation_dataset_7_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r scdd first simulated dataset 18%.  0.7436603 C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_18_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)


# Cox preds identified by scDD
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/scdd_random_seeds_first_validation_dataset_18_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r scdd first simulated dataset 30%.  0.7365927 C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_30_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/scdd_random_seeds_first_validation_dataset_30_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r scdd second simulated dataset 3%. 0.7358584 C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds


# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/scdd_random_seeds_second_validation_dataset_3_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r scdd second simulated dataset 7%.  0.639216 C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_7_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds


# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/scdd_random_seeds_second_validation_dataset_7_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r scdd second simulated dataset 18%.  0.696218 C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_18_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/scdd_random_seeds_second_validation_dataset_18_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r scdd second simulated dataset 30%.  0.4861707 C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_30_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds


# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/scdd_random_seeds_second_validation_dataset_30_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

# DESeq2 (can't test on either dataset because its gene isn't in either of them)
```{r deseq2 first simulated dataset 3%. X C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("rpl9"))
rownames(cox_preds) <- cox_preds$preds

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/deseq2_random_seeds_first_validation_dataset_3_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 1,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r deseq2 first simulated dataset 7%.  X C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_7_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("rpl9"))
rownames(cox_preds) <- cox_preds$preds


# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/deseq2_random_seeds_first_validation_dataset_7_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r deseq2 first simulated dataset 18%.  X C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_18_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)


# Cox preds identified by scDD
cox_preds <- data.frame(preds = c("rpl9"))
rownames(cox_preds) <- cox_preds$preds

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/deseq2_random_seeds_first_validation_dataset_18_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 1,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r deseq2 first simulated dataset 30%.  X C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_30_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("rpl9"))
rownames(cox_preds) <- cox_preds$preds

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/deseq2_random_seeds_first_validation_dataset_30_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 1,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r deseq2 second simulated dataset 3%. X C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("rpl9"))
rownames(cox_preds) <- cox_preds$preds


# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/deseq2_random_seeds_second_validation_dataset_3_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 1,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r deseq2 second simulated dataset 7%.  X C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_7_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("rpl9"))
rownames(cox_preds) <- cox_preds$preds


# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/deseq2_random_seeds_second_validation_dataset_7_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 1,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r deseq2 second simulated dataset 18%.  X C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_18_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("rpl9"))
rownames(cox_preds) <- cox_preds$preds

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/deseq2_random_seeds_second_validation_dataset_18_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 1,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r deseq2 second simulated dataset 30%.  X C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_30_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("rpl9"))
rownames(cox_preds) <- cox_preds$preds


# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/deseq2_random_seeds_second_validation_dataset_30_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 1,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```
# EdgeR 
```{r edger first simulated dataset 3%. 0.7359185 C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/edger_random_seeds_first_validation_dataset_3_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r edger first simulated dataset 7%.  0.7452796 C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_7_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds


# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/edger_random_seeds_first_validation_dataset_7_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r edger first simulated dataset 18%.  0.7436603 C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_18_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)


# Cox preds identified by scDD
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/edger_random_seeds_first_validation_dataset_18_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r edger first simulated dataset 30%.  0.7365927 C-index}
simulated_dataset <- read.csv("Outputs/first_simulated_validation_30_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/edger_random_seeds_first_validation_dataset_30_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r edger second simulated dataset 3%. 0.7358584 C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds


# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/edger_random_seeds_second_validation_dataset_3_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r edger second simulated dataset 7%.  0.639216 C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_7_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds


# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/edger_random_seeds_second_validation_dataset_7_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r edger second simulated dataset 18%. 0.696218 C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_18_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/edger_random_seeds_second_validation_dataset_18_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

```{r edger second simulated dataset 30%.  0.4861707 C-index}
simulated_dataset <- read.csv("Outputs/second_simulated_validation_30_percent_dataset.csv", row.names = 1)
simulated_dataset <- simulated_dataset %>%
  rename("vital.status" = status)

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Cox preds identified by DEsingle
cox_preds <- data.frame(preds = c("anxa1","arl6ip1"))
rownames(cox_preds) <- cox_preds$preds


# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/edger_random_seeds_second_validation_dataset_30_percent.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = simulated_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 5,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}



mean(c_index_vector)
```

# Plotting the other methods on initial/training dataset
```{r plotting other methods}
other_methods_df <- data.frame(c_index = c(0.6521, 0.6469, 0.683,0.6469, 0.7243224), method = c("DEsingle", "scDD", "DEseq2", "edgeR", "miRMS"))

other_methods_df$method <- factor(other_methods_df$method, levels = c("miRMS", "DEsingle", "scDD", "DEseq2", "edgeR"))

p0 <- ggplot(data = other_methods_df, aes(x = method, y = c_index))+
  geom_col(width = 0.3, fill = "skyblue")+
  xlab("Method")+
  ylab("Mean 10-fold\nCV C-index")+
  scale_y_continuous(expand = c(0,0))+
  scale_x_discrete(expand = c(0,0))+
  coord_cartesian(ylim = c(0.5, 0.75))+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text.x = element_text(size = 14, angle = 45, vjust = 0.6, hjust = 0.6),
        axis.text.y = element_text(size = 14))
p0

ggsave(p0, filename = "initial_dataset_mirms_vs_other_methods.png", path = "Figures/panels/", dpi = 600, width = 7, height = 7, units = "in")
ggsave(p0, filename = "initial_dataset_mirms_vs_other_methods.svg", path = "Figures/panels/", dpi = 600, width = 7, height = 7, units = "in")


```
# Line Plot for first validation dataset
```{r line plot of first validation dataset other methods}
validation_1_df <- read.csv("Data/first_validation_cindex_df_other_methods.csv", row.names = 1)
validation_1_df <- na.omit(validation_1_df)
# validation_1_df <- validation_1_df %>% select(-X)
p1 <- ggplot(data = validation_1_df, aes(x = surv_rate, y = c_index, group = method, color = method))+
  geom_line(linewidth = 1.75)+
  geom_point(size = 2.5)+
  xlab("Survival Rate (%)")+
  ylab("Mean C-index\nof 1000 10-fold CVs")+
  ggtitle("First Validation Dataset")+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, hjust = 0.5, face = "bold"),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14),
        legend.position = "bottom",
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 14),
        legend.key=element_blank())+
  scale_color_discrete(name = "Method")+
  coord_cartesian(ylim = c(0.50, 0.90))

p1

ggsave(p1, filename= "first_validation_panel.png", units = "in", dpi = 600, path = "Figures/panels/", width = 8, height = 8)
```

# Line Plot for second validation dataset
```{r line plot of second validation dataset other methods}
validation_2_df <- read.csv("Data/second_validation_cindex_df_other_methods.csv", row.names = 1)
validation_2_df <- na.omit(validation_2_df)
# validation_2_df <- validation_2_df %>% select(-X)
p2 <- ggplot(data = validation_2_df, aes(x = surv_rate, y = c_index, group = method, color = method))+
  geom_line(linewidth = 1.75)+
  geom_point(size = 2.5)+
  xlab("Survival Rate (%)")+
  ylab("Mean C-index\nof 1000 10-fold CVs")+
  ggtitle("Second Validation Dataset")+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, hjust = 0.5, face = "bold"),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14),
        legend.position = "bottom",
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 14),
        legend.key=element_blank())+
  scale_color_discrete(name = "Method")+
  coord_cartesian(ylim = c(0.50, 0.90))

p2

ggsave(p2, filename= "second_validation_panel.png", units = "in", dpi = 600, path = "Figures/panels/", width = 8, height = 8)
```
# Combo panel comparing other methods
```{r combo plot other methods validation data}
combo_plot <- ggarrange(p0, p1, p2, ncol = 3, nrow = 1, labels = "AUTO", font.label = list(size = 18, face = "bold"), align = "h", common.legend = TRUE, legend = "bottom")
```

```{r saving the combo plot}
ggsave(combo_plot, device = "png", width = 20, height = 11.25, path = "Figures/finished_figures/", filename = "combo_plot_other_methods.png", units = "in", dpi = 600, bg = "white")
```

# Now looking to take our initial dataset and determine if we see differences in survival or performance by sex. Should be in line with literature that women live longer
```{r male sex based performance 0.7326331 C-index with all 6 predictors. 0.6988956 with 5 predictors (all save dlk1)}
male_df <- scl_common %>%
  filter(sex == "Male")

# cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13"))
# rownames(cox_preds) <- cox_preds$preds

# Removing DLK1 so we have 5 predictors with 51 samples to avoid overfitting to smaller data. It had the smallest impact on survival according to forestplot
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "gng13"))
rownames(cox_preds) <- cox_preds$preds

# When using many random seeds we get a mean performance of X. 
# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_male_only_training_data_5_preds.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = male_df,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)



# Reading in the random seeds to ensure we get the same result and so that we can also save all of the information of every point of the c_index vector
male_df <- scl_common %>%
  filter(sex == "Male")

cox_preds <- data.frame(preds = c("tfrc", "samd12", "grin2b", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds

# Number of iterations
num_iterations <- 1000

# Read the random seeds file into a vector
random_seeds <- as.vector(read.table("Outputs/random_seeds_male_only_training_data_5_preds.csv", header = FALSE))

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- random_seeds[[1]][i]

  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = male_df,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]

  # Store the c-index value in the vector
  c_index_vector[i] <- c_index

  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)

# Saving the c_index_vector to file
write.csv(c_index_vector, "Outputs/male_c_index_vector.csv")
```

# Female based model
```{r female only model 0.9030525 C-index. 0.6950832 with only TFRC and SAMD12. 0.84167 with TFRC and GRIN2B @ 1000 reps. 0.8361392 @ 5000 reps}
female_df <- scl_common %>%
  filter(sex == "Female")

# Just selecting the best 2 genes from the signature because of the small number of female patients
cox_preds <- data.frame(preds = c("tfrc", "grin2b"))
rownames(cox_preds) <- cox_preds$preds

# When using many random seeds we get a mean performance of X. 
# Number of iterations
num_iterations <- 5000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_female_only_training_data_10000.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = female_df,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)


# Reading in the random seeds to ensure we get the same result and so that we can also save all of the information of every point of the c_index vector
female_df <- scl_common %>%
  filter(sex == "Female")

cox_preds <- data.frame(preds = c("tfrc", "grin2b"))
rownames(cox_preds) <- cox_preds$preds

# Number of iterations
num_iterations <- 1000

# Read the random seeds file into a vector
random_seeds <- as.vector(read.table("Outputs/random_seeds_female_only_training_data_10000.csv", header = FALSE))

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- random_seeds[[1]][i]

  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = female_df,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]

  # Store the c-index value in the vector
  c_index_vector[i] <- c_index

  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)

# Saving the c_index_vector to file
write.csv(c_index_vector, "Outputs/female_c_index_vector.csv")
```


```{r calculating stats for male v female performance}
male_df <- read.csv("Outputs/male_c_index_vector.csv", row.names = 1)
male_df$sex <- rep("Male", nrow(male_df))
colnames(male_df)[1] <- "c_index"

female_df <- read.csv("Outputs/female_c_index_vector.csv", row.names = 1)
female_df$sex <- rep("Female", nrow(female_df))
colnames(female_df)[1] <- "c_index"

sex_specific_df <- bind_rows(male_df, female_df)


# Check the assumptions for the t-test
assumptions_met <- TRUE

# Check for normality assumption
if (!shapiro.test(sex_specific_df$c_index)$p.value > 0.05) {
  assumptions_met <- FALSE
  message("Normality assumption not met. Trying Wilcoxon signed-rank test instead.")
}

# Check for homogeneity of variances assumption (Levene's test)
if (assumptions_met && !car::leveneTest(c_index ~ sex, data = sex_specific_df)$p.value > 0.05) {
  assumptions_met <- FALSE
  message("Homogeneity of variances assumption not met. Trying Wilcoxon signed-rank test instead.")
}

# Perform the appropriate test based on assumptions
if (assumptions_met) {
  # Perform t-test
  t_test_result <- t.test(c_index ~ sex, data = sex_specific_df)
  p_value <- t_test_result$p.value
  test_used <- "t-test"
} else {
  # Perform Wilcoxon signed-rank test
  wilcox_result <- wilcox.test(c_index ~ sex, data = sex_specific_df)
  p_value <- wilcox_result$p.value
  test_used <- "Wilcoxon signed-rank test"
}

# Print the results
cat("Test Used:", test_used, "\n")
cat("P-Value:", p_value, "\n")
p_value_formatted <- format_p(p = p_value, stars = TRUE, stars_only = TRUE)
```



# Making plots for male and female only models on initial dataset
```{r plotting male and female only models}
# sex_specific_df <- data.frame(sex = c("Male", "Female"), c_index = c(0.6988956, 0.8361392))
sex_specific_df$sex <- factor(sex_specific_df$sex, levels = c("Male", "Female"))

p3 <- ggplot(data = sex_specific_df, aes(x = sex, y = c_index))+
  geom_violin()+
  geom_sina()+
  xlab("Sex")+
  ylab("C-index of\n 1000 10-fold CVs")+
  ggtitle("Sex-Specific")+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, hjust = 0.5, face = "bold"),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14),
        legend.position = "none",
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 14))+
  scale_x_discrete(breaks = c("Male", "Female"),
                   labels = c("Male \n(n = 51)",
                              "Female \n(n = 21)"))+
  geom_signif(annotations = "***", xmin = 1, xmax = 2, y_position = 1.05, tip_length = 0, vjust = 0.5)

p3


ggsave(p3, filename= "sex_specific_panel.png", units = "in", dpi = 600, path = "Figures/panels/", width = 8, height = 8)

```

# Combo plot continuing to be built
```{r combo plot other methods validation data with sex data}
combo_plot <- ggarrange(p0, p1, p2, p3, ncol = 2, nrow = 2, labels = "AUTO", font.label = list(size = 18, face = "bold"), align = "hv", common.legend = TRUE, legend = "bottom")
```


# Now looking to take our initial dataset and determine what type of subtype it has and see if survival differs across subtypes
```{r cancer subtyping survival 0.7002429 C-index for subtype A}
scl_common <- scl_common %>%
  mutate(
    # Calculate the maximum expression value across the specified genes for each patient
    max_expression = pmax(ascl1, yap1, neurod1, pou2f3)
  ) %>%
  rowwise() %>%
  mutate(
    # Create a new column to indicate the category (A, Y, N, P) for each patient
    subtype = case_when(
      max_expression == ascl1 ~ "A",
      max_expression == yap1 ~ "Y",
      max_expression == neurod1 ~ "N",
      max_expression == pou2f3 ~ "P",
      TRUE ~ NA_character_
    )
  ) %>%
  ungroup()

scl_common <- scl_common %>%
  filter(subtype == "A" | subtype == "N" | subtype == "P")


generate_matched_samples <- function(data, subtype_column=subtype, subtype_to_match, num_samples_to_generate, replace = TRUE) {
  # Filter the DataFrame to get samples with the specified subtype
  subtype_data <- data %>%
    filter({{ subtype_column }} == subtype_to_match)
  
  # Use the slice_sample() function from dplyr to randomly select samples
  generated_samples <- subtype_data %>%
    slice_sample(n = num_samples_to_generate, replace = replace)
  
  return(generated_samples)
}


# Power analysis for each subtype
# Adjust the function and arguments based on your test and data
# f = 0.2 equal small effect size, 0.5 = medium effect size, 0.8 = large effect size
power_analysis <- pwr.anova.test(f = 0.2, k = 4, power = 0.95, sig.level = 0.05)

# Extract the required sample size
required_sample_size <- ceiling(power_analysis$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")


for (s in unique(scl_common$subtype)){
  current_sub <- filter(scl_common, subtype == s)
  current_sub <- generate_matched_samples(scl_common, subtype_to_match = paste0(s), num_samples_to_generate = required_sample_size, replace = TRUE)
  message(paste0("On subtype: ", s))
  # Number of iterations
  num_iterations <- 1000
  
  cox_preds <- data.frame(preds = c("tfrc", "grin2b", "fam83f", "samd12", "dlk1", "gng13"))
  rownames(cox_preds) <- cox_preds$preds
  
  # Create a progress bar
  pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (i in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/random_seeds_initial_training_set_subtype_",s,"_with_power_analysis_95_second_time.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = current_sub,
      gene_num = 6,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[i] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  current_df <- data.frame(subtype = rep(s, length(c_index_vector)), c_index = c_index_vector)
  View(current_df)
  write.csv(current_df, file = paste0("Outputs/subtype_",s,"_c_index_peformance.csv"))
  
  
  print(mean(c_index_vector))
  
}

```

```{r now plotting the c-index of different subtypes}
# subtype_df <- data.frame(subtype = c("A", "N", "P", "Y"), c_index = c(0.7118364 , 0.9135011, 0.8487988, 1), subtype_count = c(109, 109, 109, 109))

subtype_df_a <- read.csv("Outputs/subtype_A_c_index_peformance.csv", row.names = 1)
subtype_df_n <- read.csv("Outputs/subtype_N_c_index_peformance.csv", row.names = 1)
subtype_df_p <- read.csv("Outputs/subtype_P_c_index_peformance.csv", row.names = 1)
subtype_df_y <- read.csv("Outputs/subtype_Y_c_index_peformance.csv", row.names = 1)

subtype_df <- bind_rows(subtype_df_a, subtype_df_n, subtype_df_p, subtype_df_y)

# p4 <- ggplot(data = subtype_df, aes(x = subtype, y = c_index, fill = c_index_type))+
#   geom_col(width = 0.3, fill = "skyblue")+
#   xlab("Subtype")+
#   ylab("Mean C-index\n1000 10-fold CVs")+
#   ggtitle("Subtype-Specific")+
#   theme(panel.background = element_blank(),
#         plot.title = element_text(size = 18, hjust = 0.5, face = "bold"),
#         axis.title = element_text(size = 16, face = "bold"),
#         axis.text = element_text(size = 14),
#         legend.position = "none")+
#   coord_cartesian(ylim = c(0.5, 1.0))+
#   scale_x_discrete(breaks = c("A", "N", "P", "Y"),
#                    labels = c("A \n(n = 109)",
#                               "N \n(n = 109)",
#                               "P \n(n = 109)",
#                               "Y \n(n = 109)"))
#   
# 
# p4


p4 <- ggplot(data = subtype_df, aes(x = subtype, y = c_index))+
  geom_violin()+
  geom_sina()+
  xlab("Subtype")+
  ylab("Mean C-index\nof 1000 10-fold CVs")+
  ggtitle("Subtype-Specific", subtitle = "All pairwise p-values < 0.001")+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = 14, hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text.x = element_text(size = 14, angle = 45),
        legend.position = "none")+
  coord_cartesian(ylim = c(0.5, 1.0))+
  scale_x_discrete(breaks = c("A", "N", "P", "Y"),
                   labels = c("A\n(n = 109)",
                              "N\n(n = 109)",
                              "P\n(n = 109)",
                              "Y\n(n = 109)"))
  

p4


ggsave(p4, filename = "4a.svg", path = "Figures/panels/", dpi = 600, device = "svg", units = "in", width = 8, height = 8, bg = "white")


ggsave(p4, filename = "4a.png", path = "Figures/panels/", dpi = 600, device = "png", units = "in", width = 8, height = 8, bg = "white")

anova_test <- aov(c_index~subtype, data = subtype_df)
summary(anova_test)


kw_test <- kruskal.test(c_index~subtype, data = subtype_df)
summary(kw_test)

dunn_test <- dunn.test(subtype_df$c_index, subtype_df$subtype, method = "bonferroni")


# Create a matrix with row and column names
p_value_matrix <- matrix(data = c(0.00, 2.26e-84, 2.26e-84, 0.00, 2.26e-84, 0.00),
                         nrow = 4, ncol = 4,
                         dimnames = list(c("A", "N", "P", "Y"), c("A", "N", "P", "Y")))

# Round the p-values to 2 decimal places
p_value_matrix <- signif(p_value_matrix, digits = 2)

# Print the matrix
print(p_value_matrix)
```



```{r saving 4b heatmap png}
png(filename = "Figures/panels/4b_heatmap.png", width = 10, height = 10, units = "in", res = 1080)
par(cex.main=4)
p4b <- heatmap.2(x = p_value_matrix, dendrogram = "none", trace = "none", Rowv = NA, Colv = NA, cellnote = p_value_matrix, notecol = "black", key = FALSE, xlab = "Subtype", ylab = "Subtype", notecex = 3, cexCol = 4, cexRow = 4)
dev.off()
```

```{r saving 4b heatmap svg}
svg(filename = "Figures/panels/4b_heatmap.svg", width = 10, height = 10)
par(cex.main=4)
p4b <- heatmap.2(x = p_value_matrix, dendrogram = "none", trace = "none", Rowv = NA, Colv = NA, cellnote = p_value_matrix, notecol = "black", key = FALSE, xlab = "Subtype", ylab = "Subtype", notecex = 3, cexCol = 4, cexRow = 4)
dev.off()
```


```{r combo plot with subtype specific info}
combo_plot <- ggarrange(p0, p1, p2,p3, p4, ncol = 2, nrow = 3, labels = "AUTO", font.label = list(size = 18, face = "bold"), align = "v", common.legend = FALSE, legend = "bottom")
```

# Signature across cancer stages
```{r tumor stages}
# I
scl_common <- scl_common %>%
  mutate(
    uicc.tumor.stage = case_when(
      uicc.tumor.stage %in% c("I", "Ia", "Ib", "IB") ~ "I",
      TRUE ~ uicc.tumor.stage
    )
  )


# II
scl_common <- scl_common %>%
  mutate(
    uicc.tumor.stage = case_when(
      uicc.tumor.stage %in% c("II", "IIa", "IIb") ~ "II",
      TRUE ~ uicc.tumor.stage
    )
  )

# III
scl_common <- scl_common %>%
  mutate(
    uicc.tumor.stage = case_when(
      uicc.tumor.stage %in% c("III", "IIIa", "IIIb") ~ "III",
      TRUE ~ uicc.tumor.stage
    )
  )

# I C-index: 0.7733051
first_stage_df <- filter(scl_common, uicc.tumor.stage == "I")

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds

# When using many random seeds we get a mean performance of X. 
# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_first_tumor_stage_only_training_data_4_preds_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = first_stage_df,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)


# I + II C-index: 0.7826456
second_stage_df <- filter(scl_common, uicc.tumor.stage == "I" | uicc.tumor.stage == "II")

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds

# When using many random seeds we get a mean performance of X. 
# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_first_and_second_tumor_stage_only_training_data_4_preds_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = second_stage_df,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)

# III + IV C-index: 0.6351198
late_stage_df <- filter(scl_common, uicc.tumor.stage == "III" | uicc.tumor.stage == "IV")

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_third_and_fourth_tumor_stage_only_training_data_4_preds_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = late_stage_df,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)


# Reading in the random seeds to ensure we get the same result and so that we can also save all of the information of every point of the c_index vector
# III + IV C-index: 0.6351198
late_stage_df <- filter(scl_common, uicc.tumor.stage == "III" | uicc.tumor.stage == "IV")
cox_preds <- data.frame(preds = c("tfrc", "samd12", "grin2b", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds

# Number of iterations
num_iterations <- 1000

# Read the random seeds file into a vector
random_seeds <- as.vector(read.table("Outputs/random_seeds_third_and_fourth_tumor_stage_only_training_data_6_preds.csv", header = FALSE))

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- random_seeds[[1]][i]

  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = late_stage_df,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]

  # Store the c-index value in the vector
  c_index_vector[i] <- c_index

  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)

# Saving the c_index_vector to file
write.csv(c_index_vector, "Outputs/late_tumor_staging_c_index_vector.csv")
```

```{r plot for tumor staging}
# tumor_df <- data.frame(tumor_stage = c("Early", "Late"), c_index = c(0.7459087,0.6351198))
tumor_df_early <- read.csv("Outputs/early_tumor_staging_c_index_vector.csv", row.names = 1)
tumor_df_early$tumor_stage <- rep("Early", nrow(tumor_df_early))
colnames(tumor_df_early)[1] <- "c_index"

tumor_df_late <- read.csv("Outputs/late_tumor_staging_c_index_vector.csv", row.names = 1)
tumor_df_late$tumor_stage <- rep("Late", nrow(tumor_df_late))
colnames(tumor_df_late)[1] <- "c_index"

tumor_df <- bind_rows(tumor_df_early, tumor_df_late)

p5 <- ggplot(data = tumor_df, aes(x = tumor_stage, y = c_index))+
  geom_violin()+
  geom_sina()+
  xlab("Tumor Staging")+
  ylab("C-index of\n 1000 10-fold CVs")+
  ggtitle("Tumor Severity")+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, hjust = 0.5, face = "bold"),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 14))+
  scale_x_discrete(breaks = c("Early", "Late"),
                   labels = c("Early \n(n = 44)",
                              "Late \n(n = 28)"))+
  geom_signif(annotations = "***", xmin = 1, xmax = 2, y_position = 1.05, tip_length = 0, vjust = 0.5)
  

p5

ggsave(p5, filename= "tumor_staging_panel.png", units = "in", dpi = 600, path = "Figures/panels/", width = 8, height = 8)
```

```{r calculating stats}
# Check the assumptions for the t-test
assumptions_met <- TRUE

# Check for normality assumption
if (!shapiro.test(tumor_df$c_index)$p.value > 0.05) {
  assumptions_met <- FALSE
  message("Normality assumption not met. Trying Wilcoxon signed-rank test instead.")
}

# Check for homogeneity of variances assumption (Levene's test)
if (assumptions_met && !car::leveneTest(c_index ~ tumor_stage, data = tumor_df)$p.value > 0.05) {
  assumptions_met <- FALSE
  message("Homogeneity of variances assumption not met. Trying Wilcoxon signed-rank test instead.")
}

# Perform the appropriate test based on assumptions
if (assumptions_met) {
  # Perform t-test
  t_test_result <- t.test(c_index ~ tumor_stage, data = your_data)
  p_value <- t_test_result$p.value
  test_used <- "t-test"
} else {
  # Perform Wilcoxon signed-rank test
  wilcox_result <- wilcox.test(c_index ~ tumor_stage, data = tumor_df)
  p_value <- wilcox_result$p.value
  test_used <- "Wilcoxon signed-rank test"
}

# Print the results
cat("Test Used:", test_used, "\n")
cat("P-Value:", p_value, "\n")
p_value_formatted <- format_p(p = p_value, stars = TRUE, stars_only = TRUE)
```

```{r completed combo plot}
combo_plot <- ggarrange(p0, p1, p2, p3, p4, p5, ncol = 2, nrow = 3, labels = "AUTO", font.label = list(size = 18, face = "bold"), align = "hv", common.legend = TRUE, legend = "bottom")
```

```{r saving combo plot}
ggsave(combo_plot, device = "png", path = "Figures/finished_figures/", filename = "figure5.png", width = 9, height = 9, units = "in", dpi = 600, bg = "white")
ggsave(combo_plot, device = "svg", path = "Figures/finished_figures/", filename = "figure5.svg", width = 9, height = 9, units = "in", dpi = 600, bg = "white")
```
# Correlation analysis between signature and EMT genes
```{r emt correlation}
emt_genes <- read.csv("Data/emt_genes_tian.txt", sep = "\t")
emt_genes <- apply(emt_genes, c(1,2), tolower)
emt_genes <- as.data.frame(emt_genes)
# emt_genes <- filter(emt_genes, Gene == c("zeb1", "cdh1", "vim"))
emt_genes_common <- intersect(emt_genes$Gene, colnames(scl_common))


e_genes <- filter(emt_genes, Annotation == "e")
e_genes_common <- intersect(e_genes$Gene, colnames(scl_common))
m_genes <- filter(emt_genes, Annotation == "m")
m_genes_common <- intersect(m_genes$Gene, colnames(scl_common))

# E correlation
sig_genes <- c("tfrc", "samd12", "dlk1", "grin2b", "fam83f", "gng13")
e_df <- data.frame()

for (s in sig_genes){
  for (e in e_genes_common){
    current_cor <- cor.test(scl_common[,paste0(s)], scl_common[, paste0(e)])
    message("Correlation of ", s, " vs. ", e, " is: ", (current_cor$estimate)*100)
    current_obs <- data.frame(sig_gene = s, emt_gene = e, rho = current_cor$estimate)
    e_df <- rbind(e_df, current_obs)
  }
}

# Specific genes from our sig in E genes
tfrc_e_df <- filter(e_df, sig_gene == "tfrc")
hist(tfrc_e_df$rho)

grin2b_e_df <- filter(e_df, sig_gene == "grin2b")
hist(grin2b_e_df$rho)

samd12_e_df <- filter(e_df, sig_gene == "samd12")
hist(samd12_e_df$rho)

# Testing if the majority of rhos are less than 0 (e.g. negatively correlated with M genes)
result <- SIGN.test(samd12_e_df$rho, md = 0, alternative = "less")

# Print the result
print(result)

result <- t.test(grin2b_e_df$rho, mu = 0, alternative = "less")

print(result)



# M correlation
sig_genes <- c("tfrc", "samd12", "dlk1", "grin2b", "fam83f", "gng13")
sig_genes <- c("tfrc")
m_df <- data.frame()

for (s in sig_genes){
  for (m in m_genes_common[180]){
    current_cor <- cor.test(scl_common[,paste0(s)], scl_common[, paste0(m)])
    message("Correlation of ", s, " vs. ", m, " is: ", (current_cor$estimate))
    current_obs <- data.frame(sig_gene = s, emt_gene = m, rho = current_cor$estimate)
    m_df <- rbind(m_df, current_obs)
  }
}


# Specific genes from our sig in M genes
tfrc_m_df <- filter(m_df, sig_gene == "tfrc")
hist(tfrc_m_df$rho)

grin2b_m_df <- filter(m_df, sig_gene == "grin2b")
hist(grin2b_m_df$rho)

samd12_m_df <- filter(m_df, sig_gene == "samd12")
hist(samd12_m_df$rho)

# Testing if the majority of rhos are less than 0 (e.g. negatively correlated with M genes)
result <- SIGN.test(grin2b_m_df$rho, md = 0, alternative = "greater")

# Print the result
print(result)


# Testing if the majority of rhos are less than 0 (e.g. negatively correlated with M genes)
result <- SIGN.test(tfrc_m_df$rho, md = 0, alternative = "less")
print(result)

result <- t.test(tfrc_m_df$rho, mu = 0, alternative = "less")
print(result)
```

# Seeing if my 6 gene signature can separate EMT high vs. EMT low states
```{r emt high vs. low states. 0.6032527 for high VIM state. 0.7312259 for low VIM state. 0.6995424 for CDH2 High state. 0.6728158 for CDH2 Low state. 0.5585096 for high FN1 state. 0.7397415 for low FN1 state. 0.6341216 for high COL1A1. 0.6325213 for low COL1A1. 0.7680494 for high ZEB1 state. 0.7032933 for low ZEB1 state.  0.7963054 for high ZEB2 state. 0.7559641 for low ZEB2 state.  0.6793818 for high snail1 state. 0.7196376 for low snail1 state.  0.6992781 for snail2 high state. 0.6378382 for snail2 low state. 0.7429145 for high ACTA2 state. 0.7172152 for low ACTA2 state. 0.750169 for high FSP1 state. 0.6446073 for FSP1 low state. 0.8257751 for MMPs high state. 0.6536542 for MMPs low state. 0.6990776 high TWIST1 state}
# We do have an unusually high survival rate in this dataset which could mean we have identified a signature that is 
# best at helping patients early in treatment
threshold_VIM <- mean(scl_common$vim) # It is 194.7533
threshold_ZEB1 <- mean(scl_common$zeb1) # It is 0.08082269
threshold_ZEB2 <- mean(scl_common$zeb2) # It is 0.4974231
threshold_CDH2 <- mean(scl_common$cdh2) # It is 38.31516
threshold_FN1 <- mean(scl_common$fn1) # It is 34.58451
threshold_TWIST1 <- mean(scl_common$twist1) # It is 2.503752
threshold_SNAIl1 <- mean(scl_common$snai1) # It is 3.043554
threshold_SNAIl2 <- mean(scl_common$snai2) # It is 4.433867
threshold_ACTA2 <- mean(scl_common$acta2) # It is 1.873155
threshold_FSP1 <- mean(scl_common$s100a4) # It is 5.125578
threshold_COL1A1 <- mean(scl_common$col1a1) # It is 192.5621
threshold_MMP1 <- mean(scl_common$mmp1) # It is 0.1878272



# Create a new column 'EMT_group' based on expression levels
scl_common <- scl_common %>%
  mutate(emt_group = case_when(
    twist1 >= threshold_MMPs ~ "High EMT",
    TRUE ~ "Low EMT"
  ))



low_emt_df <- filter(scl_common, emt_group == "Low EMT")
high_emt_df <- filter(scl_common, emt_group == "High EMT")

cox_preds <- data.frame(preds = c("tfrc", "samd12", "grin2b", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds

# Number of iterations
num_iterations <- 1000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_low_emt_only_twist1_training_data_6_preds.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = low_emt_df,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)
```



```{r now making a plot of all the different correlations}
cor_df <- data.frame(emt_state = rep(c("high", "low"), times = 6), gene = rep(c("vim", "zeb1", "zeb2", "cdh2", "fn1", "twist1", "snail1", "snail2", "acta2", "fsp1", "col1a1", "mmp1"), each = 2), c_index = c(0.6032527, 0.7312259, 0.7680494, 0.7032933, 0.7963054, 0.7559641, 0.6995424, 0.6728158, 0.5585096, 0.7397415, 0.6990776, NA, 0.6793818, 0.7196376, 0.6992781, 0.6378382, 0.7429145, 0.7172152, 0.750169, 0.6446073, 0.6341216, 0.6325213,0.8257751, 0.6536542))



mean_high_c_index <- cor_df %>%
  filter(emt_state == "high") %>%
  summarise(mean_c_index = mean(c_index, na.rm = TRUE))

mean_low_c_index <- cor_df %>%
  filter(emt_state == "low") %>%
  summarise(mean_c_index = mean(c_index, na.rm = TRUE))


```



```{r attempting to use new validation dataset and determine subtypes and then generate survival time from that}
third_df <- read.csv("Data/GSE60052_79tumor.7normal.normalized.log2.data.Rda_finished.csv", sep = ",")
rownames(third_df) <- third_df$X
third_df <- third_df %>%
  select(-X)
colnames(third_df) <- tolower(colnames(third_df))

# Loading in protein-coding genes to get proper names for dataset
hgnc_names <- read.csv("Data/hgnc_results.txt", sep = "\t")
hgnc_names <- hgnc_names %>%
  select(-HGNC.ID) %>%
  select(-Approved.name) %>%
  filter(Status == "Approved")

common_genes <- intersect(tolower(hgnc_names$Approved.symbol), colnames(third_df))

# Subsetting to just HGNC approved genes
third_df <- third_df %>%
  select(all_of(common_genes))
```



# Performing 10-fold CV on subsets of the predictors to see if we can stabalize GRIN2B
```{r 10-fold CV subsets}
# Identified signature is "gng13","tfrc","fam83f","dlk1" with 10-fold cv of 0.770655075918234
genes <- c("gng13","tfrc","fam83f","samd12","grin2b","dlk1")
# Second round of elimination to see if we can get it down to 4 genes to see if we see big differences in performance
genes2 <- c("gng13","tfrc","fam83f","grin2b","dlk1")

cox_preds2 <- as.data.frame(genes2)
rownames(cox_preds2) <- cox_preds2$genes2
colnames(cox_preds2) <- "preds"


# Loop through each gene and evaluate the model
current_preds <- cox_preds2

for (gene_to_drop in genes2) {
  current_preds <- cox_preds2
  current_preds <- current_preds[current_preds$preds != gene_to_drop, ]
  current_preds <- as.data.frame(current_preds)
  rownames(current_preds) <- current_preds$current_preds
  num_remaining_genes <- nrow(current_preds)
  
  message(paste0("The number of remaining genes are: ", num_remaining_genes))
  message(paste0("The current gene that has been dropped is: ", gene_to_drop))
  
  # Fit the model with the remaining genes
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = FALSE,
    progress_free = FALSE,
    cox_predictors = current_preds,
    cox_df = scl_common,
    gene_num = num_remaining_genes,
    my_folds = NULL,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )
  
  message(paste0("The c-index of this gene set is: ", current_cox$CV$cvm[current_cox$CV$index[1]]))
}
```

```{r forestplot of the 4 predictor model}
# Risk score: -0.9526172*tfrc + -0.0854650*fam83f + -0.0006146*dlk1 + -0.2557644*gng13
cox_mod <- coxph(Surv(time, vital.status) ~ tfrc + fam83f + dlk1 + gng13, data = scl_common)
forest_plot <- ggforest(model = cox_mod, data = scl_common)

# Saving as PNG
ggsave(forest_plot, path = "Figures/panels/", filename = "forestplot_4_predictor_model.png", width = 8, height = 8, units = "in", dpi = 600)

# Saving as SVG
ggsave(forest_plot, path = "Figures/panels/", filename = "forestplot_4_predictor_model.svg", device = "svg", width = 8, height = 8, units = "in", dpi = 600)
```


# miRNA + MAD + SDE Overall survival KM plot 4 gene signature
```{r original data risk score and km plot for miRNA + MAD + SDE}
# Original data risk score
# First, let's assume your coefficients for each gene are stored in a vector like this:
coef <- c(-0.9526172, -0.0854650, -0.0006146, -0.2557644)

# And your data frame `data` has columns named after the genes
genes <- c("tfrc", "fam83f", "dlk1", "gng13")

scl_common$risk_score <- rowSums(sapply(seq_along(genes), function(i) scl_common[, genes[i]] * coef[i]))
median_risk <- median(scl_common$risk_score)
scl_common$risk <- ifelse(scl_common$risk_score > median_risk, "high", "low")

scl_common <- scl_common %>%
  select(patient.id, sex, smoker, vital.status, time, n.stage, m.stage, uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy, risk_score, risk, everything())

# Function to compute p-value from Kaplan-Meier fit
compute_p_value <- function(data, progress_free = FALSE) {
  if (progress_free) {
    fit <- survfit(Surv(data$time2, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time2, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  } else {
    fit <- survfit(Surv(data$time, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  }
}

# Compute observed p-value
observed_p_value <- compute_p_value(scl_common)

# Permutation test
set.seed(1)
n_permutations <- 1000
permuted_p_values <- replicate(n_permutations, {
  permuted_data <- scl_common
  permuted_data$risk <- sample(scl_common$risk) # Randomly permute risk labels
  compute_p_value(permuted_data)
})

# Compute p-value of permutation test
perm_p_value <- mean(permuted_p_values <= observed_p_value)


# Plotting the KM curve
fit <- survfit(Surv(scl_common$time, scl_common$vital.status) ~ risk, data = scl_common)
p1 <- ggsurvplot(
  fit = fit,
  data = scl_common,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(3500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Risk",
  title = "Single Dataset | miRMS",
  legend.labs = c("High risk", "Low risk"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)


# Saving as PNG
ggsave(p1$plot, path = "~/Desktop/", filename = "figure_a_panel_d_4_gene_predictor.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "~/Desktop/", filename = "figure_a_panel_d_4_gene_predictor.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```


# Now taking our 1000 datasets and testing the 4 predictors we have identified and seeing how they perform
```{r for 1000 simulations of 10 fold cv on mirna + mad + sde 4 gene signature}
cox_outputs <- list()
counter <- 1
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    # my_seed = 1,
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# Extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# Calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7378887 for 4 active predictors
```



```{r mirna + mad + sde progress free for 4 predictors}
cox_outputs <- list()
counter <- 1
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 4, 
    my_folds = NULL,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7567699 with the 6 active predictors from MAD + SDE + miRNA
```

# Male vs. Female for 4 predictor model
```{r male vs. female 4 predictor model}
# Power analysis to determine how many samples for each group we need to detect a medium effect size with 95% power at 0.05 significance level
sample_size <- pwr.t.test(
  d = 0.5,
  sig.level = 0.05,
  power = 0.8,
  alternative = "two.sided"
)


# Extract the required sample size
required_sample_size <- ceiling(sample_size$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds


# Function to generate random samples
generate_matched_sex_samples <- function(data, sex_column=sex, sex_to_match, num_samples_to_generate, replace = TRUE) {
  # Filter the DataFrame to get samples with the specified subtype
  sex_data <- data %>%
    filter({{ sex_column }} == sex_to_match)
  
  # Use the slice_sample() function from dplyr to randomly select samples
  generated_samples <- sex_data %>%
    slice_sample(n = num_samples_to_generate, replace = replace)
  
  return(generated_samples)
}

for (s in unique(scl_common$sex)){
  current_sex <- filter(scl_common, sex == s)
  current_sex <- generate_matched_sex_samples(scl_common, sex_to_match = paste0(s), num_samples_to_generate = required_sample_size, replace = TRUE)
  message(paste0("On sex: ", s))
  # Number of iterations
  num_iterations <- 10000
  
  cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
  rownames(cox_preds) <- cox_preds$preds
  
  # Create a progress bar
  pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (i in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/random_seeds_initial_training_set_sex_",s,"_with_power_analysis_80_10000_iters_final.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = current_sex,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[i] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  current_df <- data.frame(sex = rep(s, length(c_index_vector)), c_index = c_index_vector)
  write.csv(current_df, file = paste0("Outputs/sex_",tolower(s),"_c_index_peformance_0.80_final.csv"))
  
  
  print(mean(c_index_vector))
  
}
```


```{r calculating stats for male v female performance with 4 predictor model}
male_df <- read.csv("Outputs/sex_male_c_index_peformance_0.80_final.csv", row.names = 1)
female_df <- read.csv("Outputs/sex_female_c_index_peformance_0.80_final.csv", row.names = 1)
sex_specific_df <- bind_rows(male_df, female_df)


# Check the assumptions for the t-test
assumptions_met <- TRUE

# Check for normality assumption
if (!shapiro.test(sex_specific_df$c_index)$p.value > 0.05) {
  assumptions_met <- FALSE
  message("Normality assumption not met. Trying Wilcoxon signed-rank test instead.")
}

# Check for homogeneity of variances assumption (Levene's test)
if (assumptions_met && !car::leveneTest(c_index ~ sex, data = sex_specific_df)$p.value > 0.05) {
  assumptions_met <- FALSE
  message("Homogeneity of variances assumption not met. Trying Wilcoxon signed-rank test instead.")
}

# Perform the appropriate test based on assumptions
if (assumptions_met) {
  # Perform t-test
  t_test_result <- t.test(c_index ~ sex, data = sex_specific_df)
  p_value <- t_test_result$p.value
  test_used <- "t-test"
} else {
  # Perform Wilcoxon signed-rank test
  wilcox_result <- wilcox.test(c_index ~ sex, data = sex_specific_df)
  p_value <- wilcox_result$p.value
  test_used <- "Wilcoxon signed-rank test"
}

# Print the results
cat("Test Used:", test_used, "\n")
cat("P-Value:", p_value, "\n")
p_value_formatted <- format_p(p = p_value, stars = TRUE, stars_only = TRUE)
```


```{r male v female 4 predictor plot}
sex_specific_df$sex <- factor(sex_specific_df$sex, levels = c("Male", "Female"))
p3 <- ggplot(data = sex_specific_df, aes(x = sex, y = c_index))+
  geom_violin()+
  geom_sina()+
  xlab("Sex")+
  ylab("C-index of\n 10000 10-fold CVs")+
  ggtitle("Sex-Specific")+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, hjust = 0.5, face = "bold"),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14),
        legend.position = "none",
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 14))+
  scale_x_discrete(breaks = c("Male", "Female"),
                   labels = c("Male \n(n = 64)",
                              "Female \n(n = 64)"))+
  geom_signif(annotations = "***", xmin = 1, xmax = 2, y_position = 1.02, tip_length = 0, vjust = 0.5)

p3


ggsave(p3, filename= "sex_specific_panel_4_preds_10000_iters.png", units = "in", dpi = 600, path = "Figures/panels/", width = 8, height = 8)
ggsave(p3, filename= "sex_specific_panel_4_preds_10000_iters.svg", units = "in", dpi = 600, path = "Figures/panels/", width = 8, height = 8)
```

# Cancer Subtyping for 4 predictor model
```{r cancer subtyping survival 4 gene predictor}
scl_common <- scl_common %>%
  mutate(
    # Calculate the maximum expression value across the specified genes for each patient
    max_expression = pmax(ascl1, yap1, neurod1, pou2f3)
  ) %>%
  rowwise() %>%
  mutate(
    # Create a new column to indicate the category (A, Y, N, P) for each patient
    subtype = case_when(
      max_expression == ascl1 ~ "A",
      max_expression == yap1 ~ "Y",
      max_expression == neurod1 ~ "N",
      max_expression == pou2f3 ~ "P",
      TRUE ~ NA_character_
    )
  ) %>%
  ungroup()

scl_common <- scl_common %>%
  filter(subtype == "A" | subtype == "N" | subtype == "P")


generate_matched_samples <- function(data, subtype_column=subtype, subtype_to_match, num_samples_to_generate, replace = TRUE) {
  # Filter the DataFrame to get samples with the specified subtype
  subtype_data <- data %>%
    filter({{ subtype_column }} == subtype_to_match)
  
  # Use the slice_sample() function from dplyr to randomly select samples
  generated_samples <- subtype_data %>%
    slice_sample(n = num_samples_to_generate, replace = replace)
  
  return(generated_samples)
}


# Power analysis for each subtype
# Adjust the function and arguments based on your test and data
# f = 0.2 equal small effect size, 0.5 = medium effect size, 0.8 = large effect size
power_analysis <- pwr.anova.test(f = 0.2, k = 3, power = 0.95, sig.level = 0.05
)

# Extract the required sample size
required_sample_size <- ceiling(power_analysis$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")


for (s in unique(scl_common$subtype)){
  current_sub <- filter(scl_common, subtype == s)
  current_sub <- generate_matched_samples(scl_common, subtype_to_match = paste0(s), num_samples_to_generate = required_sample_size, replace = TRUE)
  message(paste0("On subtype: ", s))
  # Number of iterations
  num_iterations <- 10000
  
  cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
  rownames(cox_preds) <- cox_preds$preds
  
  # Create a progress bar
  pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (i in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/random_seeds_initial_training_set_subtype_",s,"_with_power_analysis_95_10000_iters_4_preds.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = current_sub,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[i] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  current_df <- data.frame(subtype = rep(s, length(c_index_vector)), c_index = c_index_vector)
  View(current_df)
  write.csv(current_df, file = paste0("Outputs/subtype_",s,"_c_index_peformance_10000_iters_4_preds.csv"))
  
  
  print(mean(c_index_vector))
  
}

```

```{r subtype plotting for the 4 predictor model}
subtype_df_a <- read.csv("Outputs/subtype_A_c_index_peformance_10000_iters_4_preds.csv", row.names = 1)
subtype_df_n <- read.csv("Outputs/subtype_N_c_index_peformance_10000_iters_4_preds.csv", row.names = 1)
subtype_df_p <- read.csv("Outputs/subtype_P_c_index_peformance_10000_iters_4_preds.csv", row.names = 1)

subtype_df <- bind_rows(subtype_df_a, subtype_df_n, subtype_df_p)


p4 <- ggplot(data = subtype_df, aes(x = subtype, y = c_index))+
  geom_violin()+
  geom_sina()+
  xlab("Subtype")+
  ylab("Mean C-index\nof 10000 10-fold CVs")+
  ggtitle("Subtype-Specific", subtitle = "All pairwise p-values < 0.001")+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = 14, hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text.x = element_text(size = 14, angle = 45),
        legend.position = "none")+
  coord_cartesian(ylim = c(0.5, 1.0))+
  scale_x_discrete(breaks = c("A", "N", "P"),
                   labels = c("A\n(n = 130)",
                              "N\n(n = 130)",
                              "P\n(n = 130)"))
  

p4


ggsave(p4, filename = "4a.svg", path = "Figures/panels/", dpi = 600, device = "svg", units = "in", width = 8, height = 8, bg = "white")


ggsave(p4, filename = "4a.png", path = "Figures/panels/", dpi = 600, device = "png", units = "in", width = 8, height = 8, bg = "white")

anova_test <- aov(c_index~subtype, data = subtype_df)
summary(anova_test)


dunn_test <- dunn.test(subtype_df$c_index, subtype_df$subtype, method = "bh")
summary(dunn_test)
```
# Tumor Staging for 4 predictor model
```{r tumor stages for 4 predictor model}
# I
scl_common <- scl_common %>%
  mutate(
    uicc.tumor.stage = case_when(
      uicc.tumor.stage %in% c("I", "Ia", "Ib", "IB") ~ "I",
      TRUE ~ uicc.tumor.stage
    )
  )


# II
scl_common <- scl_common %>%
  mutate(
    uicc.tumor.stage = case_when(
      uicc.tumor.stage %in% c("II", "IIa", "IIb") ~ "II",
      TRUE ~ uicc.tumor.stage
    )
  )

# III
scl_common <- scl_common %>%
  mutate(
    uicc.tumor.stage = case_when(
      uicc.tumor.stage %in% c("III", "IIIa", "IIIb") ~ "III",
      TRUE ~ uicc.tumor.stage
    )
  )


# Power analysis to determine how many samples for each group we need to detect a medium effect size with 95% power at 0.05 significance level
sample_size <- pwr.t.test(
  d = 0.5,
  sig.level = 0.05,
  power = 0.8,
  alternative = "two.sided"
)


# Extract the required sample size
required_sample_size <- ceiling(sample_size$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")


generate_matched_tumor_samples <- function(data, num_samples_to_generate, replace = TRUE) {
  # Use the slice_sample() function from dplyr to randomly select samples
  generated_samples <- data %>%
    slice_sample(n = num_samples_to_generate, replace = replace)
  
  return(generated_samples)
}



# I + II C-index: 0.8287269
early_stage_df <- filter(scl_common, uicc.tumor.stage == "I" | uicc.tumor.stage == "II")

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds
early_stage_df <- generate_matched_tumor_samples(data = early_stage_df, num_samples_to_generate = 64)

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_first_and_second_tumor_stage_only_training_data_4_preds_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = early_stage_df,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)

# III + IV C-index: 0.6627404
late_stage_df <- filter(scl_common, uicc.tumor.stage == "III" | uicc.tumor.stage == "IV")

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_third_and_fourth_tumor_stage_only_training_data_4_preds_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = late_stage_df,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)
```

```{r plot for tumor staging for 4 predictor model}
tumor_df_early <- read.csv("Outputs/early_tumor_staging_c_index_10000_iters_4_preds.csv", row.names = 1)
tumor_df_early$tumor_stage <- rep("Early", nrow(tumor_df_early))
colnames(tumor_df_early)[1] <- "c_index"

tumor_df_late <- read.csv("Outputs/late_tumor_staging_c_index_vector_10000_iters_4_preds.csv", row.names = 1)
tumor_df_late$tumor_stage <- rep("Late", nrow(tumor_df_late))
colnames(tumor_df_late)[1] <- "c_index"

tumor_df <- bind_rows(tumor_df_early, tumor_df_late)

p5 <- ggplot(data = tumor_df, aes(x = tumor_stage, y = c_index))+
  geom_violin()+
  geom_sina()+
  xlab("Tumor Staging")+
  ylab("C-index of\n 10000 10-fold CVs")+
  ggtitle("Tumor Severity")+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, hjust = 0.5, face = "bold"),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 14))+
  scale_x_discrete(breaks = c("Early", "Late"),
                   labels = c("Early \n(n = 64)",
                              "Late \n(n = 64)"))+
  geom_signif(annotations = "***", xmin = 1, xmax = 2, y_position = 0.95, tip_length = 0, vjust = 0.5)
  

p5

ggsave(p5, filename= "tumor_staging_panel_4_preds.png", units = "in", dpi = 600, path = "Figures/panels/", width = 8, height = 8)
```

```{r calculating stats for 4 predictors tumor staging}
# Perform Wilcoxon signed-rank test
wilcox_result <- wilcox.test(c_index ~ tumor_stage, data = tumor_df)
p_value <- wilcox_result$p.value
test_used <- "Wilcoxon signed-rank test"

# Print the results
cat("Test Used:", test_used, "\n")
cat("P-Value:", p_value, "\n")
p_value_formatted <- format_p(p = p_value, stars = TRUE, stars_only = TRUE)
```

# M Staging for 4 predictor model
```{r m stages for 4 predictor model}
# 1
scl_common <- scl_common %>%
  mutate(
    m.stage = case_when(
      m.stage %in% c("1", "1a", "1b") ~ "1",
      TRUE ~ m.stage
    )
  ) %>%
  filter(m.stage != "")





# Power analysis to determine how many samples for each group we need to detect a medium effect size with 95% power at 0.05 significance level
sample_size <- pwr.t.test(
  d = 0.5,
  sig.level = 0.05,
  power = 0.8,
  alternative = "two.sided"
)


# Extract the required sample size
required_sample_size <- ceiling(sample_size$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")


generate_matched_tumor_samples <- function(data, num_samples_to_generate, replace = TRUE) {
  # Use the slice_sample() function from dplyr to randomly select samples
  generated_samples <- data %>%
    slice_sample(n = num_samples_to_generate, replace = replace)
  
  return(generated_samples)
}



# M-stage 0 c-index: 0.6957492
early_m_df <- filter(scl_common, m.stage == 0)

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds
early_m_df <- generate_matched_tumor_samples(data = early_m_df, num_samples_to_generate = 64)

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_early_m_df_staging_only_training_data_4_preds_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = early_m_df,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)

# M-stage 1 c-index: 0.8321407
late_m_df <- filter(scl_common, m.stage == 1)

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds

# Number of iterations
num_iterations <- 10000

late_m_df <- generate_matched_tumor_samples(data = late_m_df, num_samples_to_generate = 64)

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_late_m_df_staging_only_training_data_4_preds_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = late_m_df,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)

# X stage (undetermined metastits) c-index: 1
x_m_df <- filter(scl_common, m.stage == "x")

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds

# Number of iterations
num_iterations <- 10000

x_m_df <- generate_matched_tumor_samples(data = x_m_df, num_samples_to_generate = 64)

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_x_m_df_staging_only_training_data_4_preds_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = x_m_df,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)
```

# N staging 4 predictor model
```{r n stage for 4 predictor model}
# Removing X annotated sample
scl_common <- scl_common %>%
  filter(n.stage != "X")

# Power analysis to determine how many samples for each group we need to detect a medium effect size with 95% power at 0.05 significance level
power_analysis <- pwr.anova.test(f = 0.2, k = 4, power = 0.80, sig.level = 0.05)


# Extract the required sample size
required_sample_size <- ceiling(power_analysis$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")


generate_matched_tumor_samples <- function(data, num_samples_to_generate, replace = TRUE) {
  # Use the slice_sample() function from dplyr to randomly select samples
  generated_samples <- data %>%
    slice_sample(n = num_samples_to_generate, replace = replace)
  
  return(generated_samples)
}



# N-stage 0 c-index: 0.7098857
n_stage_0_df <- filter(scl_common, n.stage == 0)

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds
n_stage_0_df <- generate_matched_tumor_samples(data = n_stage_0_df, num_samples_to_generate = required_sample_size)

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_n_0_df_staging_only_training_data_4_preds_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = n_stage_0_df,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)

# N-stage 1 c-index: 0.7099768
n_stage_1_df <- filter(scl_common, n.stage == 1)

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds
n_stage_1_df <- generate_matched_tumor_samples(data = n_stage_1_df, num_samples_to_generate = required_sample_size)

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_n_1_df_staging_only_training_data_4_preds_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = n_stage_1_df,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)


# N-stage 1 c-index: 0.7099768
n_stage_2_df <- filter(scl_common, n.stage == 2)

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds
n_stage_2_df <- generate_matched_tumor_samples(data = n_stage_2_df, num_samples_to_generate = required_sample_size)

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_n_2_df_staging_only_training_data_4_preds_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = n_stage_2_df,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)


# Automated for all n stages

# Predictors
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds

# Specify the unique n.stage values in your data
scl_common_n_analysis_df <- scl_common %>%
  filter(n.stage != "")
n_stage_values <- unique(scl_common_n_analysis_df$n.stage)
n_stage_values <- c("0", "1", "2","3")

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = length(n_stage_values) * num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a list to store c-index vectors
c_index_vectors <- list()

# Loop through n.stage values
for (n_stage_value in n_stage_values) {
  # Filter data for the current n.stage
  n_stage_df <- filter(scl_common_n_analysis_df, n.stage == n_stage_value)
  
  # Generate matched tumor samples
  n_stage_df <- generate_matched_tumor_samples(data = n_stage_df, num_samples_to_generate = required_sample_size)
  
  # Create a directory for the current n.stage value
  dir.create(paste0("Outputs/n_stage_", n_stage_value), showWarnings = FALSE)
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (iteration in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/n_stage_", n_stage_value, "/random_seeds.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = n_stage_df,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[iteration] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  # Store the c-index vector in the list
  c_index_vectors[[as.character(n_stage_value)]] <- c_index_vector
  
  # Save c-index vector to a CSV file
  write.csv(c_index_vector, file = paste0("Outputs/n_stage_", n_stage_value, "/c_index_results.csv"))
  
  # Save the cox_df as an RDS file for future use
  saveRDS(n_stage_df, file = paste0("Outputs/n_stage_", n_stage_value, "/cox_df.rds"))
  
  # Save the current n.stage value for the random seed file
  write.table(data.frame(n_stage = n_stage_value), file = "Outputs/random_seeds.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  # Calculate and print the mean c-index for the current n.stage value
  mean_c_index <- mean(c_index_vector)
  cat(paste("Mean C-Index for n.stage", n_stage_value, ":", mean_c_index, "\n"))
}
```
```{r n stage plot}
n_stage_0_df <- read.csv("Outputs/n_stage_0/c_index_results.csv")
n_stage_1_df <- read.csv("Outputs/n_stage_1/c_index_results.csv")
n_stage_2_df <- read.csv("Outputs/n_stage_2/c_index_results.csv")
n_stage_3_df <- read.csv("Outputs/n_stage_3/c_index_results.csv")

n_stages <- list(n_stage_0_df, n_stage_1_df, n_stage_2_df, n_stage_3_df)

for(x in 1:4){
  current_df <- n_stages[[x]]
  colnames(current_df) <- c("iteration", "c_index")
  current_df$n_stage <- rep(x = x - 1, times = nrow(current_df))
  n_stages[[x]] <- current_df
}

n_stages_df <-  bind_rows(n_stages) 
n_stages_df$n_stage <- factor(n_stages_df$n_stage, levels = c(0,1,2,3))

aov_res <- aov(c_index~n_stage, data = n_stages_df)
summary(aov_res)

dunn_res <- dunn.test::dunn.test(n_stages_df$c_index, n_stages_df$n_stage, method = "holm")


n_stage_plot <- ggplot(data = n_stages_df, mapping = aes(x = n_stage, y = c_index))+
  geom_violin()+
  geom_sina()+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 16, hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14))+
  xlab("N Stage")+
  ylab("Mean C-index of\n10000 10 Fold CVs")+
  ggtitle("N Stage Specific", subtitle = "All pairwise p-values < 0.001")+
  scale_x_discrete(breaks = c(0, 1, 2, 3),
                   labels = c("0\n(n = 70)",
                              "1\n(n = 70)",
                              "2\n(n = 70)",
                              "3\n(n = 70)"))


n_stage_plot

ggsave(n_stage_plot, filename = "n_stage_specific_plot.png", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")

ggsave(n_stage_plot, filename = "n_stage_specific_plot.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")
```

# M Staging for 4 predictor model
```{r m stage 4 predictor}
# Automated for all m stages

# Power analysis to determine how many samples for each group we need to detect a small effect size with 80% power at 0.05 significance level
power_analysis <- pwr.anova.test(f = 0.2, k = 2, power = 0.80, sig.level = 0.05)


# Extract the required sample size
required_sample_size <- ceiling(power_analysis$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")

# Predictors
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds


# Consolidate subtypes of m stage
scl_common_m_analysis_df <- scl_common %>%
  mutate(m.stage = case_when(
    m.stage %in% c("1a", "1b") ~ "1",  # Consolidate "1a" and "1b" into "1"
    TRUE ~ m.stage                     # Keep all other subtypes as is
  )) %>%
  filter(m.stage != "") %>%
  filter(m.stage != "x")


# Specify the unique m.stage values in the data
scl_common_m_analysis_df <- scl_common_m_analysis_df %>%
  filter(m.stage != "")
chemo_values <- unique(scl_common_m_analysis_df$m.stage)
chemo_values <- c("0", "1")

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = length(chemo_values) * num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a list to store c-index vectors
c_index_vectors <- list()

# Loop through m.stage values
for (chemo_value in chemo_values) {
  # Filter data for the current m.stage
  m_stage_df <- filter(scl_common_m_analysis_df, m.stage == chemo_value)
  
  # Generate matched tumor samples
  m_stage_df <- generate_matched_tumor_samples(data = m_stage_df, num_samples_to_generate = required_sample_size)
  
  # Create a directory for the current m.stage value
  dir.create(paste0("Outputs/m_stage_", chemo_value), showWarnings = FALSE)
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (iteration in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/m_stage_", chemo_value, "/random_seeds.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = m_stage_df,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[iteration] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  # Store the c-index vector in the list
  c_index_vectors[[as.character(chemo_value)]] <- c_index_vector
  
  # Save c-index vector to a CSV file
  write.csv(c_index_vector, file = paste0("Outputs/m_stage_", chemo_value, "/c_index_results.csv"))
  
  # Save the cox_df as an RDS file for future use
  saveRDS(m_stage_df, file = paste0("Outputs/m_stage_", chemo_value, "/cox_df.rds"))
  
  # Save the current m.stage value for the random seed file
  write.table(data.frame(m_stage = chemo_value), file = "Outputs/random_seeds.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  # Calculate and print the mean c-index for the current m.stage value
  mean_c_index <- mean(c_index_vector)
  cat(paste("Mean C-Index for m.stage", chemo_value, ":", mean_c_index, "\n"))
}
```
# M staging plot
```{r m stage plot}
m_stage_0_df <- read.csv("Outputs/m_stage_0/c_index_results.csv")
m_stage_1_df <- read.csv("Outputs/m_stage_1/c_index_results.csv")

m_stages <- list(m_stage_0_df, m_stage_1_df)

for(x in 1:2){
  current_df <- m_stages[[x]]
  colnames(current_df) <- c("iteration", "c_index")
  current_df$m_stage <- rep(x = x - 1, times = nrow(current_df))
  m_stages[[x]] <- current_df
}

m_stages_df <-  bind_rows(m_stages) 
m_stages_df$m_stage <- factor(m_stages_df$m_stage, levels = c(0,1))

wilcox_result <- wilcox.test(c_index ~ m_stage, data = m_stages_df)
p_value <- wilcox_result$p.value
p_value_formatted <- format_p(p = p_value, stars = TRUE, stars_only = TRUE)

m_stage_plot <- ggplot(data = m_stages_df, mapping = aes(x = m_stage, y = c_index))+
  geom_violin()+
  geom_sina()+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14))+
  xlab("M Stage")+
  ylab("Mean C-index of\n10000 10 Fold CVs")+
  ggtitle("M Stage Specific")+
  scale_x_discrete(breaks = c(0, 1),
                   labels = c("0\n(n = 100)",
                              "1\n(n = 100)"))+
  geom_signif(annotations = "***", xmin = 1, xmax = 2, y_position = 0.92, tip_length = 0, vjust = 0.5)


m_stage_plot

ggsave(m_stage_plot, filename = "m_stage_specific_plot.png", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")

ggsave(m_stage_plot, filename = "m_stage_specific_plot.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")
```

# Chemotherapy Analysis 4 gene predictor
```{r no chemotherapy 4 predictor}
# Automated for all chemotherapy treatments

# Power analysis to determine how many samples for each group we need to detect a small effect size with 80% power at 0.05 significance level
power_analysis <- pwr.t.test(
  d = 0.2,
  sig.level = 0.05,
  power = 0.8,
  alternative = "two.sided"
)


# Extract the required sample size
required_sample_size <- ceiling(power_analysis$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")

# Predictors
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds


# Consolidate subtypes of m stage
scl_common_chemo_analysis_df <- scl_common %>%
  filter(chemotherapy != "")


# Specify the unique m.stage values in the data
chemo_values <- unique(scl_common_chemo_analysis_df$chemotherapy)
chemo_values <- c("No", "Yes")

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = length(chemo_values) * num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a list to store c-index vectors
c_index_vectors <- list()

# Loop through m.stage values
for (chemo_value in chemo_values) {
  # Filter data for the current m.stage
  chemo_stage_df <- filter(scl_common_chemo_analysis_df, chemotherapy == chemo_value)
  
  # Generate matched tumor samples
  chemo_stage_df <- generate_matched_tumor_samples(data = chemo_stage_df, num_samples_to_generate = required_sample_size)
  
  # Create a directory for the current m.stage value
  dir.create(paste0("Outputs/chemo_stage_", chemo_value), showWarnings = FALSE)
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (iteration in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/chemo_stage_", chemo_value, "/random_seeds.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = chemo_stage_df,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[iteration] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  # Store the c-index vector in the list
  c_index_vectors[[as.character(chemo_value)]] <- c_index_vector
  
  # Save c-index vector to a CSV file
  write.csv(c_index_vector, file = paste0("Outputs/chemo_stage_", chemo_value, "/c_index_results.csv"))
  
  # Save the cox_df as an RDS file for future use
  saveRDS(m_stage_df, file = paste0("Outputs/chemo_stage_", chemo_value, "/cox_df.rds"))
  
  # Calculate and print the mean c-index for the current m.stage value
  mean_c_index <- mean(c_index_vector)
  cat(paste("Mean C-Index for chemotherapy status", chemo_value, ":", mean_c_index, "\n"))
}
```

# Chemotherapy Analysis Plot
```{r chemotherapy plot plot}
chemo_no_df <- read.csv("Outputs/chemo_stage_No/c_index_results.csv")
chemo_no_df$chemo <- rep("no", nrow(chemo_no_df))
colnames(chemo_no_df) <- c("iteration", "c_index", "chemo")
chemo_yes_df <- read.csv("Outputs/chemo_stage_Yes/c_index_results.csv")
chemo_yes_df$chemo <- rep("yes", nrow(chemo_yes_df))
colnames(chemo_yes_df) <- c("iteration", "c_index", "chemo")

chemo_stages_df <-  bind_rows(chemo_no_df, chemo_yes_df) 
chemo_stages_df$chemo <- factor(chemo_stages_df$chemo, levels = c("yes","no"))

wilcox_result <- wilcox.test(c_index ~ chemo, data = chemo_stages_df)
p_value <- wilcox_result$p.value
p_value_formatted <- format_p(p = p_value, stars = TRUE, stars_only = TRUE)

chemo_stage_plot <- ggplot(data = chemo_stages_df, mapping = aes(x = chemo, y = c_index))+
  geom_violin()+
  geom_sina()+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14))+
  xlab("Chemotherapy")+
  ylab("Mean C-index of\n10000 10 Fold CVs")+
  ggtitle("Chemotherapy Status")+
  scale_x_discrete(breaks = c("yes", "no"),
                   labels = c("Yes\n(n = 394)",
                              "No\n(n = 394)"))+
  geom_signif(annotations = "***", xmin = 1, xmax = 2, y_position = 0.95, tip_length = 0, vjust = 0.5)


chemo_stage_plot

ggsave(chemo_stage_plot, filename = "chemo_stage_specific_plot.png", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")

ggsave(chemo_stage_plot, filename = "chemo_stage_specific_plot.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")
```

# Neoadjuvent chemotherapy analysis
```{r neoadjuvant chemotherapy 4 predictor}
# Automated for all neoadjuvant chemotherapy treatments

# Power analysis to determine how many samples for each group we need to detect a small effect size with 80% power at 0.05 significance level
power_analysis <- pwr.t.test(
  d = 0.2,
  sig.level = 0.05,
  power = 0.8,
  alternative = "two.sided"
)


# Extract the required sample size
required_sample_size <- ceiling(power_analysis$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")

# Predictors
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds


# Consolidate subtypes of m stage
scl_common_chemo_analysis_df <- scl_common %>%
  filter(neoadjuvant.chemotherapy != "")


# Specify the unique m.stage values in the data
chemo_values <- unique(scl_common_chemo_analysis_df$chemotherapy)
chemo_values <- c("No", "Yes")

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = length(chemo_values) * num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a list to store c-index vectors
c_index_vectors <- list()

# Loop through m.stage values
for (chemo_value in chemo_values) {
  # Filter data for the current m.stage
  chemo_stage_df <- filter(scl_common_chemo_analysis_df, neoadjuvant.chemotherapy == chemo_value)
  
  # Generate matched tumor samples
  chemo_stage_df <- generate_matched_tumor_samples(data = chemo_stage_df, num_samples_to_generate = required_sample_size)
  
  # Create a directory for the current neoadjuvant value
  dir.create(paste0("Outputs/neo_chemo_stage_", chemo_value), showWarnings = FALSE)
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (iteration in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/neo_chemo_stage_", chemo_value, "/random_seeds.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = chemo_stage_df,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[iteration] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  # Store the c-index vector in the list
  c_index_vectors[[as.character(chemo_value)]] <- c_index_vector
  
  # Save c-index vector to a CSV file
  write.csv(c_index_vector, file = paste0("Outputs/neo_chemo_stage_", chemo_value, "/c_index_results.csv"))
  
  # Save the cox_df as an RDS file for future use
  saveRDS(chemo_stage_df, file = paste0("Outputs/neo_chemo_stage_", chemo_value, "/cox_df.rds"))
  
  # Calculate and print the mean c-index for the current m.stage value
  mean_c_index <- mean(c_index_vector)
  cat(paste("Mean C-Index for neoadjuvant chemotherapy status", chemo_value, ":", mean_c_index, "\n"))
}
```

# Age analysis
```{r age 4 predictor}
# Automated for age split

# Power analysis to determine how many samples for each group we need to detect a small effect size with 80% power at 0.05 significance level
power_analysis <- pwr.t.test(
  d = 0.2,
  sig.level = 0.05,
  power = 0.8,
  alternative = "two.sided"
)

# Function to find the mode just out of curiosity
Modes <- function(x) {
  ux <- unique(x)
  tab <- tabulate(match(x, ux))
  ux[tab == max(tab)]
}

Modes(scl_common$age)

# Extract the required sample size
required_sample_size <- ceiling(power_analysis$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")

# Predictors
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds


# Consolidate age range into two values (old and young based on if they are above ("old") or below ("young") the median age of the dataset)
scl_common_age_analysis_df <- scl_common %>%
  mutate(age_cat = ifelse(age > median(age), "old", "young"))

# Specify the unique m.stage values in the data
age_values <- unique(scl_common_age_analysis_df$age_cat)
age_values <- c("young", "old")

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = length(age_values) * num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a list to store c-index vectors
c_index_vectors <- list()

# Loop through m.stage values
for (age_value in age_values) {
  age_stage_df <- filter(scl_common_age_analysis_df, age_cat == age_value)
  
  # Generate matched tumor samples
  age_stage_df <- generate_matched_tumor_samples(data = age_stage_df, num_samples_to_generate = required_sample_size)
  
  # Create a directory for the current age value
  dir.create(paste0("Outputs/age_stage_", age_value), showWarnings = FALSE)
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (iteration in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/age_stage_", age_value, "/random_seeds.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = age_stage_df,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[iteration] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  # Store the c-index vector in the list
  c_index_vectors[[as.character(age_value)]] <- c_index_vector
  
  # Save c-index vector to a CSV file
  write.csv(c_index_vector, file = paste0("Outputs/age_stage_", age_value, "/c_index_results.csv"))
  
  # Save the cox_df as an RDS file for future use
  saveRDS(age_stage_df, file = paste0("Outputs/age_stage_", age_value, "/cox_df.rds"))
  
  # Calculate and print the mean c-index for the current m.stage value
  mean_c_index <- mean(c_index_vector)
  cat(paste("Mean C-Index for age status", age_value, ":", mean_c_index, "\n"))
}
```
# Age Plot
```{r age plot}
chemo_no_df <- read.csv("Outputs/age_stage_old/c_index_results.csv")
chemo_no_df$age <- rep("old", nrow(chemo_no_df))
colnames(chemo_no_df) <- c("iteration", "c_index", "age")
chemo_yes_df <- read.csv("Outputs/age_stage_young/c_index_results.csv")
chemo_yes_df$age <- rep("young", nrow(chemo_yes_df))
colnames(chemo_yes_df) <- c("iteration", "c_index", "age")

chemo_stages_df <-  bind_rows(chemo_no_df, chemo_yes_df) 
chemo_stages_df$age <- factor(chemo_stages_df$age, levels = c("young","old"))

wilcox_result <- wilcox.test(c_index ~ age, data = chemo_stages_df)
p_value <- wilcox_result$p.value
p_value_formatted <- format_p(p = p_value, stars = TRUE, stars_only = TRUE)

chemo_stage_plot <- ggplot(data = chemo_stages_df, mapping = aes(x = age, y = c_index))+
  geom_violin()+
  geom_sina()+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14))+
  xlab("Age")+
  ylab("Mean C-index of\n10000 10 Fold CVs")+
  ggtitle("Age")+
  scale_x_discrete(breaks = c("young", "old"),
                   labels = c("Young\n(n = 394)",
                              "Old\n(n = 394)"))+
  geom_signif(annotations = "***", xmin = 1, xmax = 2, y_position = 0.76, tip_length = 0, vjust = 0.5)


chemo_stage_plot

ggsave(chemo_stage_plot, filename = "age_specific_plot.png", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")

ggsave(chemo_stage_plot, filename = "age_specific_plot.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")
```

# Correlation between risk score and UICC tumor storage
```{r uicc tumor correlation strategy}
# Risk score: -0.9526172*tfrc + -0.0854650*fam83f + -0.0006146*dlk1 + -0.2557644*gng13
# 0 = Low risk, 1 = High risk
scl_common_rs <- scl_common %>%
  select(tfrc, fam83f, dlk1, gng13) %>%  # Subset columns based on gene names
  mutate(
    risk_score = (-0.9526172 * tfrc) +  (-0.0854650 * fam83f) +  (-0.0006146 * dlk1) + (-0.2557644 * gng13),
    risk_category = ifelse(risk_score < mean(risk_score, na.rm = TRUE), 0, 1)
  )

# Consolidate tumor stages to all numeric values
scl_common_ts_num <- scl_common %>%
  mutate(
    consolidated_stage = case_when(
      uicc.tumor.stage %in% c("I", "Ia", "Ib", "IB") ~ 1,
      uicc.tumor.stage %in% c("II", "IIa", "IIb") ~ 2,
      uicc.tumor.stage %in% c("IIIa", "IIIb") ~ 3,
      uicc.tumor.stage == "IV" ~ 4,
      TRUE ~ NA_integer_  # Handle other cases or missing values
    ),
    consolidated_score = ifelse(consolidated_stage <= 2, 0, 1)
  ) %>%
  select(-uicc.tumor.stage)  # Optionally, you can drop the original "stage" column if needed


cor.test(x = scl_common_rs$risk_score, y = scl_common_ts_num$consolidated_stage, method = "spearman")

```



# Pathway enrichment 4 predictor model
```{r pathway enrichment for 4 genes}
enrichment_df <- read.csv("Data/mirms_enrichment_4_preds.csv") 
enrichment_df <- enrichment_df %>%
  filter(Entities.FDR < 0.05) %>%
  arrange(Entities.FDR)

# Select the top 10 entries
enrichment_df <- head(enrichment_df, 10)


enrichment_plot <- ggplot(data = enrichment_df, aes(x = reorder(Pathway.name, Entities.FDR, decreasing = TRUE), y = Entities.FDR, fill = Entities.FDR))+
  geom_col(width = 0.5, fill = "skyblue")+
  coord_flip()+
  scale_y_continuous(expand = c(0,0))+
  scale_fill_continuous("FDR p-value")+
  xlab("Pathway")+
  ylab("FDR p-value")+
  theme(panel.background = element_blank(),
        axis.title = element_text(size = 22, face = "bold"),
        axis.text = element_text(size = 12),
        legend.title = element_text(size = 18, face = "bold", vjust = 1),
        legend.text = element_text(size = 16, hjust = 0),
        legend.position = "none")+
  guides(fill = guide_colorbar(barwidth = 15))

ggsave(enrichment_plot, filename = "enrichment_plot_top_10_fdr_0.05_pathways.png", path = "Figures/panels/", dpi = 600, height = 12, width = 12, bg = "white", units = "in")

ggsave(enrichment_plot, filename = "enrichment_plot_top_10_fdr_0.05_pathways.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 12, width = 12, bg = "white", units = "in")
```



