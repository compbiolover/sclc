---
title: "SCLC Analysis"
author: "Andrew Willems & Tian Hong"
date: "2023-04-05"
output: html_document
---

```{r setup, include=FALSE}
# This sets the global chunk options for knitr to display the R code.
knitr::opts_chunk$set(
  echo = TRUE
)

# This sets the root directory for knitr to the project directory.
knitr::opts_knit$set(root.dir = "~/Documents/Work/Phd_program/hong_lab/Projects/sclc/")
```

## SCLC Analysis

# Loading needed packages
```{r load needed packages}
# cowplot: for making publication-ready plots in R
# data.table: for efficient data manipulation and manipulation of large datasets
# devtools: for developing R packages and managing dependencies
# ggplot2: for data visualization and making high-quality, customizable plots
# glmnet: for fitting generalized linear models via penalized maximum likelihood
# hoardeR: for caching data to disk and improving the speed of data access
# igraph: for network analysis and visualization
# Matrix: for efficient manipulation and calculation with dense and sparse matrices
# monocle3: for single-cell RNA-seq analysis and visualization
# parallel: for running parallel computations in R
# phateR: for visualizing high-dimensional data in a 2D plot
# reticulate: for running Python code in R and vice versa
# retry: for allowing us to repeatedly restart code due to timeouts or errors
# Rmagic: for running R code in Jupyter notebooks
# styler: for consistent code formatting and styling
# survival: for survival analysis and modeling
# survminer: for visualization of survival analysis results and data
# svglite: for creating vector graphics in R
# switchde: for differential expression analysis of RNA-seq data using a Bayesian framework
# tidyverse: for data manipulation, visualization, and analysis using a consistent set of tools and syntax
# viridis: for creating color palettes for data visualization that are perceptually uniform and easy to interpret

pacman::p_load(
  cowplot, coxed, data.table, devtools, doParallel, ggplot2, glmnet, hoardeR, igraph, Matrix, monocle3, parallel, phateR,
  reticulate, retry, Rmagic, styler, survival, survminer, survsim, svglite, switchde, tidyverse, viridis
)
```

# Setting up Conda environment that is needed for MAGIC
```{r miniconda setup for MAGIC}
# Loading conda environment 'r-reticulate' for MAGIC package
use_condaenv("/Users/andrewwillems/Library/r-miniconda-arm64/envs/r-reticulate")
```

# Sourcing external R files that contain needed functions
```{r sourcing needed functions}
# This code sources several R scripts that contain functions used for analyzing miRNA expression data in small cell lung cancer (SCLC).
# The 'cox_model.R' script contains a function for performing a Cox proportional hazards model on the data.
# The 'km_plotter.R' script contains a function for creating a Kaplan-Meier plot to visualize survival data.
# The 'lung_mirna_calculator.R' script contains functions for preprocessing and normalizing the miRNA expression data.
# The 'risk_score_calculator.R' script contains a function for calculating a risk score for each patient based on the results of the Cox model.
# The 'main.Rmd' markdown notebook contains all the code for the SCLC analysis for the paper.
# This code also sources 'cell_dataset_builder.R', which contains functions for building a dataset from processed scRNA-seq expression data.

invisible(lapply(list.files("Code", pattern = "\\.R$", full.names = TRUE), source))
```

# Loading bulk SCLC data from U of Cologne that contains survival information
```{r loading data}
# Load gene expression data from a file and select relevant columns
scl_df <- read.csv(
  file = "Data/sclc_ucologne_2015/data_mrna_seq_rpkm.txt",
  sep = "\t"
)
scl_df <- subset(scl_df,
  select = c(Hugo_Symbol, sclc_ucologne_2015_S00022:sclc_ucologne_2015_S02397)
)

# Clean up column names by removing prefix
colnames(scl_df) <- sub("^sclc_ucologne_2015_S", "", colnames(scl_df))

# Load clinical data for patients and clean up column names and values
scl_patient <- read.csv(
  file = "Data/sclc_ucologne_2015/data_clinical_patient.txt",
  sep = "\t"
)

scl_patient <- scl_patient %>%
  slice(5:121) %>%
  rename(
    Patient.ID = X.Patient.Identifier, Overall.Survival.Status = Overall.Survival.Status,
    Overall.Survival.Months. = Overall.Survival..Months., Smoker = Smoker, Progress.Free.Survival.Months. = Progress.Free.Survival..Months.
  ) %>%
  select(Patient.ID, Sex, Overall.Survival.Status, Overall.Survival.Months., Progress.Free.Survival.Months., Smoker, Chemotherapy, Neoadjuvant.Chemotherapy, N.Stage, M.Stage, UICC.Tumor.Stage) %>%
  filter(Smoker != "Never") %>%
  filter(Smoker != "") %>%
  mutate(
    Smoker = as.factor(Smoker),
    Smoker = if_else(Smoker == "Current", true = 1, false = 0)
  ) %>%
  mutate(Overall.Survival.Status = ifelse(Overall.Survival.Status == "1:DECEASED", 1, 0)) %>%
  rename(
    vital.status = Overall.Survival.Status,
    time = Overall.Survival.Months.
  ) %>%
  mutate(Patient.ID = gsub(
    x = Patient.ID,
    pattern = "sclc_ucologne_2015_S",
    replacement = ""
  )) %>%
  mutate(vital.status_new = as.numeric(vital.status)) %>%
  mutate(time_new = as.numeric(time)) %>%
  select(-vital.status, -time) %>%
  rename(
    vital.status = vital.status_new,
    time = time_new
  ) %>%
  mutate(time = time * 30) %>%
  filter(time != 0) %>%
  mutate(Progress.Free.Survival.Months. = ifelse(Progress.Free.Survival.Months. == "", NA, Progress.Free.Survival.Months.)) %>%
  rename_all(tolower)
# Uncomment this line for the progress free analysis
# filter(!is.na(progress.free.survival.months.)) %>%
# rename(time2 = progress.free.survival.months.) %>%
# mutate(time2 = as.numeric(time2)) %>%
# mutate(time2 = time2 * 30)


# Extract the list of gene symbols
scl_genes <- scl_df$Hugo_Symbol

# Find the list of patients that have data for both gene expression and clinical data
common_patients <- intersect(scl_patient$patient.id, colnames(scl_df))


# Select only the common columns from gene expression data and transpose it
# so that each row corresponds to a patient
scl_common <- scl_df %>%
  select(all_of(common_patients)) %>%
  t() %>%
  as.data.frame()

# Assign the gene symbols as column names
colnames(scl_common) <- scl_genes

# Remove duplicated columns and add patient ID as a column
scl_common <- scl_common %>%
  select(-which(duplicated(names(.)))) %>%
  rownames_to_column(var = "patient.id")

# Join the gene expression data with the clinical data for each patient
scl_common <- left_join(scl_common, scl_patient[, c(
  "sex", "smoker",
  "vital.status", "time",
  "patient.id", "n.stage", "m.stage", "uicc.tumor.stage",
  "chemotherapy", "neoadjuvant.chemotherapy"
)],
by = "patient.id"
) %>%
  rename_all(tolower) %>%
  select(
    patient.id, sex, smoker, vital.status, time, n.stage, m.stage,
    uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy, everything()
  )

# Removing intermediate files to keep the environment clean
rm(scl_df, scl_patient, scl_genes, common_patients)
```

# Loading and pre-processing single-cell data
```{r single-cell data loading}
# Read in the gene expression data and filter out columns that start with
# "SCLC_P1" or "SCLC_P14" because they have been treated with cancer
# treatment and we don't want it to affect our analysis
sc_df <- fread("Data/OMIX002441-01.csv")
sc_df <- sc_df %>%
  select(-matches("^(SCLC_P1|SCLC_P14)")) %>%
  t() # transpose the data frame to have cells as rows

# Set column names to the first row of the data frame
colnames(sc_df) <- sc_df["V1", ]
sc_df <- sc_df[-1, ] # remove first row, which is now redundant
sc_df <- as.data.frame(sc_df)

# Read in the metadata and filter for tumor samples only
meta_data <- fread("Data/OMIX002441-02.csv")
meta_data <- meta_data %>%
  filter(NT == "tumor")

# Set row names to the first column, which contains the cell IDs
colnames(meta_data)[1] <- "id"

# Join the two dataframes on the "id" column
sc_df$id <- rownames(sc_df)
sc_df <- inner_join(sc_df, meta_data, by = "id")
rownames(sc_df) <- sc_df$id
sc_df <- sc_df %>% select(
  -id, -patient, -NT, -tissue, -cell_type,
  -nCount_RNA, -nFeature_RNA, -Pre_Map_Reads,
  -Aligned_Reads, -MappingRate
)

# Keep only genes that are expressed in at least 10 cells
keep_cols <- colSums(sc_df > 0) > 10
sc_df <- sc_df[, keep_cols]

sc_rownames <- rownames(sc_df)

# Convert the data frame to integers
sc_df <- apply(sc_df, c(1, 2), as.integer) %>%
  as.data.frame()

rownames(sc_df) <- sc_rownames

# Plot the distribution of library sizes
p1 <- ggplot() +
  geom_histogram(aes(x = rowSums(sc_df)), bins = 50) +
  geom_vline(xintercept = 1000, color = "red") +
  theme(
    panel.background = element_blank(),
    axis.title = element_text(size = 22, face = "bold"),
    axis.text = element_text(size = 20),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.ticks = element_line(linewidth = 1.25),
    axis.ticks.length = unit(0.2, units = "cm"),
    axis.line = element_line(color = "black", linewidth = 1.25),
    plot.subtitle = element_text(hjust = 0.5, size = 22)
  ) +
  ggtitle("Distribution of Library Sizes in scRNA-seq",
    subtitle = "Library size distribution after filtering genes with positive expression in at least 10 cells."
  ) +
  xlab("Library Size") +
  ylab("Count") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0))

# Saving to PNG format
ggsave(
  plot = p1, width = 20, height = 20, units = "in", dpi = 600,
  device = "png", filename = "sc_library_distribution_sizes.png", path = "Outputs/"
)

# Saving to SVG format
ggsave(
  plot = p1, width = 20, height = 20, units = "in", dpi = 600,
  device = "svg", filename = "sc_library_distribution_sizes.svg", path = "Outputs/"
)

# Keep only cells with a library size between 1000 and 15000
keep_rows <- rowSums(sc_df) > 1000 & rowSums(sc_df) < 15000
sc_df <- sc_df[keep_rows, ]

# Normalize the library size and take the square root of the expression values
sc_df <- library.size.normalize(sc_df)
sc_df <- sqrt(sc_df)

# Removing intermediate files to keep the environment tidy
rm(keep_cols, keep_rows, sc_rownames, p1)
```

# Single-cell denoising with MAGIC
```{r single-cell denoising}
# Convert the sc_df dataframe to a matrix
sc_df_mat <- as.matrix(sc_df)

# Apply the MAGIC (Model-based Analysis of Genome-wide CRISPR/Cas9 Knockout) algorithm to denoise the scRNA-seq data.
# The 'genes' parameter specifies the set of genes to use for MAGIC imputation. Here, 'all_genes' is used to include all genes in the analysis.
# The 'seed' parameter specifies a random seed for reproducibility.
# The 'n.jobs' parameter specifies the number of cores to use for parallelization. Setting it to -1 indicates that all available cores should be used.
sc_denoised <- magic(sc_df_mat, genes = "all_genes", seed = 123, n.jobs = -1)

# Saving the denoised matrix
saveRDS(sc_denoised, "Outputs/denoised_sc_data.rds")

# Removing intermediate files to keep environment tidy
rm(sc_df_mat)
```

# Pseudotime generation with Monocle3
```{r generating pseudotime from single-cell data}
sc_denoised$result <- sc_denoised$result %>%
  t()

meta_data <- meta_data %>%
  filter(id %in% colnames(sc_denoised$result)) %>%
  column_to_rownames(var = "id")

cds_cell_meta <- meta_data
cds_gene_meta <- data.frame(gene_short_name = rownames(sc_denoised$result))
rownames(cds_gene_meta) <- cds_gene_meta$gene_short_name

emt_genes <- read.csv("Data/emt_genes_tian.txt", sep = "\t")

# Getting common genes between EMT list and our list
common_emt_genes <- intersect(cds_gene_meta$gene_short_name, emt_genes$Gene)
common_emt_genes <- data.frame(gene_short_name = common_emt_genes)
rownames(common_emt_genes) <- common_emt_genes$gene_short_name

cds_output <- cell_dataset_builder(
  gene_expression = "TUBA1A",
  cell_data = sc_denoised$result,
  gene_meta = cds_gene_meta,
  cell_meta = cds_cell_meta,
  pt_root = "Y_7",
  gene_title = "TUBA1A",
  pt_title = "TUBA1A",
  point_size = 2.5,
  norm_flag = "none",
  use_ordering_funct = FALSE,
  cds_filename = "Outputs/cds.rds",
  plot_file = "Outputs/emt_gene_expression.png",
  pt_file = "Outputs/pt_expression.png",
  pt_data_filename = "Outputs/TUBA1A_pseudotime_data.csv"
)

# Bringing the cell expression and pseudotime graphs together into a single plot
combo_plot <- ggarrange(cds_output$Cell_Progression_Graph, cds_output$PT_Graph,
  ncol = 2, nrow = 1, align = "h", labels = c("A.", "B."),
  legend = "bottom", font.label = c(size = 18)
)

combo_plot <- combo_plot + ggtitle("SDE Pseudotime Ordering") +
  theme(
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5, size = 9)
  )


# Saving to PNG
ggsave(
  plot = combo_plot, device = "png", dpi = 600, width = 7, height = 5,
  units = "in", filename = "Outputs/sde_foundation_plot.png", bg = "white"
)

# Saving to SVG
ggsave(
  plot = combo_plot, device = "svg", dpi = 600, width = 7, height = 5,
  units = "in", filename = "Outputs/sde_foundation_plot.svg", bg = "white"
)
```

# Calculating and saving SDE metric
```{r sde metric}
sde_genes <- switchde_calculator(sc_denoised$result,
  pseudo_time = cds_output$PT_Data
)

saveRDS(sde_genes, "Outputs/sde_genes.rds")

head(sde_genes)
```

# Finding ideal number of genes for SDE metric
```{r ideal gene number for sde metric}
gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1
for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(my_seed = 1, my_alpha = 1, cox_predictors = sde_genes, cox_df = scl_common, gene_num = gn, n_folds = 10, calc_auc = FALSE, save_coefs = FALSE, verbose = FALSE, cat_preds = FALSE)
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  write.csv(cindex_df, paste0("Outputs/sde/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, ".csv"))
  counter <- counter + 1
}


# Now seeing what the best c-index is
all_sde_cindices <- read_files(folder_path = "Outputs/sde/", pattern = "*.csv")
max_sde_cindex <- all_sde_cindices[which.max(all_sde_cindices$cindex), ] # 0.7221 with 7 active genes
```

# Calculating and saving MAD metric
```{r mad metric}
mad_genes <- mad_calculator(sc_denoised$result)
saveRDS(mad_genes, "Outputs/mad_genes.rds")
head(mad_genes)
```

# Finding ideal gene size for MAD metric
```{r ideal gene size for mad}
gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1
for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(my_seed = 1, my_alpha = 1, cox_predictors = mad_genes, cox_df = scl_common, gene_num = gn, n_folds = 10, calc_auc = FALSE, save_coefs = FALSE, verbose = FALSE, cat_preds = FALSE)
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  write.csv(cindex_df, paste0("Outputs/mad/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, ".csv"))
  counter <- counter + 1
}


# Now seeing what the best c-index is
all_mad_cindices <- read_files(folder_path = "Outputs/mad/", pattern = "*.csv")
max_mad_cindex <- all_mad_cindices[which.max(all_mad_cindices$cindex), ] # 0.7718 with 13 active genes
all_mad_cindices_sub <- all_mad_cindices %>% filter(cindex_active_genes == 7 | cindex_active_genes == 8) # 0.7221 with 7 active genes
```

# C-index of small miRNA set
```{r mirna with small number of active genes cindex}
file_list <- list.files(path = "Outputs/mirna/rds", pattern = "*.rds", full.names = TRUE)
file_list <- file_list[!grepl("_mat_", file_list)]

gene_sizes <- seq(2, 8, 1)
cox_outputs <- list()
counter <- 1
for (f in file_list) {
  print(f)
  for (gn in gene_sizes) {
    current_mirna_met <- readRDS(paste0(f))
    current_cox <- cox_model_fitter(my_seed = 1, my_alpha = 1, cox_predictors = current_mirna_met, cox_df = scl_common, gene_num = gn, n_folds = 10, calc_auc = FALSE, save_coefs = FALSE, verbose = FALSE, cat_preds = FALSE)
    cox_outputs[[counter]] <- current_cox
    mirna_genes <- str_extract(f, "(?<=mirna_genes_)\\d+")
    mirnas <- str_extract(f, "(?<=mirnas_)\\d+")
    cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/mirna/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_mirnas_", mirnas, "_targets_", mirna_genes, ".csv"))
    counter <- counter + 1
  }
}
```

# Finding performance of the small miRNA set
```{r loading in all mirna outputs for small size and finding performance}
# Now seeing what the best c-index is
all_mirna_cindices <- read_files(folder_path = "Outputs/mirna/glmnet/", pattern = "*.csv")
max_mirna_cindex <- all_mirna_cindices[which.max(all_mirna_cindices$cindex), ] #  0.7560 with 5 active genes
```

```{r df of individual metrics}
all_individual_met_df <- bind_rows(max_mirna_cindex, max_sde_cindex, all_mad_cindices_sub[1, ])
all_individual_met_df <- all_individual_met_df %>%
  mutate(metric = c("mirna", "sde", "mad"))
```

# Cancer clinical staging Cox model 
```{r generate a cox model with just the cancer staging to see performance}
scl_patient <- read.csv(
  file = "Data/sclc_ucologne_2015/data_clinical_patient.txt",
  sep = "\t"
)

scl_patient <- scl_patient %>%
  slice(5:121) %>%
  rename(
    Patient.ID = X.Patient.Identifier, Overall.Survival.Status = Overall.Survival.Status,
    Overall.Survival.Months. = Overall.Survival..Months., Smoker = Smoker
  ) %>%
  select(Patient.ID, Sex, Overall.Survival.Status, Overall.Survival.Months., Smoker, Sex, Ethnicity.Category, N.Stage, M.Stage, UICC.Tumor.Stage, Chemotherapy, Neoadjuvant.Chemotherapy) %>%
  filter(Smoker != "Never") %>%
  filter(Smoker != "") %>%
  mutate(
    Smoker = as.factor(Smoker),
    Smoker = if_else(Smoker == "Current", true = 1, false = 0)
  ) %>%
  mutate(Overall.Survival.Status = ifelse(Overall.Survival.Status == "1:DECEASED", 1, 0)) %>%
  rename(
    vital.status = Overall.Survival.Status,
    time = Overall.Survival.Months.
  ) %>%
  mutate(Patient.ID = gsub(
    x = Patient.ID,
    pattern = "sclc_ucologne_2015_S",
    replacement = ""
  )) %>%
  mutate(vital.status_new = as.numeric(vital.status)) %>%
  mutate(time_new = as.numeric(time)) %>%
  select(-vital.status, -time) %>%
  rename(
    vital.status = vital.status_new,
    time = time_new
  ) %>%
  mutate(time = time * 30) %>%
  filter(time != 0) %>%
  rename_all(tolower)

scl_clinical_only <- scl_patient %>%
  mutate(n.stage = ifelse(n.stage == "", NA, n.stage)) %>%
  mutate(m.stage = ifelse(m.stage == "", NA, m.stage)) %>%
  filter(!is.na(ethnicity.category) & !is.na(n.stage) & !is.na(m.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ia", 1, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "I", 1, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ib", 1, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IB", 1, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIa", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IV", 4, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "iib", 2, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "iia", 2, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "iiia", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "iiib", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIa", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIb", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIa", 2, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIb", 2, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "II", 2, uicc.tumor.stage)) %>%
  mutate(n.stage = ifelse(n.stage == "1a", 1, n.stage)) %>%
  mutate(n.stage = ifelse(n.stage == "1b", 1, n.stage)) %>%
  mutate(n.stage = ifelse(n.stage == "X", "x", n.stage)) %>%
  mutate(m.stage = ifelse(m.stage == "1a", 1, m.stage)) %>%
  mutate(m.stage = ifelse(m.stage == "1b", 1, m.stage))

surv_y <- Surv(time = scl_clinical_only$time, event = scl_clinical_only$vital.status, type = "right")
clinical_cox_only <- coxph(data = scl_clinical_only, formula = surv_y ~ n.stage + m.stage + uicc.tumor.stage)
summary_clinical <- summary(clinical_cox_only)
clinical_staging_only_cindex <- round(as.numeric(as.vector(summary_clinical$concordance["C"])), digits = 4) # 0.6205 with 9 active predictors
clinical_staging_only_cindex_se <- round(as.numeric(as.vector(summary_clinical$concordance["se(C)"])), digits = 4)

clinical_staging_only_df <- data.frame(X = 1, cindex = clinical_staging_only_cindex, cindex_se = clinical_staging_only_cindex_se, cindex_active_genes = 9, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "clinical_staging")
# Adding staging c-index to df of other individual metrics
all_individual_met_df <- bind_rows(all_individual_met_df, clinical_staging_only_df)
```

# Random gene Cox performance
```{r random gene selection}
scl_common <- scl_common %>%
  select(
    -patient.id, -sex, -smoker, -vital.status, -time, -n.stage, -m.stage,
    -uicc.tumor.stage, -chemotherapy, -neoadjuvant.chemotherapy
  )

# Function to randomly sample genes from the dataset
sample_genes <- function(df, n_genes, n_samples = 1000) {
  gene_names <- colnames(df)
  n_genes <- min(n_genes, length(gene_names))
  samples <- lapply(1:n_samples, function(x) {
    df %>%
      select(sample(gene_names, n_genes, replace = FALSE)) %>%
      rename_all(tolower)
  })
  return(samples)
}


set.seed(123)
sampled_genes <- sample_genes(df = scl_common, n_genes = 7, n_samples = 1000)

# Re-loading the scl file so that we can include the meta data
scl_patient <- read.csv(
  file = "Data/sclc_ucologne_2015/data_clinical_patient.txt",
  sep = "\t"
)

scl_patient <- scl_patient %>%
  slice(5:121) %>%
  rename(
    Patient.ID = X.Patient.Identifier, Overall.Survival.Status = Overall.Survival.Status,
    Overall.Survival.Months. = Overall.Survival..Months., Smoker = Smoker
  ) %>%
  select(Patient.ID, Sex, Overall.Survival.Status, Overall.Survival.Months., Smoker, Sex) %>%
  filter(Smoker != "Never") %>%
  filter(Smoker != "") %>%
  mutate(
    Smoker = as.factor(Smoker),
    Smoker = if_else(Smoker == "Current", true = 1, false = 0)
  ) %>%
  mutate(Overall.Survival.Status = ifelse(Overall.Survival.Status == "1:DECEASED", 1, 0)) %>%
  rename(
    vital.status = Overall.Survival.Status,
    time = Overall.Survival.Months.
  ) %>%
  mutate(Patient.ID = gsub(
    x = Patient.ID,
    pattern = "sclc_ucologne_2015_S",
    replacement = ""
  )) %>%
  mutate(vital.status_new = as.numeric(vital.status)) %>%
  mutate(time_new = as.numeric(time)) %>%
  select(-vital.status, -time) %>%
  rename(
    vital.status = vital.status_new,
    time = time_new
  ) %>%
  mutate(time = time * 30) %>%
  filter(time != 0) %>%
  rename_all(tolower)


# Extract the list of gene symbols
scl_genes <- scl_df$Hugo_Symbol

# Find the list of patients that have data for both gene expression and clinical data
common_patients <- intersect(scl_patient$patient.id, colnames(scl_df))

# Select only the common columns from gene expression data and transpose it
# so that each row corresponds to a patient
scl_common <- scl_df %>%
  select(all_of(common_patients)) %>%
  t() %>%
  as.data.frame()

# Assign the gene symbols as column names
colnames(scl_common) <- scl_genes

# Remove duplicated columns and add patient ID as a column
scl_common <- scl_common %>%
  select(-which(duplicated(names(.)))) %>%
  rownames_to_column(var = "patient.id")

# Join the gene expression data with the clinical data for each patient
scl_common <- left_join(scl_common, scl_patient[, c(
  "vital.status", "time",
  "patient.id"
)],
by = "patient.id"
) %>%
  rename_all(tolower) %>%
  select(
    patient.id, vital.status, time, everything()
  )


counter <- 1
cox_outputs <- list()
for (g in sampled_genes) {
  current_genes <- g
  current_cox <- cox_model_fitter(my_seed = 1, my_alpha = 1, cox_predictors = current_genes, cox_df = scl_common, gene_num = 7, n_folds = 10, calc_auc = FALSE, save_coefs = FALSE, verbose = FALSE, cat_preds = FALSE)
  cox_outputs[[counter]] <- current_cox

  if (is.null(current_cox)) {
    next
  } else {
    cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/random_genes/glmnet_7_genes_glmnet_index_", cindex_index, "_lambda_", lambda, ".csv"))
    counter <- counter + 1
  }
}


# Combining all files together
all_random_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/random_genes/", pattern = "*.csv")
mean_random_cindices <- mean(all_random_cindices$cindex) # 0.606116
random_genes_only_df <- data.frame(X = 1, cindex = mean_random_cindices, cindex_se = NA, cindex_active_genes = NA, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "random_genes")
all_individual_met_df <- bind_rows(all_individual_met_df, random_genes_only_df)
write.csv(all_individual_met_df, "Outputs/all_individual_metrics_cindex.csv")
```

# Getting miRNA targeting info to make miRNA metric
```{r mirna}
# Now sending those miRNAs to TargetScan
mirna_num <- seq(100, 800, 100)
mirna_target_num <- seq(2, 8, 1)
for (m in mirna_num[1:4]) {
  for (t in mirna_target_num[1:7]) {
    mirna_genes <- mirna_calculator(ts_org = "Human", ts_version = "8.0", max_mir_targets = t, cancer_up = TRUE, cancer_type1 = "lung cancer", print_ts_targets = FALSE, status = "up", max_mirnas = m, mirna_genes_mat_name = paste0("Outputs/mirna/mirna_genes_mat_", m, "_mirnas_", t, "_targets_up.csv"), mirna_ranking_name = paste0("Outputs/mirna/mirna_genes_", m, "_mirnas_", t, "_targets_up_.csv"), mirna_ranking_name_rds = paste0("Outputs/mirna/mirna_genes_", m, "_mirnas_", t, "_targets_up_.rds"), mirna_genes_mat_name_rds = paste0("Outputs/mirna/mirna_genes_mat_", m, "_mirnas_", t, "_targets_up.rds"))
  }
}
```

## Combinations of metrics
# MAD + SDE
```{r mad + sde}
sde_genes <- readRDS("Outputs/sde_genes.rds")
mad_genes <- readRDS("Outputs/mad_genes.rds")

# Optimize the weights of the MAD + SDE metrics
mad_sde_optimized <- two_weight_optimizer(
  first.metric = mad_genes,
  second.metric = sde_genes,
  my.start = 0,
  my.finish = 1,
  step.size = 0.1,
  my.filename = paste0("Outputs/Optimization_mad_sde_1_alpha.rds")
)

gene_sizes <- seq(2, 8, 1)
counter <- 1
for (ms in mad_sde_optimized) {
  for (gs in gene_sizes) {
    current_cox <- cox_model_fitter(
      my_seed = 1,
      my_alpha = 1,
      cox_predictors = ms,
      cox_df = scl_common,
      gene_num = gs,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10
    )
    cindex <- current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/mad_sde/cindex_", gs, "_mad_sde_optimized_", counter, ".csv"))
    active_genes_df <- as.data.frame(cbind(current_cox$`Active Genes`, current_cox$`Active Coefficients`))
    colnames(active_genes_df) <- c("gene", "coef")
    write.csv(active_genes_df, paste0("Outputs/glmnet_coefs/mad_sde/cindex_", gs, "_mad_sde_optimized_", counter, "_active_coefs_df.csv"))
    counter <- counter + 1
  }
}

all_mad_sde_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/mad_sde/", pattern = "*.csv")
max_mad_sde_cindices <- all_mad_sde_cindices[which.max(all_mad_sde_cindices$cindex), ] # 0.7201824 with 3 active predictors
```

# miRNA + SDE
```{r mirna + sde}
sde_genes <- readRDS("Outputs/sde_genes.rds")
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
gene_sizes <- seq(2, 8, 1)
counter <- 1

# Optimizing the weights
mirna_sde_optimized <- two_weight_optimizer(
  first.metric = mirna_genes,
  second.metric = sde_genes,
  my.start = 0,
  my.finish = 1,
  step.size = 0.1,
  my.filename = paste0("Outputs/Optimization_mirna_sde_1_alpha.rds")
)

for (ms in mirna_sde_optimized) {
  for (gs in gene_sizes) {
    current_cox <- cox_model_fitter(
      my_seed = 1,
      my_alpha = 1,
      cox_predictors = ms,
      cox_df = scl_common,
      gene_num = gs,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10
    )
    cindex <- current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/mirna_sde/cindex_", gs, "_mirna_sde_optimized_", counter, ".csv"))
    active_genes_df <- as.data.frame(cbind(current_cox$`Active Genes`, current_cox$`Active Coefficients`))
    colnames(active_genes_df) <- c("gene", "coef")
    write.csv(active_genes_df, paste0("Outputs/glmnet_coefs/mirna_sde/cindex_", gs, "_mirna_sde_optimized_", counter, "_active_coefs_df.csv"))
    counter <- counter + 1
  }
}

all_mirna_sde_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/mirna_sde/", pattern = "*.csv")
max_mirna_sde_cindices <- all_mirna_sde_cindices[which.max(all_mirna_sde_cindices$cindex), ] # 0.7560 with 5 active predictors
```

# miRNA + MAD
```{r mad + mirna}
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
mad_genes <- readRDS("Outputs/mad_genes.rds")

# Optimize the weights of the MAD + SDE metrics
mad_mirna_optimized <- two_weight_optimizer(
  first.metric = mad_genes,
  second.metric = mirna_genes,
  my.start = 0,
  my.finish = 1,
  step.size = 0.1,
  my.filename = paste0("Outputs/Optimization_mad_mirna_1_alpha.rds")
)

gene_sizes <- seq(2, 8, 1)
counter <- 1
for (ms in mad_mirna_optimized) {
  for (gs in gene_sizes) {
    current_cox <- cox_model_fitter(
      my_seed = 1,
      my_alpha = 1,
      cox_predictors = ms,
      cox_df = scl_common,
      gene_num = gs,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10
    )
    cindex <- current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/mirna_mad/cindex_", gs, "_mirna_mad_optimized_", counter, ".csv"))
    active_genes_df <- as.data.frame(cbind(current_cox$`Active Genes`, current_cox$`Active Coefficients`))
    colnames(active_genes_df) <- c("gene", "coef")
    write.csv(active_genes_df, paste0("Outputs/glmnet_coefs/mirna_mad/cindex_", gs, "_mirna_mad_optimized_", counter, "_active_coefs_df.csv"))
    counter <- counter + 1
  }
}

all_mirna_mad_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/mirna_mad/", pattern = "*.csv")
max_mirna_mad_cindices <- all_mirna_mad_cindices[which.max(all_mirna_mad_cindices$cindex), ] # 0.7559976 with 5 active predictors
```

# miRNA + MAD + SDE
```{r mirna + mad + sde}
sde_genes <- readRDS("Outputs/sde_genes.rds")
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
mad_genes <- readRDS("Outputs/mad_genes.rds")
gene_sizes <- seq(2, 8, 1)
counter <- 1

# Optimizing the weights
mirna_mad_sde_optimized <- three_weight_optimizer(
  first.metric = mirna_genes,
  second.metric = sde_genes,
  third.metric = mad_genes,
  my.start = 0,
  my.finish = 1,
  step.size = 0.1,
  my.filename = paste0("Outputs/Optimization_mirna_mad_sde_1_alpha.rds")
)

for (ms in mirna_mad_sde_optimized) {
  for (gs in gene_sizes) {
    current_cox <- cox_model_fitter(
      my_seed = 1,
      my_alpha = 1,
      cox_predictors = ms,
      cox_df = scl_common,
      gene_num = gs,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10
    )
    cindex <- current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/mirna_mad_sde/cindex_", gs, "_mirna_mad_sde_optimized_", counter, ".csv"))
    active_genes_df <- as.data.frame(cbind(current_cox$`Active Genes`, current_cox$`Active Coefficients`))
    colnames(active_genes_df) <- c("gene", "coef")
    write.csv(active_genes_df, paste0("Outputs/glmnet_coefs/mirna_mad_sde/cindex_", gs, "_mirna_mad_sde_optimized_", counter, "_active_coefs_df.csv"))
    counter <- counter + 1
  }
}

all_mirna_mad_sde_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/mirna_mad_sde/", pattern = "*.csv")
max_mirna_mad_sde_cindices <- all_mirna_mad_sde_cindices[which.max(all_mirna_mad_sde_cindices$cindex), ] # 0.76910 with 6 active predictors
```

# Attempting to generate several synthetic datasets based on our original survival distribution
```{r 1000 reps for bootstrap for comparison}
set.seed(1)
# Assume your original dataset is named `data` and it has a column named `vital.status`
# Get the distribution of the vital status column
vital_status_dist <- table(scl_common$vital.status)

# Create a function to generate bootstrap samples
bootstrap_func <- function(data) {
  # Randomly sample with replacement from the original data
  bootstrap_sample <- sample_n(data, nrow(data), replace = TRUE)
  return(bootstrap_sample)
}


# Generate 1000 datasets using bootstrap sampling that match the distribution of the vital status column
bootstrap_datasets <- replicate(1000,
  {
    # Create an empty data frame to store the bootstrap samples
    bootstrap_data <- data.frame()

    # Loop through each unique value in the vital status column and generate a bootstrap sample for each value
    for (i in seq_along(vital_status_dist)) {
      # Subset the original data to only include rows with the current value of the vital status column
      current_data <- scl_common %>% filter(vital.status == names(vital_status_dist)[i])

      # Calculate the number of rows needed for the bootstrap sample
      n_rows <- vital_status_dist[i]

      # Generate a bootstrap sample for the current value of the vital status column
      bootstrap_sample <- bootstrap_func(current_data)

      # Add the bootstrap sample to the empty data frame
      bootstrap_data <- rbind(bootstrap_data, bootstrap_sample[1:n_rows, ])
    }

    return(bootstrap_data)
  },
  simplify = FALSE
)
```

# Now taking our 1000 datasets and testing the 6 predictors we have identified and seeing how they perform
```{r for 1000 simulations of 10 fold cv on mirna + mad + sde}
cox_outputs <- list()
counter <- 1
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7204482 with the 6 active perdictors from mad + sde + miRNA
```

# MAD on 1000 simulated datasets
```{r now doing the same with MAD to ensure fair comparison}
cox_outputs <- list()
counter <- 1
cox_preds <- mad_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6212627 with the 5 active predictors from MAD
```

# SDE on 1000 simulated datasets
```{r now doing the same with SDE to ensure fair comparison}
cox_outputs <- list()
counter <- 1
cox_preds <- sde_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 7,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6746058 with the 7 active predictors from SDE
```

# miRNA on 1000 simulated datasets
```{r now doing the same with miRNA to ensure fair comparison}
cox_outputs <- list()
counter <- 1
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
cox_preds <- mirna_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6920965 with the 5 active predictors from miRNA
```

# miRNA + SDE on 1000 simulated datasets
```{r mirna + sde 1000}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("znf460", "tfrc", "fam83f", "samd12", "grin2b"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6907635 with the 5 active predictors from miRNA + SDE
```

# miRNA + MAD on 1000 simulated datasets
```{r mirna + mad 1000}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("znf460", "tfrc", "fam83f", "samd12", "grin2b"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6907635 with the 5 active predictors from miRNA + MAD
```

# MAD + SDE on 1000 simulated datasets
```{r mad + sde 1000}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("dlk1", "arl6ip1", "ube2c"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 3,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6958149 with the 3 active predictors from MAD + SDE
```

# Clinical Staging on 1000 simulated datasets
```{r clinical staging 1000}
# Function to efficiently simplify tumor staging
modify_dataframe <- function(df) {
  df <- df %>%
    mutate(n.stage = factor(gsub("[A-Za-z]", "", n.stage))) %>%
    mutate(m.stage = factor(gsub("[A-Za-z]", "", m.stage))) %>%
    mutate(n.stage = ifelse(n.stage == "", NA, n.stage)) %>%
    mutate(m.stage = ifelse(m.stage == "", NA, m.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "I", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ia", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ib", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ic", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IA", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IB", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IC", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "II", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIa", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIb", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIc", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIA", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIB", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIC", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "III", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIa", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIb", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIc", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIA", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIB", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIC", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IV", 4, uicc.tumor.stage)) %>%
    filter(!is.na(n.stage)) %>%
    filter(!is.na(m.stage)) %>%
    filter(!is.na(uicc.tumor.stage))

  return(df)
}

cox_outputs <- list()
counter <- 1
cox_preds <- c("n.stage", "m.stage", "uicc.tumor.stage")
bootstrap_datasets_clinical <- bootstrap_datasets
bootstrap_datasets_clinical <- lapply(bootstrap_datasets_clinical, modify_dataframe)

for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 3,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7081862 with the 3 active predictors from miRNA
```


# Plot for individual metrics for overall survival with initial dataset perforamnce
```{r combining all overall survival cindicies together for first panel}
all_individual_met_df <- read.csv("Outputs/all_individual_metrics_cindex.csv")
mirna_mad_only_df <- data.frame(X = 1, cindex = 0.7559976, cindex_se = NA, cindex_active_genes = 5, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "mirna_mad")
all_individual_met_df <- bind_rows(all_individual_met_df, mirna_mad_only_df)
mirna_mad_sde_only_df <- data.frame(X = 1, cindex = 0.76910, se = NA, cindex_active_genes = 6, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "mirna_mad_sde")
all_individual_met_df <- bind_rows(all_individual_met_df, mirna_mad_sde_only_df)
mirna_sde_only_df <- data.frame(X = 1, cindex = 0.7560, cindex_se = NA, cindex_active_genes = 5, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "mirna_sde")
all_individual_met_df <- bind_rows(all_individual_met_df, mirna_sde_only_df)
mad_sde_only_df <- data.frame(X = 1, cindex = 0.7201824, cindex_se = NA, cindex_active_genes = 3, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "mad_sde")
all_individual_met_df <- bind_rows(all_individual_met_df, mad_sde_only_df)
write.csv(all_individual_met_df, "Outputs/all_individual_metrics_cindex.csv")

# Starting plotting code
all_individual_metrics_cindex$metric <- factor(all_individual_metrics_cindex$metric, levels = c("mad", "sde", "mirna", "clinical_staging", "random_genes", "mad_sde", "mirna_mad", "mirna_sde", "mirna_mad_sde"), labels = c("M", "S", "miR", "CS", "RG", "MS", "miRM", "miRS", "miRMS"))

all_individual_metrics_cindex <- all_individual_metrics_cindex %>%
  select(cindex, metric) %>%
  mutate(cindex = round(cindex, digits = 4))


p1 <- ggplot(data = all_individual_metrics_cindex, aes(x = metric, y = cindex, fill = metric, color = metric)) +
  geom_col(width = 0.4) +
  geom_text(aes(label = round(cindex, 2), y = cindex + 0.01),
    size = 4,
    position = position_dodge(width = 0.4), color = "black"
  ) +
  theme(
    panel.background = element_blank(),
    axis.title = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 14),
    axis.text.x = element_text(angle = 45, vjust = 0.7),
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.ticks.length = unit(0.2, units = "cm"),
    legend.position = "none",
    axis.ticks = element_line(color = "black", linewidth = 0.75)
  ) +
  xlab("Metric") +
  ylab("Mean 10-fold CV C-index") +
  ggtitle("Single Dataset | Overall Survival") +
  scale_y_continuous(expand = c(0, 0))
p1 <- p1 + coord_cartesian(ylim = c(0.5, 0.8)) +
  scale_fill_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef")) +
  scale_color_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef"))
p1

# Save to PNG
ggsave(p1, device = "png", filename = "figure_a_panel_a.png", path = "Figures/panels/", width = 8, height = 8, dpi = 600, units = "in")

# Save to SVG
ggsave(p1, device = "svg", filename = "figure_a_panel_a.svg", path = "Figures/panels/", width = 8, height = 8, dpi = 600, units = "in")
```

# Plot for individual metrics for overall survival with 1,000 simulated datasets performance
```{r combining all overall survival cindicies together for second panel}
plot_df <- data.frame(metric = c("M", "S", "miR", "CS", "MS", "miRM", "miRS", "miRMS"), cindex = c(0.6212627, 0.6746058, 0.6920965, 0.7081862, 0.6958149, 0.6907635, 0.6907635, 0.7204482))

plot_df$metric <- factor(plot_df$metric, levels = c("M", "S", "miR", "CS", "MS", "miRM", "miRS", "miRMS"), labels = c("M", "S", "miR", "CS", "MS", "miRM", "miRS", "miRMS"))
p1 <- ggplot(data = plot_df, aes(x = metric, y = cindex, fill = metric, color = metric)) +
  geom_col(width = 0.4) +
  geom_text(aes(label = round(cindex, 2), y = cindex + 0.01),
    size = 4,
    position = position_dodge(width = 0.4), color = "black"
  ) +
  theme(
    panel.background = element_blank(),
    axis.title = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 14),
    axis.text.x = element_text(angle = 45, vjust = 0.7),
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.ticks.length = unit(0.2, units = "cm"),
    legend.position = "none",
    axis.ticks = element_line(color = "black", linewidth = 0.75)
  ) +
  xlab("Metric") +
  ylab("Mean 10-fold CV C-index") +
  ggtitle("1000 Bootstrapped Datasets | Overall Survival") +
  scale_y_continuous(expand = c(0, 0))
p1 <- p1 + coord_cartesian(ylim = c(0.5, 0.8)) +
  scale_fill_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef")) +
  scale_color_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef"))
p1

# Save to PNG
ggsave(p1, device = "png", filename = "figure_a_panel_b.png", path = "Figures/panels/", width = 8, height = 8, dpi = 600, units = "in")

# Save to SVG
ggsave(p1, device = "svg", filename = "figure_a_panel_b.svg", path = "Figures/panels/", width = 8, height = 8, dpi = 600, units = "in")
```


# Simulated datasets with progress free survival for the identified signatures
# miRNA + MAD + SDE
```{r mirna + mad + sde progress free}
cox_outputs <- list()
counter <- 1
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7460983 with the 6 active predictors from MAD + SDE + miRNA
```

```{r MAD progress free}
cox_outputs <- list()
counter <- 1
mad_genes <- readRDS("Outputs/mad_genes.rds")
cox_preds <- mad_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7001656 with the 6 active predictors from MAD
```

# SDE
```{r sde progress free}
cox_outputs <- list()
counter <- 1
cox_preds <- sde_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 7,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.749532 with the 7 active predictors from SDE
```

# miRNA
```{r mirna progress free}
cox_outputs <- list()
counter <- 1
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
cox_preds <- mirna_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7488896 with the 5 active predictors from miRNA
```

# miRNA + SDE
```{r mirna + sde progress free}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("znf460", "tfrc", "fam83f", "samd12", "grin2b"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7463801 with the 5 active predictors from miRNA + SDE
```

# miRNA + MAD
```{r mirna + mad progress free}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("znf460", "tfrc", "fam83f", "samd12", "grin2b"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7463801 with the 5 active predictors from miRNA + MAD
```

# MAD + SDE
```{r mad + sde progress free}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("dlk1", "arl6ip1", "ube2c"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 3,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.732993 with the 3 active predictors from MAD + SDE
```

# Clinical staging
```{r clinical staging progress free}
# Function to efficiently simplify tumor staging
modify_dataframe <- function(df) {
  df <- df %>%
    mutate(n.stage = factor(gsub("[A-Za-z]", "", n.stage))) %>%
    mutate(m.stage = factor(gsub("[A-Za-z]", "", m.stage))) %>%
    mutate(n.stage = ifelse(n.stage == "", NA, n.stage)) %>%
    mutate(m.stage = ifelse(m.stage == "", NA, m.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "I", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ia", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ib", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ic", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IA", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IB", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IC", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "II", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIa", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIb", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIc", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIA", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIB", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIC", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "III", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIa", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIb", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIc", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIA", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIB", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIC", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IV", 4, uicc.tumor.stage)) %>%
    filter(!is.na(n.stage)) %>%
    filter(!is.na(m.stage)) %>%
    filter(!is.na(uicc.tumor.stage))

  return(df)
}

cox_outputs <- list()
counter <- 1
cox_preds <- c("n.stage", "m.stage", "uicc.tumor.stage")
bootstrap_datasets_clinical <- bootstrap_datasets
bootstrap_datasets_clinical <- lapply(bootstrap_datasets_clinical, modify_dataframe)

for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    progress_free = TRUE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 3,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7208957 with the 3 active predictors from clinical staging
```

# Plot for individual metrics for progress free survival with 1,000 simulated datasets performance
```{r combining all overall survival cindicies together for third panel}
plot_df <- data.frame(
  metric = c("M", "S", "miR", "CS", "MS", "miRM", "miRS", "miRMS"),
  cindex = c(0.7001656, 0.749532, 0.7488896, 0.7208957, 0.732993, 0.7463801, 0.7463801, 0.7460983)
)

plot_df$metric <- factor(plot_df$metric, levels = c("M", "S", "miR", "CS", "MS", "miRM", "miRS", "miRMS"), labels = c("M", "S", "miR", "CS", "MS", "miRM", "miRS", "miRMS"))
p1 <- ggplot(data = plot_df, aes(x = metric, y = cindex, fill = metric, color = metric)) +
  geom_col(width = 0.4) +
  geom_text(aes(label = round(cindex, 2), y = cindex + 0.01),
    size = 4,
    position = position_dodge(width = 0.4), color = "black"
  ) +
  theme(
    panel.background = element_blank(),
    axis.title = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 14),
    axis.text.x = element_text(angle = 45, vjust = 0.7),
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.ticks.length = unit(0.2, units = "cm"),
    legend.position = "none",
    axis.ticks = element_line(color = "black", linewidth = 0.75)
  ) +
  xlab("Metric") +
  ylab("Mean 10-fold CV C-index") +
  ggtitle("1000 Bootstrapped Datasets | Progress Free Survival") +
  scale_y_continuous(expand = c(0, 0))
p1 <- p1 + coord_cartesian(ylim = c(0.5, 0.8)) +
  scale_fill_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef")) +
  scale_color_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef"))
p1

# Save to PNG
ggsave(p1, device = "png", filename = "figure_a_panel_c.png", path = "Figures/panels/", width = 9, height = 9, dpi = 600, units = "in")

# Save to SVG
ggsave(p1, device = "svg", filename = "figure_a_panel_c.svg", path = "Figures/panels/", width = 9, height = 9, dpi = 600, units = "in")
```

# Simulating survival data
```{r simulating survival data}
preds <- c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13")
top_pred_df <- select(scl_common, all_of(preds))
simdata <- sim.survdata(N = 1000, T = 4920, X = top_pred_df, num.data.frames = 1000, beta = c(-0.75737985824054, -0.0706471525401676, -0.16554139965723, 0.305795111401098, -0.000374799303479439, -0.027261204056091), censor = 0.18)

# First, let's assume your coefficients for each gene are stored in a vector like this:
coef <- c(-0.75737985824054, -0.0706471525401676, -0.16554139965723, 0.305795111401098, -0.000374799303479439, -0.027261204056091)

# And your data frame `data` has columns named after the genes
genes <- c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13")

# Then, you can calculate the risk score like this:
test <- simdata[[1]]$data
test2 <- simdata[[25]]$data
test$risk_score <- rowSums(sapply(seq_along(genes), function(i) test[, genes[i]] * coef[i]))
test2$risk_score <- rowSums(sapply(seq_along(genes), function(i) test2[, genes[i]] * coef[i]))

# Now, you may want to binarize the risk score into high and low risk groups, using median risk as a threshold:
median_risk <- median(test$risk_score)
median_risk <- median(test2$risk_score)
test$risk <- ifelse(test$risk_score > median_risk, "high", "low")
test2$risk <- ifelse(test2$risk_score > median_risk, "high", "low")



# # Extract the number of cell lines and genes from the original dataset
# num_cell_lines <- ncol(cell_lines)
# num_genes <- nrow(cell_lines)
# 
# # Calculate the mean and standard deviation of gene expression from the original dataset
# mean_expression <- apply(cell_lines, 1, mean)
# sd_expression <- apply(cell_lines, 1, sd)
# 
# # Generate synthetic gene expression profiles
# synthetic_expression <- matrix(rnorm(num_cell_lines * num_genes, mean_expression, sd_expression),
#   nrow = num_genes, ncol = num_cell_lines, dimnames = list(rownames(cell_lines), colnames(cell_lines))
# )
# 
# synthetic_expression <- t(synthetic_expression)
# 
# colnames(synthetic_expression) <- tolower(colnames(synthetic_expression))
# 
# # Print the dimensions of the synthetic expression matrix
# cat("Dimensions of the synthetic expression matrix:", dim(synthetic_expression))
# 
# # Print the first few rows of the synthetic expression matrix
# head(synthetic_expression)
```

# miRNA + MAD + SDE Overall survival KM plot
```{r original data risk score and km plot for miRNA + MAD + SDE}
# Original data risk score
# First, let's assume your coefficients for each gene are stored in a vector like this:
coef <- c(-0.75737985824054, -0.0706471525401676, -0.16554139965723, 0.305795111401098, -0.000374799303479439, -0.027261204056091)

# And your data frame `data` has columns named after the genes
genes <- c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13")

scl_common$risk_score <- rowSums(sapply(seq_along(genes), function(i) scl_common[, genes[i]] * coef[i]))
median_risk <- median(scl_common$risk_score)
scl_common$risk <- ifelse(scl_common$risk_score > median_risk, "high", "low")

scl_common <- scl_common %>%
  select(patient.id, sex, smoker, vital.status, time, n.stage, m.stage, uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy, risk_score, risk, everything())

# Function to compute p-value from Kaplan-Meier fit
compute_p_value <- function(data, progress_free = FALSE) {
  if (progress_free) {
    fit <- survfit(Surv(data$time2, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time2, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  } else {
    fit <- survfit(Surv(data$time, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  }
}

# Compute observed p-value
observed_p_value <- compute_p_value(scl_common)

# Permutation test
set.seed(1)
n_permutations <- 1000
permuted_p_values <- replicate(n_permutations, {
  permuted_data <- scl_common
  permuted_data$risk <- sample(scl_common$risk) # Randomly permute risk labels
  compute_p_value(permuted_data)
})

# Compute p-value of permutation test
perm_p_value <- mean(permuted_p_values <= observed_p_value)


# Plotting the KM curve
fit <- survfit(Surv(scl_common$time, scl_common$vital.status) ~ risk, data = scl_common)
p1 <- ggsurvplot(
  fit = fit,
  data = scl_common,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(3500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Risk",
  title = "Single Dataset | miRMS",
  legend.labs = c("High risk", "Low risk"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)


# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_d.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_d.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```

# miRNA Overall survival KM plot
```{r miRNA alone overall survival KM plot}
# Original data risk score
# First, let's assume your coefficients for each gene are stored in a vector like this:
coef <- c(-0.0175147427192908, -0.813624034216674, -0.0808400629378394, -0.175783984675757, 0.59820613021554)

# And your data frame `data` has columns named after the genes
genes <- c("znf460", "tfrc", "fam83f", "samd12", "grin2b")

scl_common$risk_score <- rowSums(sapply(seq_along(genes), function(i) scl_common[, genes[i]] * coef[i]))
median_risk <- median(scl_common$risk_score)
scl_common$risk <- ifelse(scl_common$risk_score > median_risk, "high", "low")

scl_common <- scl_common %>%
  select(patient.id, sex, smoker, vital.status, time, n.stage, m.stage, uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy, risk_score, risk, everything())

# Function to compute p-value from Kaplan-Meier fit
compute_p_value <- function(data, progress_free = FALSE) {
  if (progress_free) {
    fit <- survfit(Surv(data$time2, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time2, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  } else {
    fit <- survfit(Surv(data$time, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  }
}

# Compute observed p-value
observed_p_value <- compute_p_value(scl_common)


# Plotting the KM curve
fit <- survfit(Surv(scl_common$time, scl_common$vital.status) ~ risk, data = scl_common)
p1 <- ggsurvplot(
  fit = fit,
  data = scl_common,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(3500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Risk",
  title = "Single Dataset | miRNA",
  legend.labs = c("High risk", "Low risk"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)


# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_e.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_e.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```

# miRNA Progress free survival KM plot
```{r miRNA alone progress free survival KM plot}
# Original data risk score
# First, let's assume your coefficients for each gene are stored in a vector like this:
coef <- c(-0.0175147427192908, -0.813624034216674, -0.0808400629378394, -0.175783984675757, 0.59820613021554)

# And your data frame `data` has columns named after the genes
genes <- c("znf460", "tfrc", "fam83f", "samd12", "grin2b")

scl_common$risk_score <- rowSums(sapply(seq_along(genes), function(i) scl_common[, genes[i]] * coef[i]))
median_risk <- median(scl_common$risk_score)
scl_common$risk <- ifelse(scl_common$risk_score > median_risk, "high", "low")

scl_common <- scl_common %>%
  select(patient.id, sex, smoker, vital.status, time, time2, n.stage, m.stage, uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy, risk_score, risk, everything())

# Function to compute p-value from Kaplan-Meier fit
compute_p_value <- function(data, progress_free = FALSE) {
  if (progress_free) {
    fit <- survfit(Surv(data$time2, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time2, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  } else {
    fit <- survfit(Surv(data$time, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  }
}

# Compute observed p-value
observed_p_value <- compute_p_value(scl_common, progress_free = TRUE)


# Plotting the KM curve
fit <- survfit(Surv(scl_common$time2, scl_common$vital.status) ~ risk, data = scl_common)
p1 <- ggsurvplot(
  fit = fit,
  data = scl_common,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(2500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Risk",
  title = "Single Dataset | miRNA | Progress Free",
  legend.labs = c("High risk", "Low risk"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)


# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_f.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_f.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```

# All 3 metrics Progress free survival KM plot
```{r miRNA alone progress free survival KM plot}
# Original data risk score
coef <- c(-0.75737985824054, -0.0706471525401676, -0.16554139965723, 0.305795111401098, -0.000374799303479439, -0.027261204056091)

# And your data frame `data` has columns named after the genes
genes <- c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13")


scl_common$risk_score <- rowSums(sapply(seq_along(genes), function(i) scl_common[, genes[i]] * coef[i]))
median_risk <- median(scl_common$risk_score)
scl_common$risk <- ifelse(scl_common$risk_score > median_risk, "high", "low")

scl_common <- scl_common %>%
  select(
    patient.id, sex, smoker, vital.status, time, time2, n.stage, m.stage,
    uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy,
    risk_score, risk, everything()
  )

# Function to compute p-value from Kaplan-Meier fit
compute_p_value <- function(data, progress_free = FALSE) {
  if (progress_free) {
    fit <- survfit(Surv(data$time2, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time2, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  } else {
    fit <- survfit(Surv(data$time, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  }
}

# Compute observed p-value
observed_p_value <- compute_p_value(scl_common, progress_free = TRUE)


# Plotting the KM curve
fit <- survfit(Surv(scl_common$time2, scl_common$vital.status) ~ risk, data = scl_common)
p1 <- ggsurvplot(
  fit = fit,
  data = scl_common,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(2500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Risk",
  title = "Single Dataset | miRMS | Progress Free",
  legend.labs = c("High risk", "Low risk"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)


# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_g.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_g.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")


# Permuted p-value
# Create a data frame with the p-values
df <- data.frame(p_value = permuted_p_values)

# Plot the histogram
hist <- ggplot(df, aes(x = p_value)) +
  geom_histogram(binwidth = 0.05, fill = "steelblue", color = "black") +
  labs(x = "P-value", y = "Frequency") +
  ggtitle("1,000 Permutations | miRMS | Progress Free") +
  geom_vline(xintercept = observed_p_value, linetype = "solid", color = "red", linewidth = 1.25) +
  theme(
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    axis.title = element_text(size = 20, face = "bold"),
    axis.text = element_text(size = 18),
    axis.line = element_line(color = "black", size = 1.25, lineend = "round"),
    axis.ticks = element_line(color = "black", linewidth = 1.25),
    panel.background = element_blank(),
    panel.grid.major.y = element_line(color = "black", linewidth = 1.25),
    panel.grid.major.x = element_blank()
  ) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0))

hist


# Saving as PNG
ggsave(hist, path = "Figures/panels/", filename = "figure_a_panel_h.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(hist, path = "Figures/panels/", filename = "figure_a_panel_h.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```

# miRNA only Progress free survival permutations
```{r miRNA alone progress free survival KM plot}
coef <- c(-0.0175147427192908, -0.813624034216674, -0.0808400629378394, -0.175783984675757, 0.59820613021554)

# And your data frame `data` has columns named after the genes
genes <- c("znf460", "tfrc", "fam83f", "samd12", "grin2b")


scl_common$risk_score <- rowSums(sapply(seq_along(genes), function(i) scl_common[, genes[i]] * coef[i]))
median_risk <- median(scl_common$risk_score)
scl_common$risk <- ifelse(scl_common$risk_score > median_risk, "high", "low")

scl_common <- scl_common %>%
  select(
    patient.id, sex, smoker, vital.status, time, time2, n.stage, m.stage,
    uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy,
    risk_score, risk, everything()
  )

# Function to compute p-value from Kaplan-Meier fit
compute_p_value <- function(data, progress_free = FALSE) {
  if (progress_free) {
    fit <- survfit(Surv(data$time2, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time2, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  } else {
    fit <- survfit(Surv(data$time, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  }
}

# Compute observed p-value
observed_p_value <- compute_p_value(scl_common, progress_free = TRUE)


# Permuted p-value
# Create a data frame with the p-values
df <- data.frame(p_value = permuted_p_values)

# Plot the histogram
hist <- ggplot(df, aes(x = p_value)) +
  geom_histogram(binwidth = 0.05, fill = "steelblue", color = "black") +
  labs(x = "P-value", y = "Frequency") +
  ggtitle("1,000 Permutations | miRNA | Progress Free") +
  geom_vline(xintercept = observed_p_value, linetype = "solid", color = "red", linewidth = 1.25) +
  theme(
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    axis.title = element_text(size = 20, face = "bold"),
    axis.text = element_text(size = 18),
    axis.line = element_line(color = "black", size = 1.25, lineend = "round"),
    axis.ticks = element_line(color = "black", linewidth = 1.25),
    panel.background = element_blank(),
    panel.grid.major.y = element_line(color = "black", linewidth = 1.25),
    panel.grid.major.x = element_blank()
  ) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0))

hist


# Saving as PNG
ggsave(hist, path = "Figures/panels/", filename = "figure_a_panel_i.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(hist, path = "Figures/panels/", filename = "figure_a_panel_i.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```


# SCLCCellMinerCDB Datasets
```{r sclccellminercdb cell lines}
# Using SCLCCellMinerCDB Cell lines to attempt to do that
cell_lines <- read.csv("Data/data_SCLC NCI-DTP_exp.txt", sep = "\t")
cell_lines <- cell_lines %>%
  select(
    -TranscriptClusterID, -UNIT_ID, -GeneName, -GeneAccession, -EntrezID,
    -Chromosome, -Cytoband, -Start, -Stop, -Strand, -CrossHybridization,
    -ProbesetType
  )

rownames(cell_lines) <- cell_lines$GeneSymbol
cell_lines <- cell_lines %>%
  select(-GeneSymbol, -COR.L279)


# Generating synthetic survival data

# Step 2: Analyze reference dataset
# Fit a survival model using survfit (Kaplan-Meier estimator or other methods)
surv_model <- survfit(Surv(time, vital.status) ~ 1, data = scl_common)

# Extract survival probabilities and time points from the survival model
surv_prob <- surv_model$surv
time_points <- surv_model$time


# Step 4: Simulate survival times
n <- 67 # Number of individuals to simulate
simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

# Step 5: Simulate censoring status
# Assuming 18% survival rate after 5 years based on American Cancer Society for regional staging of
# cancer. We are using regional survival rate because the majority of patients in our dataset have regional characteristics. (https://www.cancer.org/cancer/types/lung-cancer/detection-diagnosis-staging/survival-rates.html)

# Survival rate at 5 years
survival_rate <- 0.18

# Calculate the number of censored observations
n_censored <- round(survival_rate * n)

# Generate censoring status
censoring_status <- rep(1, n) # Initialize with 1 (event)
censoring_status[sample(1:n, n_censored)] <- 0 # Assign 0 to randomly selected censored observations

# Print the proportion of censored observations
prop_censored <- sum(censoring_status == 0) / n
cat("Proportion of censored observations:", prop_censored)

# Step 6: Create a simulated dataset
simulated_data <- data.frame(time = simulated_times, status = censoring_status)


synthetic_expression <- synthetic_expression %>%
  as.data.frame(synthetic_expression) %>%
  mutate(time = simulated_data$time) %>%
  mutate(status = simulated_data$status)

rownames(synthetic_expression) <- colnames(cell_lines)
```

```{r creating lots of synthetic survival datasets}
simulate_survival_data <- function(reference_data, n, survival_rate) {
  # Step 2: Fit a survival model using survfit
  surv_model <- survfit(Surv(time, vital.status) ~ 1, data = reference_data)
  surv_prob <- surv_model$surv
  time_points <- surv_model$time

  # Step 4: Simulate survival times
  simulated_times <- sample(time_points, size = n, replace = TRUE, prob = surv_prob)

  # Step 5: Simulate censoring status
  n_censored <- round(survival_rate * n)
  censoring_status <- rep(1, n)
  censoring_status[sample(1:n, n_censored)] <- 0

  # Step 6: Create a simulated dataset
  simulated_data <- data.frame(time = simulated_times, status = censoring_status)

  return(simulated_data)
}

cell_lines <- read.csv("Data/data_SCLC NCI-DTP_exp.txt", sep = "\t")
cell_lines <- cell_lines %>%
  select(
    -TranscriptClusterID, -UNIT_ID, -GeneName, -GeneAccession,
    -EntrezID, -Chromosome, -Cytoband, -Start, -Stop, -Strand,
    -CrossHybridization, -ProbesetType
  )
rownames(cell_lines) <- cell_lines$GeneSymbol
cell_lines <- cell_lines %>% select(-GeneSymbol, -COR.L279)


# Now using the function
reference_data <- scl_common # Replace with your reference dataset
n <- 67
survival_rate <- 0.18

simulated_data <- simulate_survival_data(reference_data, n, survival_rate)

# Creating several simulated datasets
n_datasets <- 1000
simulated_datasets <- list()

for (i in 1:n_datasets) {
  simulated_datasets[[i]] <- simulate_survival_data(reference_data, n, survival_rate)
}



# Making synthetic gene profiles
generate_synthetic_expression <- function(data, sample = TRUE) {
  num_cell_lines <- ncol(data)
  num_genes <- nrow(data)
  
  mean_expression <- apply(data, 1, mean)
  sd_expression <- apply(data, 1, sd)
  
  if (sample) {
    # Generate random variation for mean and standard deviation up to 20%
    mean_variation <- runif(num_genes, min = -0.2, max = 0.2)
    sd_variation <- runif(num_genes, min = -0.2, max = 0.2)
    
    mean_expression <- mean_expression + mean_expression * mean_variation
    sd_expression <- sd_expression + sd_expression * sd_variation
  }
  
  synthetic_expression <- matrix(
    rnorm(num_cell_lines * num_genes, mean_expression, sd_expression),
    nrow = num_genes,
    ncol = num_cell_lines,
    dimnames = list(rownames(data), colnames(data))
  )
  
  synthetic_expression <- t(synthetic_expression)
  colnames(synthetic_expression) <- tolower(colnames(synthetic_expression))
  
  return(synthetic_expression)
}

simulated_gene_datasets <- list()

for (i in 1:n_datasets){
  simulated_gene_datasets[[i]] <- generate_synthetic_expression(cell_lines, sample = TRUE)
}

finished_datasets <- list()

for (i in 1:n_datasets){
  current_gene_dataset <- simulated_gene_datasets[[i]]
  current_survival_dataset <- simulated_datasets[[i]]
  finished_dataset <- current_gene_dataset %>%
  as.data.frame(current_gene_dataset) %>%
  mutate(time = current_survival_dataset$time) %>%
  mutate(status = current_survival_dataset$status)
  rownames(finished_dataset) <- colnames(cell_lines)
  finished_datasets[[i]] <- finished_dataset
}

# Combining the synthetic gene expression and survival times together
synthetic_expression <- synthetic_expression %>%
  as.data.frame(synthetic_expression) %>%
  mutate(time = simulated_data$time) %>%
  mutate(status = simulated_data$status)

rownames(synthetic_expression) <- colnames(cell_lines)
```
