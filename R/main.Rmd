---
title: "SCLC Analysis"
author: "Andrew Willems & Tian Hong"
date: "2023-04-05"
output: html_document
---

```{r setup, include=FALSE}
# This sets the global chunk options for knitr to display the R code.
knitr::opts_chunk$set(
  echo = TRUE
)

# This sets the root directory for knitr to the project directory.
knitr::opts_knit$set(root.dir = "~/Documents/Work/Phd_program/hong_lab/Projects/sclc/")
```

## SCLC Analysis

# Loading needed packages
```{r load needed packages}
# cowplot: for making publication-ready plots in R
# data.table: for efficient data manipulation and manipulation of large datasets
# DESeq2: a single-cell differentially-expressed (DE) method
# DEsingle: a single-cell differentially-expressed (DE) method
# devtools: for developing R packages and managing dependencies
# doParallel: for parallel computing
# dunn.test: for Dunn's Test of Multiple Comparisons Using Rank Sums
# edgeR: a single-cell differentially-expressed (DE) method
# GGally: for making parallel coordinate plots
# forestplot: for visualizing Cox model coefficients
# ggplot2: for data visualization and making high-quality, customizable plots
# glmnet: for fitting generalized linear models via penalized maximum likelihood
# hoardeR: for caching data to disk and improving the speed of data access
# igraph: for network analysis and visualization
# Matrix: for efficient manipulation and calculation with dense and sparse matrices
# monocle3: for single-cell RNA-seq analysis and visualization
# parallel: for running parallel computations in R
# phateR: for visualizing high-dimensional data in a 2D plot
# pwr: for power analysis calculations
# reticulate: for running Python code in R and vice versa
# retry: for allowing us to repeatedly restart code due to timeouts or errors
# randomForestSRC: for Random Forest model
# Rmagic: for running R code in Jupyter notebooks
# scDD: Another method for doing DE of genes
# SingleCellExperiment: For building special data objects used by many single-cell data analysis tools
# styler: for consistent code formatting and styling
# survival: for survival analysis and modeling
# survivalmodels: for deepSurv model
# survminer: for visualization of survival analysis results and data
# svglite: for creating vector graphics in R
# switchde: for differential expression analysis of RNA-seq data using a Bayesian framework
# tidyverse: for data manipulation, visualization, and analysis using a consistent set of tools and syntax
# viridis: for creating color palettes for data visualization that are perceptually uniform and easy to interpret
# zinbwave: for DESeq2 pre-processing

pacman::p_load(
caret, cowplot, coxed, data.table, DESeq2, DEsingle, devtools, doParallel, dunn.test, easystats, edgeR, foreach, forestplot, ggforce, GGally, ggplot2, glmnet, glue, gridExtra, hoardeR, igraph, janitor, Matrix, moments, monocle3, parallel, phateR, progress, pwr, reticulate, retry, randomForestSRC, Rmagic, scDD, SingleCellExperiment, styler, survival, survminer, survsim, survivalmodels, svglite, switchde, tidyverse, viridis, zinbwave
)
```

# Setting up Conda environment that is needed for MAGIC
```{r miniconda setup for MAGIC}
# Loading conda environment 'r-reticulate' for MAGIC package
use_condaenv("/Users/andrewwillems/Library/r-miniconda-arm64/envs/r-reticulate")
```

# Sourcing external R files that contain needed functions
```{r sourcing needed functions}
# This code sources several R scripts that contain functions used for analyzing miRNA expression data in small cell lung cancer (SCLC).
# The 'cox_model.R' script contains a function for performing a Cox proportional hazards model on the data.
# The 'km_plotter.R' script contains a function for creating a Kaplan-Meier plot to visualize survival data.
# The 'lung_mirna_calculator.R' script contains functions for preprocessing and normalizing the miRNA expression data.
# The 'risk_score_calculator.R' script contains a function for calculating a risk score for each patient based on the results of the Cox model.
# The 'main.Rmd' markdown notebook contains all the code for the SCLC analysis for the paper.
# This code also sources 'cell_dataset_builder.R', which contains functions for building a dataset from processed scRNA-seq expression data.

invisible(lapply(list.files("Code", pattern = "\\.R$", full.names = TRUE), source))
```

# Loading bulk SCLC data from University of Cologne that contains survival information
```{r functions}
# Link to paper: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4861069/
# Link to data: https://www.cbioportal.org/study/summary?id=sclc_ucologne_2015
# Paper title for data: Comprehensive genomic profiles of small cell lung cancer by George et al.
# Example usage
# survival_data <- process_survival_data(raw_data, "progression_free")

#' Load and process SCLC expression and clinical data
#' @param expr_file Path to expression data file
#' @param clinical_file Path to clinical data file  
#' @param survival_type "overall" or "progression_free"
#' @return Merged expression and clinical data frame
#' @source George et al. PMC4861069
load_sclc_data <- function(expr_file, clinical_file, survival_type = "overall") {
 expr_data <- load_expression_data(expr_file)
 clinical_data <- load_clinical_data(clinical_file, survival_type)
 
 common_patients <- intersect(clinical_data$patient_id, colnames(expr_data))
 expr_processed <- process_expression_data(expr_data, common_patients)
 merge_expression_clinical(expr_processed, clinical_data)
}

#' Load SCLC gene expression data
#' @param file_path Path to expression data file
#' @return Expression data frame
load_expression_data <- function(file_path) {
 data <- read_tsv(file_path)
 data <- data |> select(Hugo_Symbol, starts_with("sclc_ucologne_2015_S"))
 colnames(data) <- sub("^sclc_ucologne_2015_S", "", colnames(data))
 colnames(data) <- str_to_lower(colnames(data)) 
 data
}

# Function to convert our FPKM data to TPM data
fpkm_to_tpm <- function(fpkm_df) {
    # Input validation
    if (!is.data.frame(fpkm_df) && !is.matrix(fpkm_df)) {
        stop("Input must be a data frame or matrix")
    }
    
    if (ncol(fpkm_df) < 2) {
        stop("Input must have at least 2 columns (gene names and one sample)")
    }
    
    # Store gene names
    genes <- fpkm_df[,1]
    
    # Convert remaining columns to numeric matrix
    fpkm_matrix <- tryCatch({
        matrix <- as.matrix(fpkm_df[,-1])
        mode(matrix) <- "numeric"
        if (any(is.na(matrix))) {
            stop("Non-numeric values found in expression data")
        }
        matrix
    }, error = function(e) {
        stop("Failed to convert expression data to numeric matrix: ", e$message)
    })
    
    # Check for negative values
    if (any(fpkm_matrix < 0)) {
        warning("Negative values found in expression data")
    }
    
    # Calculate TPM for columns [2 applies the function the dataframe's columns]
    tpm_matrix <- apply(fpkm_matrix, 2, function(x) {
        sum_x <- sum(x, na.rm = TRUE)
        if (sum_x == 0) {
            warning("Found column with sum = 0")
            return(rep(0, length(x)))
        }
        x / sum_x * 1e6
    })
    
    # Create output data frame
    tpm_df <- data.frame(Gene = genes, tpm_matrix)
    
    # Verify column sums are approximately 1 million
    col_sums <- colSums(tpm_matrix)
    if (any(abs(col_sums - 1e6) > 1)) {
        warning("Not all columns sum to approximately 1 million")
    }
    
    return(tpm_df)
}



# Function to check distributions to see if log2 transformation is needed
check_distribution <- function(data, pseudocount = 1, sample_name = "sample", 
                             save_path = "distribution_plots/", verbose = FALSE) {
  
  pacman::p_load(ggplot2, gridExtra, moments)
  
  # Create directory if it doesn't exist
  dir.create(save_path, showWarnings = FALSE)
  
  # Create statistics
  orig_stats <- c(
    mean = mean(data),
    median = median(data),
    skewness = moments::skewness(data),
    shapiro_p = shapiro.test(sample(data, min(5000, length(data))))$p.value
  )
  
  log_data <- log2(data + pseudocount)
  log_stats <- c(
    mean = mean(log_data),
    median = median(log_data),
    skewness = moments::skewness(log_data),
    shapiro_p = shapiro.test(sample(log_data, min(5000, length(log_data))))$p.value
  )
  
  # Create plots
  p1 <- ggplot(data.frame(x = data), aes(x = x)) +
    geom_histogram(bins = 50) +
    ggtitle(paste0("Original Distribution - ", sample_name)) +
    theme(axis.title = element_text(size = 20, face = "bold"),
          axis.text = element_text(size = 18),
          plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
          panel.background = element_blank(),
          axis.ticks = element_line(colour = "lightgrey"),
          panel.grid.major = element_line(colour = "lightgrey")) +
    scale_y_continuous(expand = c(0,0))+
    scale_x_continuous(expand = c(0,0))+
    xlab("Transcripts per Million (TPM)") +
    ylab("Gene Count")
  
  p2 <- ggplot(data.frame(x = log_data), aes(x = x)) +
    geom_histogram(bins = 50) +
    ggtitle(bquote(bold(Log[2]~"Transformed -"~.(sample_name)))) +
         theme(axis.title = element_text(size = 20, face = "bold"),
               axis.text = element_text(size = 18),
          plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
          panel.background = element_blank(),
          axis.ticks = element_line(colour = "lightgrey"),
          panel.grid.major = element_line(colour = "lightgrey")) +
    scale_y_continuous(expand = c(0,0))+
    scale_x_continuous(expand = c(0,0))+
    xlab("Transcripts per Million (TPM)") +
    ylab("Gene Count")
  
  # Combine plots
  combined_plot <- arrangeGrob(p1, p2, ncol = 2)
  
  # Save plot
  ggsave(
    filename = paste0(save_path, sample_name, "_distribution.png"),
    plot = combined_plot,
    width = 12,
    height = 6
  )
  
  # Print statistics
  if (verbose){
    cat("\nStatistics for",sample_name,":\n")
    cat("\nOriginal Distribution Statistics:\n")
    print(orig_stats)
    cat("\nLog2 Transformed Statistics:\n")
    print(log_stats)
  }
  
  return(list(
    original_stats = orig_stats,
    log_stats = log_stats,
    plot = combined_plot
  ))
}


load_clinical_data <- function(file_path, survival_type = "os") {
 data <- read_tsv(file_path) |>
   slice(5:121) |>
   rename_clinical_columns() |>
   process_clinical_variables(survival_type = survival_type)
}

#' Process clinical variables
#' @param data Clinical data frame
#' @param survival_type "overall" or "progression_free"
#' @return Processed data frame 
process_clinical_variables <- function(data, survival_type) {
 processed_data <- data |>
   filter(smoker != "Never", smoker != "") |>
   mutate(
     smoker = if_else(smoker == "Current", 1, 0),
     vital_status = if_else(vital_status == "1:DECEASED", 1, 0),
     patient_id = gsub("sclc_ucologne_2015_S", "", patient_id),
     survival_months = as.numeric(survival_months),
     survival_months = survival_months * 30,
     progression_free_months = as.numeric(progression_free_months),
     progression_free_months = if_else(progression_free_months == "", NA, 
                                     progression_free_months),
     progression_free_months = progression_free_months * 30,
     smoking_history = gsub("Smoking Pack years:", "", smoking_history),
     age = as.numeric(age),
     tumor_stage = gsub("a", "", tumor_stage),
     tumor_stage = gsub("b", "", tumor_stage),
     tumor_stage = gsub("B", "", tumor_stage)
   ) |>
   filter(survival_months != 0) |>
    rename(overall_survival_days = survival_months,
           progress_free_days = progression_free_months,
           smoking_history_pack_years = smoking_history)
  
  if (survival_type == "pf"){
    processed_data |>
      select(!overall_survival_days)
  }
  else if (survival_type == "os"){
    processed_data |>
      select(!progress_free_days)
  }
}

#' Process expression data frame with genes as rows and patients as columns
#' @param expr_df Expression data frame with genes as rows and patients as columns
#' @return Processed expression data frame with genes as columns and patient_id rows
process_expression_df <- function(expr_df) {
  # Validate input
  if(!is.data.frame(expr_df)) {
    stop("Input must be a data frame")
  }
  
  processed <- expr_df |>
    # Transpose so patients become rows and genes become columns
    t() |>
    as.data.frame() |>
    # Add patient IDs from column names
    rownames_to_column(var = "patient_id") |>
    # Clean patient IDs
    mutate(patient_id = gsub("^X", "", patient_id))
  
  gene_names <- as.character(processed[1,2:ncol(processed)])
  processed <- processed[-c(1),]
  colnames(processed)[2:ncol(processed)] <- gene_names
    
  duplicate_cols <- duplicated(colnames(processed)[-1]) # Exclude patient_id
  processed <- processed[, c(TRUE, !duplicate_cols)] # Keep patient_id and non-duplicates
  
  processed |>
    select(patient_id, everything())
}


#' Rename clinical columns to consistent format
#' @param data Clinical data frame
#' @return Data frame with renamed columns
rename_clinical_columns <- function(data) {
 rename(data,
   patient_id = '#Patient Identifier',
   vital_status = 'Overall Survival Status', 
   survival_months = 'Overall Survival (Months)',
   progression_free_months = 'Progress Free Survival (Months)',
   acquisition_method = 'First Pathologic Diagnosis Biospecimen Acquisition Method Type',
   age = 'Diagnosis Age',
   sex = Sex,
   ethnicity = 'Ethnicity Category',
   tumor_stage = 'UICC Tumor Stage',
   n_stage = 'N Stage',
   m_stage = 'M Stage',
   previous_treatment = 'Previous Treatment',
   radiation = 'Radiation Therapy',
   chemotherapy = 'Chemotherapy',
   neoadj_chemo = 'Neoadjuvant Chemotherapy',
   smoker = 'Smoker',
   smoking_history = 'Smoking History'
 )
}
```

```{r loading and normalizing bulk RNA-seq data}
# Loading bulk RNA-seq data
bulk_rna <- load_expression_data(file_path = "Data/sclc_ucologne_2015/data_mrna_seq_rpkm.txt")

# Convert from FPKM data to TPM 
tryCatch({
    tpm_data <- fpkm_to_tpm(bulk_rna)
    print("Conversion successful")
    print("Column sums (should be close to 1,000,000):")
    print(colSums(tpm_data[,-1]))
    
}, error = function(e) {
    print(paste("Error in conversion:", e$message))
})


# Visualizing the distribution of expression of TPM samples vs. log2(TPM samples)  
for(sample in colnames(tpm_data)[-1]) {
  check_distribution(tpm_data[[sample]], sample_name = sample, save_path = "Outputs/distribution_plots/")
}

# Given that log2 transformation is best we transform the TPM data
log_tpm_data <- log2(tpm_data[-1] + 1)
log_tpm_data <- bind_cols(log_tpm_data, tpm_data |> 
                            select(hugo_symbol)) |>
  relocate(hugo_symbol)

log_tpm_data <- process_expression_df(expr_df = log_tpm_data, remove_duplicates = TRUE)

# Now load clinical data 
clinical_df <- load_clinical_data(file_path = "Data/sclc_ucologne_2015/data_clinical_patient.txt", survival_type = "os")

# Merging them together
common_patients <- intersect(clinical_df$patient_id, log_tpm_data$patient_id)
clinical_df <- filter(clinical_df, patient_id %in% common_patients)
log_tpm_data <- filter(log_tpm_data, patient_id %in% common_patients)
cox_df <- bind_cols(log_tpm_data, clinical_df)
```






# Loading and pre-processing single-cell data
```{r single-cell data loading}
# Read in the gene expression data and filter out columns that start with
# "SCLC_P1" or "SCLC_P14" because they have been treated with cancer
# treatment and we don't want it to affect our analysis
# Data from: https://ngdc.cncb.ac.cn/omix/release/OMIX002441
# Paper title for data: Single-cell transcriptomic profiling reveals the tumor heterogeneity of small-cell lung cancer by Yanhua Tian
sc_df <- fread("Data/OMIX002441-01.csv")
sc_df <- sc_df %>%
  select(-matches("^(SCLC_P1|SCLC_P14)")) %>%
  t() # transpose the data frame to have cells as rows

# Set column names to the first row of the data frame
colnames(sc_df) <- sc_df["V1", ]
sc_df <- sc_df[-1, ] # remove first row, which is now redundant
sc_df <- as.data.frame(sc_df)

# Read in the metadata and filter for tumor samples only
meta_data <- fread("Data/OMIX002441-02.csv")

meta_data <- meta_data %>%
  filter(NT == "tumor")


# Test to try and combine NT column info with patient info
# meta_data <- meta_data %>%
#   mutate(V1 = paste0(V1, "_", NT))

meta_data <- meta_data %>%
  mutate(V1 = paste0(V1))


# Set row names to the first column, which contains the cell IDs
colnames(meta_data)[1] <- "id"

# Join the two dataframes on the "id" column
sc_df$id <- rownames(sc_df)
sc_df <- inner_join(sc_df, meta_data, by = "id")
rownames(sc_df) <- sc_df$id

# rownames(sc_df) <- sc_df$id

sc_df <- sc_df %>% select(
  -id, -patient, -NT, -tissue, -cell_type,
  -nCount_RNA, -nFeature_RNA, -Pre_Map_Reads,
  -Aligned_Reads, -MappingRate
)

# Keep only genes that are expressed in at least 10 cells
keep_cols <- colSums(sc_df > 0) > 10
sc_df <- sc_df[, keep_cols]

sc_rownames <- rownames(sc_df)

# Convert the data frame to integers
sc_df <- apply(sc_df, c(1, 2), as.integer) %>%
  as.data.frame()

rownames(sc_df) <- sc_rownames

# Plot the distribution of library sizes
p1 <- ggplot() +
  geom_histogram(aes(x = rowSums(sc_df)), bins = 50) +
  geom_vline(xintercept = 1000, color = "red") +
  theme(
    panel.background = element_blank(),
    axis.title = element_text(size = 22, face = "bold"),
    axis.text = element_text(size = 20),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.ticks = element_line(linewidth = 1.25),
    axis.ticks.length = unit(0.2, units = "cm"),
    axis.line = element_line(color = "black", linewidth = 1.25),
    plot.subtitle = element_text(hjust = 0.5, size = 22)
  ) +
  ggtitle("Distribution of Library Sizes in scRNA-seq",
    subtitle = "Library size distribution after filtering genes with positive expression in at least 10 cells."
  ) +
  xlab("Library Size") +
  ylab("Count") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0))

# Saving to PNG format
ggsave(
  plot = p1, width = 20, height = 20, units = "in", dpi = 600,
  device = "png", filename = "Outputs/sc_library_distribution_sizes.png", path = "Outputs/"
)

# Saving to SVG format
ggsave(
  plot = p1, width = 20, height = 20, units = "in", dpi = 600,
  device = "svg", filename = "Outputs/sc_library_distribution_sizes.svg", path = "Outputs/"
)

# Keep only cells with a library size between 1000 and 15000
keep_rows <- rowSums(sc_df) > 1000 & rowSums(sc_df) < 15000
sc_df <- sc_df[keep_rows, ]

# Normalize the library size and take the square root of the expression values
sc_df <- library.size.normalize(sc_df)
sc_df <- sqrt(sc_df)

# Removing intermediate files to keep the environment tidy
rm(keep_cols, keep_rows, sc_rownames, p1)
```

# Single-cell denoising with MAGIC
```{r single-cell denoising}
# Convert the sc_df dataframe to a matrix
sc_df_mat <- as.matrix(sc_df)

# Generate a random seed based on system time
# Seed is: 1688576604
# seed <- as.integer(Sys.time())

# Apply the MAGIC (Model-based Analysis of Genome-wide CRISPR/Cas9 Knockout) algorithm to denoise the scRNA-seq data.
# The 'genes' parameter specifies the set of genes to use for MAGIC imputation. Here, 'all_genes' is used to include all genes in the analysis.
# The 'seed' parameter specifies a random seed for reproducibility.
# The 'n.jobs' parameter specifies the number of cores to use for parallelization. Setting it to -1 indicates that all available cores should be used.
sc_denoised <- magic(sc_df_mat, genes = "all_genes", seed = 1688405764, n.jobs = -1)
```


```{r single-cell denoising saved}
# Saving the denoised matrix
saveRDS(sc_denoised, "Outputs/denoised_sc_data.rds")

# Removing intermediate files to keep environment tidy
rm(sc_df_mat)
```

# Pseudotime generation with Monocle3
```{r generating pseudotime from single-cell data}
sc_denoised$result <- sc_denoised$result %>%
  t()

meta_data <- meta_data %>%
  filter(id %in% colnames(sc_denoised$result)) %>%
  column_to_rownames(var = "id")

cds_cell_meta <- meta_data
cds_gene_meta <- data.frame(gene_short_name = rownames(sc_denoised$result))
rownames(cds_gene_meta) <- cds_gene_meta$gene_short_name

emt_genes <- read.csv("Data/emt_genes_tian.txt", sep = "\t")

# Getting common genes between EMT list and our list
common_emt_genes <- intersect(cds_gene_meta$gene_short_name, emt_genes$Gene)
common_emt_genes <- data.frame(gene_short_name = common_emt_genes)
rownames(common_emt_genes) <- common_emt_genes$gene_short_name

cds_output <- cell_dataset_builder(
  gene_expression = "TUBA1A",
  cell_data = sc_denoised$result,
  gene_meta = cds_gene_meta,
  cell_meta = cds_cell_meta,
  pt_root = "Y_7",
  gene_title = "TUBA1A",
  pt_title = "TUBA1A",
  point_size = 2.5,
  norm_flag = "none",
  use_ordering_funct = FALSE,
  cds_filename = "Outputs/cds.rds",
  plot_file = "Outputs/emt_gene_expression.png",
  pt_file = "Outputs/pt_expression.png",
  pt_data_filename = "Outputs/TUBA1A_pseudotime_data.csv"
)

# Bringing the cell expression and pseudotime graphs together into a single plot
combo_plot <- ggarrange(cds_output$Cell_Progression_Graph, cds_output$PT_Graph,
  ncol = 2, nrow = 1, align = "h", labels = c("A", "B"),
  legend = "bottom", font.label = c(size = 18)
)

combo_plot <- combo_plot + ggtitle("SDE Pseudotime Ordering") +
  theme(
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5, size = 9)
  )


# Saving to PNG
ggsave(
  plot = combo_plot, device = "png", dpi = 600, width = 7, height = 5,
  units = "in", filename = "Outputs/sde_foundation_plot.png", bg = "white"
)

# Saving to SVG
ggsave(
  plot = combo_plot, device = "svg", dpi = 600, width = 7, height = 5,
  units = "in", filename = "Outputs/sde_foundation_plot.svg", bg = "white"
)
```

# Calculating and saving SDE metric
```{r sde metric}
sde_genes <- switchde_calculator(sc_denoised$result,
  pseudo_time = cds_output$PT_Data
)

saveRDS(sde_genes, "Outputs/sde_genes.rds")

head(sde_genes)
```

# Finding ideal number of genes for SDE metric
```{r ideal gene number for sde metric}
sde_genes <- readRDS("Outputs/sde_genes_new_random_seed.rds")
gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1
for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 1,
    cox_predictors = sde_genes,
    cox_df = scl_common,
    gene_num = gn,
    n_folds = 10,
    calc_auc = FALSE,
    save_coefs = FALSE,
    verbose = FALSE,
    cat_preds = FALSE,
    my_folds = NULL
  )
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  write.csv(cindex_df, paste0("Outputs/sde/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_new_random_seed.csv"))
  counter <- counter + 1
}


# Now seeing what the best c-index is
all_sde_cindices <- read_files(folder_path = "Outputs/sde/", pattern = "*_new_random_seed.csv")
all_sde_cindices_sub <- all_sde_cindices %>% filter(cindex_active_genes < 8)
max_sde_cindex <- all_sde_cindices_sub[which.max(all_sde_cindices_sub$cindex), ] # 0.7034 with 4 active genes with new random seed
max_sde_cindex <- all_sde_cindices[which.max(all_sde_cindices$cindex), ] # 0.7221 with 7 active genes with initial 123 random seed
```

# Calculating and saving MAD metric
```{r mad metric}
mad_genes <- mad_calculator(sc_denoised$result)
saveRDS(mad_genes, "Outputs/mad_genes.rds")
head(mad_genes)
```

# Finding ideal gene size for MAD metric
```{r ideal gene size for mad}
gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1
for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(my_seed = 1688405764,
                                  my_alpha = 1,
                                  cox_predictors = mad_genes,
                                  cox_df = scl_common,
                                  gene_num = gn,
                                  n_folds = 10, 
                                  calc_auc = FALSE,
                                  save_coefs = FALSE,
                                  verbose = FALSE,
                                  cat_preds = FALSE)
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  write.csv(cindex_df, paste0("Outputs/mad/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_new_random_seed.csv"))
  counter <- counter + 1
}


# Now seeing what the best c-index is
all_mad_cindices <- read_files(folder_path = "Outputs/mad/", pattern = "*.csv")
max_mad_cindex <- all_mad_cindices[which.max(all_mad_cindices$cindex), ] # 0.7718 with 13 active genes
all_mad_cindices_sub <- all_mad_cindices %>% filter(cindex_active_genes == 7 | cindex_active_genes == 8) # 0.7221 with 7 active genes
```

# Getting miRNA targeting info to make miRNA metric
```{r mirna}
# Now sending those miRNAs to TargetScan
mirna_num <- seq(100, 800, 100)
mirna_target_num <- seq(2, 8, 1)
for (m in mirna_num[1:4]) {
  for (t in mirna_target_num[1:7]) {
    mirna_genes <- mirna_calculator(ts_org = "Human", ts_version = "8.0", max_mir_targets = t, cancer_up = TRUE, cancer_type1 = "lung cancer", print_ts_targets = FALSE, status = "up", max_mirnas = m, mirna_genes_mat_name = paste0("Outputs/mirna/mirna_genes_mat_", m, "_mirnas_", t, "_targets_up.csv"), mirna_ranking_name = paste0("Outputs/mirna/mirna_genes_", m, "_mirnas_", t, "_targets_up_.csv"), mirna_ranking_name_rds = paste0("Outputs/mirna/mirna_genes_", m, "_mirnas_", t, "_targets_up_.rds"), mirna_genes_mat_name_rds = paste0("Outputs/mirna/mirna_genes_mat_", m, "_mirnas_", t, "_targets_up.rds"))
  }
}
```

# Determining highest scoring miRNAs from our best miRNA gene signature
```{r best miRNA score from gene signature}
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
mirna_genes_site_score <- read.csv("Outputs/mirna/mirna_genes_mat_200_mirnas_5_targets_up_site_score_output.csv")

tfrc_mirnas <- mirna_genes_site_score %>%
  mutate(gene = tolower(gene)) %>%
  filter(gene == "tfrc")


fam83f_mirnas <- mirna_genes_site_score %>%
  mutate(gene = tolower(gene)) %>%
  filter(gene == "fam83f")


samd12_mirnas <- mirna_genes_site_score %>%
  mutate(gene = tolower(gene)) %>%
  filter(gene == "samd12")


grin2b_mirnas <- mirna_genes_site_score %>%
  mutate(gene = tolower(gene)) %>%
  filter(gene == "grin2b")


dlk1_mirnas <- mirna_genes_site_score %>%
  mutate(gene = tolower(gene)) %>%
  filter(gene == "dlk1")

gng13_mirnas <- mirna_genes_site_score %>%
  mutate(gene = tolower(gene)) %>%
  filter(gene == "gng13")



cox_preds <- data.frame(preds = c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
```

# Finding ideal gene size for miRNA metric
```{r mirna with small number of active genes cindex}
file_list <- list.files(path = "Outputs/mirna/rds", pattern = "*.rds", full.names = TRUE)
file_list <- file_list[!grepl("_mat_", file_list)]

gene_sizes <- seq(2, 8, 1)
cox_outputs <- list()
counter <- 1
for (f in file_list) {
  print(f)
  for (gn in gene_sizes) {
    current_mirna_met <- readRDS(paste0(f))
    current_cox <- cox_model_fitter(my_seed = 1,
                                    my_alpha = 1, 
                                    cox_predictors = current_mirna_met, 
                                    cox_df = scl_common,
                                    gene_num = gn,
                                    n_folds = 10,
                                    calc_auc = FALSE,
                                    save_coefs = FALSE,
                                    verbose = FALSE,
                                    cat_preds = FALSE)
    cox_outputs[[counter]] <- current_cox
    mirna_genes <- str_extract(f, "(?<=mirna_genes_)\\d+")
    mirnas <- str_extract(f, "(?<=mirnas_)\\d+")
    cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/mirna/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_mirnas_", mirnas, "_targets_", mirna_genes, ".csv"))
    counter <- counter + 1
  }
}


# Now seeing what the best c-index is
all_mirna_cindices <- read_files(folder_path = "Outputs/mirna/glmnet/", pattern = "*.csv")
max_mirna_cindex <- all_mirna_cindices[which.max(all_mirna_cindices$cindex), ] #  0.7560 with 5 active genes

```

# Combining the performance levels of the individual metrics together
```{r df of individual metrics}
all_individual_met_df <- bind_rows(max_mirna_cindex, max_sde_cindex, all_mad_cindices_sub[1, ])
all_individual_met_df <- all_individual_met_df %>%
  mutate(metric = c("mirna", "sde", "mad"))
```

# Cancer clinical staging Cox model 
```{r generate a cox model with just the cancer staging to see performance}
scl_patient <- read.csv(
  file = "Data/sclc_ucologne_2015/data_clinical_patient.txt",
  sep = "\t"
)

scl_patient <- scl_patient %>%
  slice(5:121) %>%
  rename(
    Patient.ID = X.Patient.Identifier, Overall.Survival.Status = Overall.Survival.Status,
    Overall.Survival.Months. = Overall.Survival..Months., Smoker = Smoker
  ) %>%
  select(Patient.ID, Sex, Overall.Survival.Status, Overall.Survival.Months., Smoker, Sex, Ethnicity.Category, N.Stage, M.Stage, UICC.Tumor.Stage, Chemotherapy, Neoadjuvant.Chemotherapy) %>%
  filter(Smoker != "Never") %>%
  filter(Smoker != "") %>%
  mutate(
    Smoker = as.factor(Smoker),
    Smoker = if_else(Smoker == "Current", true = 1, false = 0)
  ) %>%
  mutate(Overall.Survival.Status = ifelse(Overall.Survival.Status == "1:DECEASED", 1, 0)) %>%
  rename(
    vital.status = Overall.Survival.Status,
    time = Overall.Survival.Months.
  ) %>%
  mutate(Patient.ID = gsub(
    x = Patient.ID,
    pattern = "sclc_ucologne_2015_S",
    replacement = ""
  )) %>%
  mutate(vital.status_new = as.numeric(vital.status)) %>%
  mutate(time_new = as.numeric(time)) %>%
  select(-vital.status, -time) %>%
  rename(
    vital.status = vital.status_new,
    time = time_new
  ) %>%
  mutate(time = time * 30) %>%
  filter(time != 0) %>%
  rename_all(tolower)

scl_clinical_only <- scl_patient %>%
  mutate(n.stage = ifelse(n.stage == "", NA, n.stage)) %>%
  mutate(m.stage = ifelse(m.stage == "", NA, m.stage)) %>%
  filter(!is.na(ethnicity.category) & !is.na(n.stage) & !is.na(m.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ia", 1, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "I", 1, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ib", 1, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IB", 1, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIa", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IV", 4, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "iib", 2, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "iia", 2, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "iiia", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "iiib", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIa", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIb", 3, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIa", 2, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIb", 2, uicc.tumor.stage)) %>%
  mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "II", 2, uicc.tumor.stage)) %>%
  mutate(n.stage = ifelse(n.stage == "1a", 1, n.stage)) %>%
  mutate(n.stage = ifelse(n.stage == "1b", 1, n.stage)) %>%
  filter(n.stage != "X") %>%
  mutate(m.stage = ifelse(m.stage == "1a", 1, m.stage)) %>%
  mutate(m.stage = ifelse(m.stage == "1b", 1, m.stage)) %>%
  filter(m.stage != "x")

library(caret)

# Set the number of folds
num_folds <- 10

# Initialize an empty vector to store c-index values
c_index_values <- numeric(num_folds)

# Create a list of indices for 10-fold cross-validation
cv_indices <- createFolds(1:nrow(scl_clinical_only), k = num_folds)

# Perform 10-fold cross-validation
for (fold in 1:num_folds) {
  # Split the data into training and testing sets for this fold
  train_indices <- unlist(cv_indices[-fold])
  test_indices <- cv_indices[[fold]]
  
  # Fit the deepSurv model on the training data
  fit <- coxph(formula = Surv(time, vital.status)~ n.stage + m.stage + uicc.tumor.stage, data = scl_clinical_only[train_indices,])
  
  # Predict the risk scores on the test data
  my_newdata <- scl_clinical_only%>%
    select(-time, -vital.status)
  
  my_newdata <- my_newdata %>%
    select(n.stage, m.stage, uicc.tumor.stage)
  my_newdata <- as.data.frame(my_newdata)
  
  p <- predict(fit, type = "risk", newdata = my_newdata[test_indices, ])
  
  # Calculate the concordance index for this fold
  c_index <- rcorr.cens(p, scl_clinical_only[test_indices, "time"])
  
  # Store the c-index value for this fold
  c_index_values[fold] <- unname(c_index[1])
  
  # Print the c-index for this fold to the console
  cat("Fold", fold, "C-Index:", c_index, "\n")
}

# Calculate and print the mean c-index across all folds
mean_c_index <- mean(c_index_values)
cat("Mean C-Index:", mean_c_index, "\n")

clinical_staging_only_df <- data.frame(X = 1, cindex = 0.4829762, cindex_se = NA, cindex_active_genes = 9, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "clinical_staging")
```

# Smoking status
```{r smoking status}
library(caret)

# Set the number of folds
num_folds <- 10

# Initialize an empty vector to store c-index values
c_index_values <- numeric(num_folds)

# Create a list of indices for 10-fold cross-validation
cv_indices <- createFolds(1:nrow(scl_common), k = num_folds)

# Perform 10-fold cross-validation
for (fold in 1:num_folds) {
  # Split the data into training and testing sets for this fold
  train_indices <- unlist(cv_indices[-fold])
  test_indices <- cv_indices[[fold]]
  
  # Fit the deepSurv model on the training data
  fit <- coxph(formula = Surv(time, vital.status)~ smoker, data = scl_common[train_indices,])
  
  # Predict the risk scores on the test data
  my_newdata <- scl_common%>%
    select(-time, -vital.status, smoker)
  my_newdata <- as.data.frame(my_newdata)
  
  p <- predict(fit, type = "risk", newdata = my_newdata[test_indices, ])
  
  # Calculate the concordance index for this fold
  c_index <- rcorr.cens(p, scl_common[test_indices, "time"])
  
  # Store the c-index value for this fold
  c_index_values[fold] <- unname(c_index[1])
  
  # Print the c-index for this fold to the console
  cat("Fold", fold, "C-Index:", c_index, "\n")
}

# Calculate and print the mean c-index across all folds
mean_c_index <- mean(c_index_values)
cat("Mean C-Index:", mean_c_index, "\n")

smoker_only_df <- data.frame(X = 1, cindex = 0.5045635 , cindex_se = NA, cindex_active_genes = NA, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "smoker")
```



# Random gene Cox performance
```{r random gene selection}
scl_common <- scl_common %>%
  select(
    -patient.id, -sex, -smoker, -vital.status, -time, -n.stage, -m.stage,
    -uicc.tumor.stage, -chemotherapy, -neoadjuvant.chemotherapy
  )

# Function to randomly sample genes from the dataset
sample_genes <- function(df, n_genes, n_samples = 1000) {
  gene_names <- colnames(df)
  n_genes <- min(n_genes, length(gene_names))
  samples <- lapply(1:n_samples, function(x) {
    df %>%
      select(sample(gene_names, n_genes, replace = FALSE)) %>%
      rename_all(tolower)
  })
  return(samples)
}


set.seed(1688405764)
sampled_genes <- sample_genes(df = scl_common, n_genes = 7, n_samples = 1000)

# Re-loading the scl file so that we can include the meta data
scl_patient <- read.csv(
  file = "Data/sclc_ucologne_2015/data_clinical_patient.txt",
  sep = "\t"
)

scl_patient <- scl_patient %>%
  slice(5:121) %>%
  rename(
    Patient.ID = X.Patient.Identifier, Overall.Survival.Status = Overall.Survival.Status,
    Overall.Survival.Months. = Overall.Survival..Months., Smoker = Smoker
  ) %>%
  select(Patient.ID, Sex, Overall.Survival.Status, Overall.Survival.Months., Smoker, Sex) %>%
  filter(Smoker != "Never") %>%
  filter(Smoker != "") %>%
  mutate(
    Smoker = as.factor(Smoker),
    Smoker = if_else(Smoker == "Current", true = 1, false = 0)
  ) %>%
  mutate(Overall.Survival.Status = ifelse(Overall.Survival.Status == "1:DECEASED", 1, 0)) %>%
  rename(
    vital.status = Overall.Survival.Status,
    time = Overall.Survival.Months.
  ) %>%
  mutate(Patient.ID = gsub(
    x = Patient.ID,
    pattern = "sclc_ucologne_2015_S",
    replacement = ""
  )) %>%
  mutate(vital.status_new = as.numeric(vital.status)) %>%
  mutate(time_new = as.numeric(time)) %>%
  select(-vital.status, -time) %>%
  rename(
    vital.status = vital.status_new,
    time = time_new
  ) %>%
  mutate(time = time * 30) %>%
  filter(time != 0) %>%
  rename_all(tolower)


# Extract the list of gene symbols
scl_genes <- scl_df$Hugo_Symbol

# Find the list of patients that have data for both gene expression and clinical data
common_patients <- intersect(scl_patient$patient.id, colnames(scl_df))

# Select only the common columns from gene expression data and transpose it
# so that each row corresponds to a patient
scl_common <- scl_df %>%
  select(all_of(common_patients)) %>%
  t() %>%
  as.data.frame()

# Assign the gene symbols as column names
colnames(scl_common) <- scl_genes

# Remove duplicated columns and add patient ID as a column
scl_common <- scl_common %>%
  select(-which(duplicated(names(.)))) %>%
  rownames_to_column(var = "patient.id")

# Join the gene expression data with the clinical data for each patient
scl_common <- left_join(scl_common, scl_patient[, c(
  "vital.status", "time",
  "patient.id"
)],
by = "patient.id"
) %>%
  rename_all(tolower) %>%
  select(
    patient.id, vital.status, time, everything()
  )


counter <- 1
cox_outputs <- list()
for (g in sampled_genes) {
  current_genes <- g
  current_cox <- cox_model_fitter(my_seed = 1,
                                  my_alpha = 1,
                                  cox_predictors = current_genes, 
                                  cox_df = scl_common,
                                  gene_num = 7, n_folds = 10,
                                  calc_auc = FALSE,
                                  save_coefs = FALSE,
                                  verbose = FALSE, 
                                  cat_preds = FALSE)
  cox_outputs[[counter]] <- current_cox

  if (is.null(current_cox)) {
    next
  } else {
    cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/random_genes/glmnet_7_genes_glmnet_index_", cindex_index, "_lambda_", lambda, ".csv"))
    counter <- counter + 1
  }
}


# Combining all files together
all_random_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/random_genes/", pattern = "*.csv")
mean_random_cindices <- mean(all_random_cindices$cindex) # 0.606116
random_genes_only_df <- data.frame(X = 1, cindex = mean_random_cindices, cindex_se = NA, cindex_active_genes = NA, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "random_genes")
all_individual_met_df <- bind_rows(all_individual_met_df, random_genes_only_df)
write.csv(all_individual_met_df, "Outputs/all_individual_metrics_cindex.csv")
```

# MAD + SDE
```{r mad + sde}
sde_genes <- readRDS("Outputs/sde_genes.rds")
mad_genes <- readRDS("Outputs/mad_genes.rds")

# Optimize the weights of the MAD + SDE metrics
mad_sde_optimized <- two_weight_optimizer(
  first.metric = mad_genes,
  second.metric = sde_genes,
  my.start = 0,
  my.finish = 1,
  step.size = 0.1,
  my.filename = paste0("Outputs/Optimization_mad_sde_1_alpha.rds")
)

gene_sizes <- seq(2, 8, 1)
counter <- 1
for (ms in mad_sde_optimized) {
  for (gs in gene_sizes) {
    current_cox <- cox_model_fitter(
      my_seed = 1,
      my_alpha = 1,
      cox_predictors = ms,
      cox_df = scl_common,
      gene_num = gs,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10
    )
    cindex <- current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/mad_sde/cindex_", gs, "_mad_sde_optimized_", counter, ".csv"))
    active_genes_df <- as.data.frame(cbind(current_cox$`Active Genes`, current_cox$`Active Coefficients`))
    colnames(active_genes_df) <- c("gene", "coef")
    write.csv(active_genes_df, paste0("Outputs/glmnet_coefs/mad_sde/cindex_", gs, "_mad_sde_optimized_", counter, "_active_coefs_df.csv"))
    counter <- counter + 1
  }
}

all_mad_sde_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/mad_sde/", pattern = "*.csv")
max_mad_sde_cindices <- all_mad_sde_cindices[which.max(all_mad_sde_cindices$cindex), ] # 0.7201824 with 3 active predictors
```

# miRNA + SDE
```{r mirna + sde}
sde_genes <- readRDS("Outputs/sde_genes.rds")
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
gene_sizes <- seq(2, 8, 1)
counter <- 1

# Optimizing the weights
mirna_sde_optimized <- two_weight_optimizer(
  first.metric = mirna_genes,
  second.metric = sde_genes,
  my.start = 0,
  my.finish = 1,
  step.size = 0.1,
  my.filename = paste0("Outputs/Optimization_mirna_sde_1_alpha.rds")
)

for (ms in mirna_sde_optimized) {
  for (gs in gene_sizes) {
    current_cox <- cox_model_fitter(
      my_seed = 1,
      my_alpha = 1,
      cox_predictors = ms,
      cox_df = scl_common,
      gene_num = gs,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10
    )
    cindex <- current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/mirna_sde/cindex_", gs, "_mirna_sde_optimized_", counter, ".csv"))
    active_genes_df <- as.data.frame(cbind(current_cox$`Active Genes`, current_cox$`Active Coefficients`))
    colnames(active_genes_df) <- c("gene", "coef")
    write.csv(active_genes_df, paste0("Outputs/glmnet_coefs/mirna_sde/cindex_", gs, "_mirna_sde_optimized_", counter, "_active_coefs_df.csv"))
    counter <- counter + 1
  }
}

all_mirna_sde_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/mirna_sde/", pattern = "*.csv")
max_mirna_sde_cindices <- all_mirna_sde_cindices[which.max(all_mirna_sde_cindices$cindex), ] # 0.7560 with 5 active predictors
```

# miRNA + MAD
```{r mad + mirna}
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
mad_genes <- readRDS("Outputs/mad_genes.rds")

# Optimize the weights of the MAD + SDE metrics
mad_mirna_optimized <- two_weight_optimizer(
  first.metric = mad_genes,
  second.metric = mirna_genes,
  my.start = 0,
  my.finish = 1,
  step.size = 0.1,
  my.filename = paste0("Outputs/Optimization_mad_mirna_1_alpha.rds")
)

gene_sizes <- seq(2, 8, 1)
counter <- 1
for (ms in mad_mirna_optimized) {
  for (gs in gene_sizes) {
    current_cox <- cox_model_fitter(
      my_seed = 1,
      my_alpha = 1,
      cox_predictors = ms,
      cox_df = scl_common,
      gene_num = gs,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10
    )
    cindex <- current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/mirna_mad/cindex_", gs, "_mirna_mad_optimized_", counter, ".csv"))
    active_genes_df <- as.data.frame(cbind(current_cox$`Active Genes`, current_cox$`Active Coefficients`))
    colnames(active_genes_df) <- c("gene", "coef")
    write.csv(active_genes_df, paste0("Outputs/glmnet_coefs/mirna_mad/cindex_", gs, "_mirna_mad_optimized_", counter, "_active_coefs_df.csv"))
    counter <- counter + 1
  }
}

all_mirna_mad_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/mirna_mad/", pattern = "*.csv")
max_mirna_mad_cindices <- all_mirna_mad_cindices[which.max(all_mirna_mad_cindices$cindex), ] # 0.7559976 with 5 active predictors
```

# miRNA + MAD + SDE
```{r mirna + mad + sde}
sde_genes <- readRDS("Outputs/sde_genes.rds")
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
mad_genes <- readRDS("Outputs/mad_genes.rds")
gene_sizes <- seq(2, 8, 1)
counter <- 1

# Optimizing the weights
mirna_mad_sde_optimized <- three_weight_optimizer(
  first.metric = mirna_genes,
  second.metric = sde_genes,
  third.metric = mad_genes,
  my.start = 0,
  my.finish = 1,
  step.size = 0.1,
  my.filename = paste0("Outputs/Optimization_mirna_mad_sde_1_alpha.rds")
)

for (ms in mirna_mad_sde_optimized) {
  for (gs in gene_sizes) {
    current_cox <- cox_model_fitter(
      my_seed = 1,
      my_alpha = 1,
      cox_predictors = ms,
      cox_df = scl_common,
      gene_num = gs,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10
    )
    cindex <- current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]
    cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
    lambda <- current_cox$CV$lambda.min
    measure <- "Concordance-index"
    cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
    cindex_index <- current_cox$CV$index["min", ]
    active_genes <- current_cox$`Active Genes`
    active_coefs <- current_cox$`Active Coefficients`
    cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
    cindex_df$active_genes <- paste(active_genes, collapse = ",")
    cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
    write.csv(cindex_df, paste0("Outputs/glmnet_cindices/mirna_mad_sde/cindex_", gs, "_mirna_mad_sde_optimized_", counter, ".csv"))
    active_genes_df <- as.data.frame(cbind(current_cox$`Active Genes`, current_cox$`Active Coefficients`))
    colnames(active_genes_df) <- c("gene", "coef")
    write.csv(active_genes_df, paste0("Outputs/glmnet_coefs/mirna_mad_sde/cindex_", gs, "_mirna_mad_sde_optimized_", counter, "_active_coefs_df.csv"))
    counter <- counter + 1
  }
}

all_mirna_mad_sde_cindices <- read_files(folder_path = "Outputs/glmnet_cindices/mirna_mad_sde/", pattern = "*.csv")
max_mirna_mad_sde_cindices <- all_mirna_mad_sde_cindices[which.max(all_mirna_mad_sde_cindices$cindex), ] # 0.76910 with 6 active predictors
```

# Attempting to generate several synthetic datasets based on our original survival distribution
```{r 1000 reps for bootstrap for comparison}
set.seed(1688405764)
# Assume your original dataset is named `data` and it has a column named `vital.status`
# Get the distribution of the vital status column
vital_status_dist <- table(scl_common$vital.status)

# Create a function to generate bootstrap samples
bootstrap_func <- function(data) {
  # Randomly sample with replacement from the original data
  bootstrap_sample <- sample_n(data, nrow(data), replace = TRUE)
  return(bootstrap_sample)
}


# Generate 1000 datasets using bootstrap sampling that match the distribution of the vital status column
bootstrap_datasets <- replicate(1000,
  {
    # Create an empty data frame to store the bootstrap samples
    bootstrap_data <- data.frame()

    # Loop through each unique value in the vital status column and generate a bootstrap sample for each value
    for (i in seq_along(vital_status_dist)) {
      # Subset the original data to only include rows with the current value of the vital status column
      current_data <- scl_common %>% filter(vital.status == names(vital_status_dist)[i])

      # Calculate the number of rows needed for the bootstrap sample
      n_rows <- vital_status_dist[i]

      # Generate a bootstrap sample for the current value of the vital status column
      bootstrap_sample <- bootstrap_func(current_data)

      # Add the bootstrap sample to the empty data frame
      bootstrap_data <- rbind(bootstrap_data, bootstrap_sample[1:n_rows, ])
    }

    return(bootstrap_data)
  },
  simplify = FALSE
)
```

# Now taking our 1000 datasets and testing the 4 predictors we have identified and seeing how they perform after removing GRIN2B
```{r for 1000 simulations of 10 fold cv on mirna + mad + sde for 4}
cox_outputs <- list()
counter <- 1
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# Extract the mean cross-validated performance for each fold at the minimum lambda value
# Foldids to reproduce 10-fold CV splits is c(3 2  5  5  3  2  4 7  2  8  2 10  7  9  1  1  7  9  4  6 10  6  1  7  8  3  2  3  7  9  5  5  1  9  4 10  9 10  5  1  8 10  4  3  6  1  3  8  6  8  2  5  9  2  3  1 10  4  2  4  7  7  4  6  8  6  5 10  9  8  1  6)
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# Calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7378887
```

# MAD on 1000 simulated datasets
```{r now doing the same with MAD to ensure fair comparison}
mad_genes <- readRDS("Outputs/mad_genes_new_random_seed.rds")
cox_outputs <- list()
counter <- 1
cox_preds <- mad_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 6,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.692528
```

# SDE on 1000 simulated datasets
```{r now doing the same with SDE to ensure fair comparison}
sde_genes <- readRDS("Outputs/sde_genes_new_random_seed.rds")
cox_outputs <- list()
counter <- 1
cox_preds <- sde_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 7,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7373972
```

# miRNA on 1000 simulated datasets
```{r now doing the same with miRNA to ensure fair comparison}
cox_outputs <- list()
counter <- 1
mirna_genes <- readRDS("Outputs/mirna/rds/mirna_genes_200_mirnas_5_targets_up_.rds")
cox_preds <- mirna_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE, 
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    my_folds = NULL,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7497211
```

# miRNA + SDE on 1000 simulated datasets
```{r mirna + sde 1000}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("znf460", "tfrc", "fam83f", "samd12", "grin2b"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6907635 with the 5 active predictors from miRNA + SDE. 0.6973343 with more random seed. Foldid: 3  2  5  5  3  2  4  7  2  8  2 10  7  9  1  1  7  9  4  6 10  6  1  7  8  3  2  3  7  9  5  5  1  9  4 10  9 10  5  1  8 10  4  3  6  1  3  8  6  8  2  5  9  2  3  1 10  4  2  4  7  7  4  6  8  6  5 10  9  8  1  6
```

# miRNA + MAD on 1000 simulated datasets
```{r mirna + mad 1000}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("znf460", "tfrc", "fam83f", "samd12", "grin2b"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 5,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6907635 with the 5 active predictors from miRNA + MAD. 0.6973343 for
# better random number. Foldid: 3  2  5  5  3  2  4  7  2  8  2 10  7  9  1  1  7  9  4  6 10  6  1  7  8  3  2  3  7  9  5  5  1  9  4 10  9 10  5  1  8 10  4  3  6  1  3  8  6  8  2  5  9  2  3  1 10  4  2  4  7  7  4  6  8  6  5 10  9  8  1  6
```

# MAD + SDE on 1000 simulated datasets
```{r mad + sde 1000}
cox_outputs <- list()
cox_preds <- data.frame(preds = c("dlk1", "arl6ip1", "ube2c"))
rownames(cox_preds) <- cox_preds$preds
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 3,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6958149 with the 3 active predictors from MAD + SDE. 0.6965589 for
# . better random seed. Foldid: 3  2  5  5  3  2  4  7  2  8  2 10  7  9  1  1  7  9  4  6 10  6  1  7  8  3  2  3  7  9  5  5  1  9  4 10  9 10  5  1  8 10  4  3  6  1  3  8  6  8  2  5  9  2  3  1 10  4  2  4  7  7  4  6  8  6  5 10  9  8  1  6
```

# Clinical Staging on 1000 simulated datasets
```{r clinical staging 1000}
# Function to efficiently simplify tumor staging
modify_dataframe <- function(df) {
  df <- df %>%
    mutate(n.stage = factor(gsub("[A-Za-z]", "", n.stage))) %>%
    mutate(m.stage = factor(gsub("[A-Za-z]", "", m.stage))) %>%
    mutate(n.stage = ifelse(n.stage == "", NA, n.stage)) %>%
    mutate(m.stage = ifelse(m.stage == "", NA, m.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "I", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ia", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ib", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ic", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IA", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IB", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IC", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "II", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIa", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIb", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIc", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIA", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIB", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIC", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "III", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIa", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIb", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIc", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIA", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIB", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIC", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IV", 4, uicc.tumor.stage)) %>%
    filter(!is.na(n.stage)) %>%
    filter(!is.na(m.stage)) %>%
    filter(!is.na(uicc.tumor.stage))

  return(df)
}

cox_outputs <- list()
counter <- 1
cox_preds <- c("n.stage", "m.stage", "uicc.tumor.stage")
bootstrap_datasets_clinical <- bootstrap_datasets
bootstrap_datasets_clinical <- lapply(bootstrap_datasets_clinical, modify_dataframe)

for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 3,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6882093 
```

# Smoking Status on 1000 synthetic datasets
```{r smoking on 1000 synthetic datasets}
library(caret)

# Set the number of folds
num_folds <- 10
cox_outputs <- list()

for (d in 1:length(bootstrap_datasets)){
  # Initialize an empty vector to store c-index values
  c_index_values <- numeric(num_folds)
  
  current_dataset <- bootstrap_datasets[[d]]
  
  # Create a list of indices for 10-fold cross-validation
  cv_indices <- createFolds(1:nrow(current_dataset), k = num_folds)
  
  # Perform 10-fold cross-validation
  for (fold in 1:num_folds) {
    # Split the data into training and testing sets for this fold
    train_indices <- unlist(cv_indices[-fold])
    test_indices <- cv_indices[[fold]]
    
    # Fit the cox model on the training data
    fit <- coxph(formula = Surv(time, vital.status)~ smoker, data = current_dataset[train_indices,])
    
    # Predict the risk scores on the test data
    my_newdata <- current_dataset %>%
      select(-time, -vital.status, smoker)
    my_newdata <- as.data.frame(my_newdata)
    
    p <- predict(fit, type = "risk", newdata = my_newdata[test_indices, ])
    
    # Calculate the concordance index for this fold
    c_index <- rcorr.cens(p, current_dataset[test_indices, "time"])
    
    # Store the c-index value for this fold
    c_index_values[fold] <- unname(c_index[1])
  
  }
  
  # Calculate and print the mean c-index across all folds
  mean_c_index <- mean(c_index_values)
  cox_outputs[[d]] <- mean_c_index
}

cv_performance <- unlist(cox_outputs)
mean(cv_performance) # 0.4913271
```


# Figure 1A Plot
```{r combining all overall survival cindicies together for first panel}
all_individual_met_df <- read.csv("Outputs/all_individual_metrics_cindex.csv")
mirna_mad_only_df <- data.frame(X = 1, cindex = 0.7559976, cindex_se = NA, cindex_active_genes = 5, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "mirna_mad")
all_individual_met_df <- bind_rows(all_individual_met_df, mirna_mad_only_df)
mirna_mad_sde_only_df <- data.frame(X = 1, cindex = 0.76910, se = NA, cindex_active_genes = 6, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "mirna_mad_sde")
all_individual_met_df <- bind_rows(all_individual_met_df, mirna_mad_sde_only_df)
mirna_sde_only_df <- data.frame(X = 1, cindex = 0.7560, cindex_se = NA, cindex_active_genes = 5, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "mirna_sde")
all_individual_met_df <- bind_rows(all_individual_met_df, mirna_sde_only_df)
mad_sde_only_df <- data.frame(X = 1, cindex = 0.7201824, cindex_se = NA, cindex_active_genes = 3, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "mad_sde")
all_individual_met_df <- bind_rows(all_individual_met_df, mad_sde_only_df)

# Smoker status for presentation
smoker_only_df <- data.frame(X = 1, cindex = 0.5045635, cindex_se = 0.0354, cindex_active_genes = NA, lambda = NA, measure = "Concordance-index", cindex_index = NA, metric = "smoker")

all_individual_met_df <- bind_rows(all_individual_met_df, smoker_only_df)

#write.csv(all_individual_met_df, "Outputs/all_individual_metrics_cindex_with_smoker_status.csv")
# write.csv(all_individual_met_df, "Outputs/all_individual_metrics_cindex.csv")

all_individual_metrics_cindex <- read.csv("Outputs/all_individual_metrics_cindex.csv")

# Starting plotting code
all_individual_metrics_cindex$metric <- factor(all_individual_metrics_cindex$metric, levels = c("mad", "sde", "mirna", "clinical_staging", "smoker", "random_genes", "mad_sde", "mirna_mad", "mirna_sde", "mirna_mad_sde"), labels = c("M", "S", "miR", "CS", "SM", "RG", "MS", "miRM", "miRS", "miRMS"))

all_individual_metrics_cindex <- all_individual_metrics_cindex %>%
  select(cindex, metric) %>%
  mutate(cindex = round(cindex, digits = 4))


p1 <- ggplot(data = all_individual_metrics_cindex, aes(x = metric, y = cindex, fill = metric, color = metric)) +
  geom_col(width = 0.4) +
  geom_text(aes(label = round(cindex, 2), y = cindex + 0.01),
    size = 4,
    position = position_dodge(width = 0.4), color = "black"
  ) +
  theme(
    panel.background = element_blank(),
    axis.title = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 14),
    axis.text.x = element_text(angle = 45, vjust = 0.7),
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.ticks.length = unit(0.2, units = "cm"),
    legend.position = "none",
    axis.ticks = element_line(color = "black", linewidth = 0.75)
  ) +
  xlab("Metric") +
  ylab("Mean 10-fold CV C-index") +
  ggtitle("Single Dataset | Overall Survival") +
  scale_y_continuous(expand = c(0, 0))

p1 <- p1 + coord_cartesian(ylim = c(0.4, 0.8)) +
  scale_fill_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef")) +
  scale_color_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef"))
p1

# Save to PNG
ggsave(p1, device = "png", filename = "figure_a_panel_a.png", path = "~/Desktop/", width = 8, height = 8, dpi = 600, units = "in")

# Save to SVG
ggsave(p1, device = "svg", filename = "figure_a_panel_a.svg", path = "~/Desktop/", width = 8, height = 8, dpi = 600, units = "in")
```

# Figure 1A plot that includes smoking status
```{r figure 1a with smoking status}
all_individual_metrics_cindex <- read.csv("Outputs/all_individual_metrics_cindex_with_smoker_status.csv")

# Starting plotting code
all_individual_metrics_cindex$metric <- factor(all_individual_metrics_cindex$metric, levels = c("mad", "sde", "mirna", "clinical_staging", "smoker", "random_genes", "mad_sde", "mirna_mad", "mirna_sde", "mirna_mad_sde"), labels = c("M", "S", "miR", "CS", "SM", "RG", "MS", "miRM", "miRS", "miRMS"))

all_individual_metrics_cindex <- all_individual_metrics_cindex %>%
  select(cindex, metric) %>%
  mutate(cindex = round(cindex, digits = 2))


p1 <- ggplot(data = all_individual_metrics_cindex, aes(x = metric, y = cindex, fill = metric, color = metric)) +
  geom_col(width = 0.4) +
  geom_text(aes(label = cindex, y = cindex + 0.01),
    size = 4,
    position = position_dodge(width = 0.4), color = "black"
  ) +
  theme(
    panel.background = element_blank(),
    axis.title = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 14),
    axis.text.x = element_text(angle = 45, vjust = 0.7),
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.ticks.length = unit(0.2, units = "cm"),
    legend.position = "none",
    axis.ticks = element_line(color = "black", linewidth = 0.75)
  ) +
  xlab("Metric") +
  ylab("Mean 10-fold CV C-index") +
  ggtitle("Single Dataset | Overall Survival") +
  scale_y_continuous(expand = c(0, 0))


p1 <- p1 + coord_cartesian(ylim = c(0.4, 0.80)) +
  scale_fill_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef")) +
  scale_color_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef"))

# Save to PNG
ggsave(p1, device = "png", filename = "figure_a_panel_a_with_smoking.png", path = "Figures/panels/", width = 8, height = 8, dpi = 600, units = "in")

# Save to SVG
ggsave(p1, device = "svg", filename = "figure_a_panel_a_with_smoking.svg", path = "Figures/panels/", width = 8, height = 8, dpi = 600, units = "in")
```

# Figure 1B plot
```{r combining all overall survival cindicies together for second panel}
plot_df <- data.frame(metric = c("M", "S", "miR", "CS", "SM", "MS", "miRM", "miRS", "miRMS"), cindex = c(0.6212627, 0.6746058, 0.6920965, 0.7081862, 0.4913271, 0.6958149, 0.6907635, 0.6907635,  0.7378887))

plot_df$metric <- factor(plot_df$metric, levels = c("M", "S", "miR", "CS", "SM", "MS", "miRM", "miRS", "miRMS"), labels = c("M", "S", "miR", "CS","SM", "MS", "miRM", "miRS", "miRMS"))
p1 <- ggplot(data = plot_df, aes(x = metric, y = cindex, fill = metric, color = metric)) +
  geom_col(width = 0.4) +
  geom_text(aes(label = round(cindex, 2), y = cindex + 0.01),
    size = 4,
    position = position_dodge(width = 0.4), color = "black"
  ) +
  theme(
    panel.background = element_blank(),
    axis.title = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 14),
    axis.text.x = element_text(angle = 45, vjust = 0.7),
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.ticks.length = unit(0.2, units = "cm"),
    legend.position = "none",
    axis.ticks = element_line(color = "black", linewidth = 0.75)
  ) +
  xlab("Metric") +
  ylab("Mean 10-fold CV C-index") +
  ggtitle("1000 Bootstrapped Datasets | Overall Survival") +
  scale_y_continuous(expand = c(0, 0))

p1 <- p1 + coord_cartesian(ylim = c(0.4, 0.8)) +
  scale_fill_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef")) +
  scale_color_manual(values = c("grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "grey35", "#0796ef"))

# Save to PNG
ggsave(p1, device = "png", filename = "figure_a_panel_b_4_predictors.png", path = "~/Desktop/", width = 8, height = 8, dpi = 600, units = "in")

# Save to SVG
ggsave(p1, device = "svg", filename = "figure_a_panel_b_4_predictors.svg", path = "~/Desktop/", width = 8, height = 8, dpi = 600, units = "in")
```

# Now doing the same thing as above but for progress free survival
```{r miRMS progress free survival performance}
cox_outputs <- list()
counter <- 1
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# Extract the mean cross-validated performance for each fold at the minimum lambda value
# Foldids to reproduce 10-fold CV splits is c(3 2  5  5  3  2  4 7  2  8  2 10  7  9  1  1  7  9  4  6 10  6  1  7  8  3  2  3  7  9  5  5  1  9  4 10  9 10  5  1  8 10  4  3  6  1  3  8  6  8  2  5  9  2  3  1 10  4  2  4  7  7  4  6  8  6  5 10  9  8  1  6)
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# Calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7567699
```

# Clinical staging progress-free survival
```{r clinical staging progress free 1000}
# Function to efficiently simplify tumor staging
modify_dataframe <- function(df) {
  df <- df %>%
    mutate(n.stage = factor(gsub("[A-Za-z]", "", n.stage))) %>%
    mutate(m.stage = factor(gsub("[A-Za-z]", "", m.stage))) %>%
    mutate(n.stage = ifelse(n.stage == "", NA, n.stage)) %>%
    mutate(m.stage = ifelse(m.stage == "", NA, m.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "I", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ia", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ib", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "Ic", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IA", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IB", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IC", 1, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "II", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIa", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIb", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIc", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIA", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIB", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIC", 2, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "III", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIa", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIb", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIc", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIA", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIB", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IIIC", 3, uicc.tumor.stage)) %>%
    mutate(uicc.tumor.stage = ifelse(uicc.tumor.stage == "IV", 4, uicc.tumor.stage)) %>%
    filter(!is.na(n.stage)) %>%
    filter(!is.na(m.stage)) %>%
    filter(!is.na(uicc.tumor.stage))

  return(df)
}

cox_outputs <- list()
counter <- 1
cox_preds <- c("n.stage", "m.stage", "uicc.tumor.stage")
bootstrap_datasets_clinical <- bootstrap_datasets
bootstrap_datasets_clinical <- lapply(bootstrap_datasets_clinical, modify_dataframe)

for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    progress_free = TRUE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 3,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7081862 with the 3 active predictors from miRNA
```



# miRNA + MAD + SDE Overall survival KM plot
```{r original data risk score and km plot for miRNA + MAD + SDE}
# Original data risk score
# First, let's assume your coefficients for each gene are stored in a vector like this:
coef <- c(-0.75737985824054, -0.0706471525401676, -0.16554139965723, 0.305795111401098, -0.000374799303479439, -0.027261204056091)

# And your data frame `data` has columns named after the genes
genes <- c("tfrc", "fam83f", "samd12", "grin2b", "dlk1", "gng13")

scl_common$risk_score <- rowSums(sapply(seq_along(genes), function(i) scl_common[, genes[i]] * coef[i]))
median_risk <- median(scl_common$risk_score)
scl_common$risk <- ifelse(scl_common$risk_score > median_risk, "high", "low")

scl_common <- scl_common %>%
  select(patient.id, sex, smoker, vital.status, time, n.stage, m.stage, uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy, risk_score, risk, everything())

# Function to compute p-value from Kaplan-Meier fit
compute_p_value <- function(data, progress_free = FALSE) {
  if (progress_free) {
    fit <- survfit(Surv(data$time2, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time2, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  } else {
    fit <- survfit(Surv(data$time, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  }
}

# Compute observed p-value
observed_p_value <- compute_p_value(scl_common)

# Permutation test
set.seed(1)
n_permutations <- 1000
permuted_p_values <- replicate(n_permutations, {
  permuted_data <- scl_common
  permuted_data$risk <- sample(scl_common$risk) # Randomly permute risk labels
  compute_p_value(permuted_data)
})

# Compute p-value of permutation test
perm_p_value <- mean(permuted_p_values <= observed_p_value)


# Plotting the KM curve
fit <- survfit(Surv(scl_common$time, scl_common$vital.status) ~ risk, data = scl_common)
p1 <- ggsurvplot(
  fit = fit,
  data = scl_common,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(3500, 0.8),
  palette = c("red", "blue"),
  risk.table = FALSE,
  censor.shape = "|", 
  surv.median.line = "hv",
  risk.table = "abs_pct",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Risk",
  title = "Single Dataset | miRMS",
  legend.labs = c("High risk", "Low risk"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)


# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_d.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_d.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```

# C-index for other methods on initial dataset
```{r desingle. 0.6521 C-index with 3 active predictors}
# Processing steps for generarting normal cells single-cell data
sc_df <- fread("Data/OMIX002441-01.csv")
sc_df <- sc_df %>%
  select(-matches("^(SCLC_P1|SCLC_P14)")) %>%
  t() # transpose the data frame to have cells as rows

# Set column names to the first row of the data frame
colnames(sc_df) <- sc_df["V1", ]
sc_df <- sc_df[-1, ] # remove first row, which is now redundant
sc_df <- as.data.frame(sc_df)

# Read in the metadata and filter for normal samples only
meta_data <- fread("Data/OMIX002441-02.csv")
meta_data <- meta_data %>%
  filter(NT == "normal")

# Set row names to the first column, which contains the cell IDs
colnames(meta_data)[1] <- "id"

# Join the two dataframes on the "id" column
sc_df$id <- rownames(sc_df)
sc_df <- inner_join(sc_df, meta_data, by = "id")
sc_df <- sc_df %>%
  mutate(id = paste0(id, "_", NT, "_", cell_type))
rownames(sc_df) <- sc_df$id
sc_df <- sc_df %>% select(
  -id, -patient, -NT, -tissue, -cell_type,
  -nCount_RNA, -nFeature_RNA, -Pre_Map_Reads,
  -Aligned_Reads, -MappingRate
)

# Keep only genes that are expressed in at least 10 cells
keep_cols <- colSums(sc_df > 0) > 10
sc_df <- sc_df[, keep_cols]


# Convert the data frame to integers
sc_df <- apply(sc_df, c(1, 2), as.integer) %>%
  as.data.frame()


# saveRDS(sc_df, "Outputs/normal_sc_df.rds")

# Denoising the normal cells
# Convert the sc_df dataframe to a matrix
sc_df_mat <- as.matrix(normal_sc_df)

sc_denoised <- magic(sc_df_mat, genes = "all_genes", seed = 1688405764, n.jobs = -1)

# Saving the denoised matrix
# saveRDS(sc_denoised, "Outputs/denoised_sc_normal_data_new_random_seed.rds")

# Removing intermediate files to keep environment tidy
rm(sc_df_mat)

# Now denoising the whole thing together
sc_df <- fread("Data/OMIX002441-01.csv")
sc_df <- sc_df %>%
  select(-matches("^(SCLC_P1|SCLC_P14)")) %>%
  t() # transpose the data frame to have cells as rows

# Set column names to the first row of the data frame
colnames(sc_df) <- sc_df["V1", ]
sc_df <- sc_df[-1, ] # remove first row, which is now redundant
sc_df <- as.data.frame(sc_df)

# Read in the metadata for all samples
meta_data <- fread("Data/OMIX002441-02.csv")

# Set row names to the first column, which contains the cell IDs
colnames(meta_data)[1] <- "id"

# Join the two dataframes on the "id" column
sc_df$id <- rownames(sc_df)
sc_df <- inner_join(sc_df, meta_data, by = "id")
sc_df <- sc_df %>%
  mutate(id = paste0(id, "_", NT))
rownames(sc_df) <- sc_df$id
sc_df <- sc_df %>% select(
  -id, -patient, -NT, -tissue, -cell_type,
  -nCount_RNA, -nFeature_RNA, -Pre_Map_Reads,
  -Aligned_Reads, -MappingRate
)

# Keep only genes that are expressed in at least 10 cells
keep_cols <- colSums(sc_df > 0) > 10
sc_df <- sc_df[, keep_cols]


# Convert the data frame to integers
sc_df <- apply(sc_df, c(1, 2), as.integer) %>%
  as.data.frame()


saveRDS(sc_df, "Outputs/all_sc_df.rds")

# Denoising the normal cells
# Convert the sc_df dataframe to a matrix
sc_df_mat <- as.matrix(all_sc_df)

sc_denoised <- magic(sc_df_mat, genes = "all_genes", seed = 1688405764, n.jobs = -1)

# Saving the denoised matrix
# saveRDS(sc_denoised$result, "Outputs/denoised_sc_all_data_new_random_seed.rds")

# Removing intermediate files to keep environment tidy
rm(sc_df_mat)


#Reading in single-cell files
all_tumor_cells_fpkm <- readRDS("Outputs/denoised_sc_data_new_random_seed.rds")
all_nm_cells_fpkm <- readRDS("Outputs/denoised_sc_normal_data_new_random_seed.rds")
all_cells <- readRDS("Outputs/denoised_sc_all_data_new_random_seed.rds")
all_cells <- t(all_cells)

condition <- unlist(colnames(all_cells) %>% str_extract_all("(normal|tumor)"))
condition <- ifelse(condition == "normal", 1, 2)
condition <- factor(condition)

sce <- SingleCellExperiment(assays=list(counts=all_cells))

des_results <- DEsingle(counts = sce, group = condition, parallel = TRUE,
                        BPPARAM = BiocParallel::bpparam())


saveRDS(des_results, file = "Outputs/des_results.rds")
write.csv(des_results, file = "Outputs/des_results.csv")

des_results <- filter(des_results, pvalue.adj.FDR < 0.05)
rownames(des_results) <- tolower(rownames(des_results))

gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1

for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(my_seed = 1688405764,
                                  my_alpha = 1,
                                  cox_predictors = rownames(des_results),
                                  cox_df = scl_common,
                                  gene_num = gn,
                                  n_folds = 10, 
                                  calc_auc = FALSE,
                                  save_coefs = TRUE,
                                  my_filename = paste0("Outputs/desingle/active_coefs/", gn, "_active_coefs.csv"),
                                  verbose = FALSE,
                                  my_folds = NULL)
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  active_genes <- current_cox$`Active Genes`
  active_coefs <- current_cox$`Active Coefficients`
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  cindex_df$active_genes <- paste(active_genes, collapse = ",")
  cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
  write.csv(cindex_df, paste0("Outputs/desingle/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_new_random_seed.csv"))
  counter <- counter + 1
}

# Now seeing what the best c-index is
all_desingle_cindices <- read_files(folder_path = "Outputs/desingle/", pattern = "*.csv")
all_desingle_cindices_sub <- all_desingle_cindices %>% filter(cindex_active_genes < 8)
max_desingle_cindex <- all_desingle_cindices_sub[which.max(all_desingle_cindices_sub$cindex), ] # 0.6521 with 3 active genes with new random seed
```

#DEsingle on 1,000 simulated datasets
```{r desingle on 1000 simulated datasets 0.6952395}
cox_preds <- data.frame(preds = c("dek", "hmgn2", "cox7a2"))
rownames(cox_preds) <- cox_preds$preds
cox_outputs <- list()
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = FALSE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 3,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6626098
```

#edgeR on 1,000 simulated datasets
```{r edgeR. 0.6469 with 2 active predictors}
dge <- DGEList(assay(zinb_data))
dge <- calcNormFactors(dge)

weights <- assay(zinb_data, "weights")


design <- model.matrix(~cell_state, data = colData(zinb_data))
dge$weights <- weights
dge <- estimateDisp(dge, design)
fit <- glmFit(dge, design)

lrt <- glmWeightedF(fit, coef = 1:2)
topTags(lrt)

finished_edger <- lrt$table
finished_edger <- finished_edger %>% arrange(padjFilter)
# write.csv(finished_edger, "Outputs/edger_res.csv")

rownames(finished_edger) <- finished_edger$X
rownames(finished_edger) <- tolower(rownames(finished_edger))

gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1

for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(my_seed = 1688405764,
                                  my_alpha = 1,
                                  cox_predictors = rownames(finished_edger),
                                  cox_df = scl_common,
                                  gene_num = gn,
                                  n_folds = 10, 
                                  calc_auc = FALSE,
                                  save_coefs = FALSE,
                                  verbose = FALSE,
                                  my_folds = NULL,
                                  cat_preds = FALSE)
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  active_genes <- current_cox$`Active Genes`
  active_coefs <- current_cox$`Active Coefficients`
  cindex_df$active_genes <- paste(active_genes, collapse = ",")
  cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
  write.csv(cindex_df, paste0("Outputs/edger/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_new_random_seed.csv"))
  counter <- counter + 1
}

# Now seeing what the best c-index is
all_edger_cindices <- read_files(folder_path = "Outputs/edger/", pattern = "*.csv")
all_edger_cindices_sub <- all_edger_cindices %>% filter(cindex_active_genes < 8)
max_edger_cindex <- all_edger_cindices_sub[which.max(all_edger_cindices_sub$cindex), ] # 0.6469 with 2 active genes with new random seed
```

```{r edger on 1000 simulated datasets 0.6096405}
cox_preds <- data.frame(preds = c("anxa1", "arl6ip1"))
rownames(cox_preds) <- cox_preds$preds
cox_outputs <- list()
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = FALSE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6390974
```

# scDD on 1000 datasets
```{r scdd 1000 datasets 0.6943911}
cox_preds <- data.frame(preds = c("anxa1", "arl6ip1"))
rownames(cox_preds) <- cox_preds$preds

cox_outputs <- list()
counter <- 1
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = FALSE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 2,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.6390974
```



```{r scdd. 0.6469 C-index with 2 active predictors}
sce <- SingleCellExperiment(assays=list(normcounts= all_cells), colData=data.frame(condition))
prior_param <- list(alpha=0.01, mu0=0, s0=0.01, a0=0.01, b0=0.01)
scdd_res <- scDD(sce, prior_param=prior_param, testZeroes=FALSE, categorize = FALSE)
scdd_res <- results(scdd_res)

saveRDS(scdd_res, file = "Outputs/scdd_results.rds")
write.csv(scdd_res, file = "Outputs/scdd_results.csv")

scdd_res <- filter(scdd_res, nonzero.pvalue.adj < 0.05)

scdd_res$gene <- tolower(scdd_res$gene)

gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1

for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(my_seed = 1688405764,
                                  my_alpha = 1,
                                  cox_predictors = scdd_res$gene,
                                  cox_df = scl_common,
                                  gene_num = gn,
                                  n_folds = 10, 
                                  calc_auc = FALSE,
                                  save_coefs = TRUE,
                                  verbose = FALSE,
                                  my_folds = NULL,
                                  cat_preds = FALSE)
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  active_genes <- current_cox$`Active Genes`
  active_coefs <- current_cox$`Active Coefficients`
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  cindex_df$active_genes <- paste(active_genes, collapse = ",")
  cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
  write.csv(cindex_df, paste0("Outputs/scdd/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_new_random_seed.csv"))
  counter <- counter + 1
}

# Now seeing what the best c-index is
all_scdd_cindices <- read_files(folder_path = "Outputs/scdd/", pattern = "*.csv")
all_scdd_cindices_sub <- all_scdd_cindices %>% filter(cindex_active_genes < 8)
max_scdd_cindex <- all_scdd_cindices_sub[which.max(all_scdd_cindices_sub$cindex), ] # 0.6469 with 2 active genes with new random seed
```


# DESeq2 on 1000 datasets
```{r deseq2 1000 datasets 0.6700623}
cox_preds <- data.frame(preds = c("rpl9"))
rownames(cox_preds) <- cox_preds$preds

cox_outputs <- list()
counter <- 1
cox_preds <- sde_genes
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = FALSE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 1,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.5025007
```


```{r deseq2. 0.683 C-index with 1 active predictor}
all_cells <- readRDS("Outputs/denoised_sc_all_data_new_random_seed.rds")
all_cells <- t(all_cells)

all_cells <- apply(all_cells, c(1, 2), as.integer)

# Making a summarizedExperiment object from the combined data frame
deseq2_se <- SummarizedExperiment(
  assays = list(counts = as.matrix(all_cells)),
  colData = DataFrame(label = colnames(all_cells)),
  rowData = DataFrame(length = rownames(all_cells))
)

keep <- rowSums(assay(deseq2_se) > 5) > 10
table(keep)
zinb_data <- deseq2_se[keep, ]

normal_num <- rep("normal", 1394)
tumor_num <- rep("tumor", 1197)
all_nums <- c(tumor_num, normal_num)

zinb_data$cell_state <- all_nums
zinb_data <- zinb_data[names(zinb_data)[1:dim(zinb_data)[1]], ]

# For multicore
BiocParallel::register(BiocParallel::MulticoreParam())

zinb_data <- zinbwave(zinb_data,
  K = 0, BPPARAM = BiocParallel::bpparam(),
  epsilon = 1e12, normalizedValues = FALSE,
  observationalWeights = TRUE, verbose = TRUE
)

dds <- DESeqDataSet(zinb_data, design = ~cell_state)
dds_red <- DESeqDataSet(zinb_data, design = ~1)

dds <- estimateSizeFactors(dds, type = "poscounts")
dds_red <- estimateSizeFactors(dds_red, type = "poscounts")

scr <- scran::calculateSumFactors(dds)
sizeFactors(dds) <- scr

scr_red <- scran::calculateSumFactors(dds_red)
sizeFactors(dds_red) <- scr_red

dds <- DESeq(dds,
  sfType = "poscounts", useT = TRUE, minmu = 1e-6, minReplicatesForReplace = Inf,
  test = "LRT", reduced = ~1
)

res <- results(dds)
resSig <- subset(res, padj < 0.05)
# write.csv(as.data.frame(resSig), "Outputs/deseq2_res.csv")
deseq2_res <- read.csv("Outputs/deseq2_res.csv")
deseq2_res <- deseq2_res %>% 
  arrange(padj) %>%
  rename(gene = X)

deseq2_res$gene <- tolower(deseq2_res$gene)

gene_sizes <- seq(1, 20, 1)
cox_outputs <- list()
counter <- 1

for (gn in gene_sizes) {
  current_cox <- cox_model_fitter(my_seed = 1688405764,
                                  my_alpha = 1,
                                  cox_predictors = deseq2_res$gene,
                                  cox_df = scl_common,
                                  gene_num = gn,
                                  n_folds = 10, 
                                  calc_auc = FALSE,
                                  save_coefs = FALSE,
                                  verbose = FALSE,
                                  my_folds = NULL,
                                  cat_preds = FALSE)
  cox_outputs[[counter]] <- current_cox
  cindex <- round(current_cox$CV$cvm[which(current_cox$CV$lambda == current_cox$CV$lambda.min)], digits = 4)
  cindex_active_genes <- as.numeric(as.vector(current_cox$CV$nzero[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]))
  lambda <- current_cox$CV$lambda.min
  measure <- "Concordance-index"
  cindex_se <- round(as.numeric(current_cox$CV$cvsd[which(current_cox$CV$lambda == current_cox$CV$lambda.min)]), digits = 4)
  cindex_index <- current_cox$CV$index["min", ]
  active_genes <- current_cox$`Active Genes`
  active_coefs <- current_cox$`Active Coefficients`
  cindex_df <- as.data.frame(cbind(cindex, cindex_se, cindex_active_genes, lambda, measure, cindex_index))
  cindex_df$active_genes <- paste(active_genes, collapse = ",")
  cindex_df$active_coefs <- paste(active_coefs, collapse = ",")
  write.csv(cindex_df, paste0("Outputs/deseq2/glmnet_", gn, "_genes_glmnet_index_", cindex_index, "_lambda_", lambda, "_new_random_seed.csv"))
  counter <- counter + 1
}

# Now seeing what the best c-index is
all_deseq2_cindices <- read_files(folder_path = "Outputs/deseq2/", pattern = "*.csv")
all_deseq2_cindices_sub <- all_deseq2_cindices %>% filter(cindex_active_genes < 8)
max_deseq2_cindex <- all_deseq2_cindices_sub[which.max(all_deseq2_cindices_sub$cindex), ] # 0.683 with 1 active genes with new random seed
```

# Plotting the other methods on training dataset
```{r plotting other methods}
other_methods_df <- data.frame(c_index = c(0.6521, 0.6469, 0.683,0.6469, 0.7243224), method = c("DEsingle", "scDD", "DEseq2", "edgeR", "miRMS"))

other_methods_df$method <- factor(other_methods_df$method, levels = c("miRMS", "DEsingle", "scDD", "DEseq2", "edgeR"))

p0 <- ggplot(data = other_methods_df, aes(x = method, y = c_index))+
  geom_col(width = 0.3, fill = "skyblue")+
  xlab("Method")+
  ylab("Mean 10-fold\nCV C-index")+
  ggtitle("Initial Dataset | Overall Survival")+
  scale_y_continuous(expand = c(0,0))+
  scale_x_discrete(expand = c(0,0))+
  coord_cartesian(ylim = c(0.5, 0.75))+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text.x = element_text(size = 14, angle = 45, vjust = 0.6, hjust = 0.6),
        axis.text.y = element_text(size = 14))
p0

ggsave(p0, filename = "initial_dataset_mirms_vs_other_methods.png", path = "Figures/panels/", dpi = 600, width = 7, height = 7, units = "in")
ggsave(p0, filename = "initial_dataset_mirms_vs_other_methods.svg", path = "Figures/panels/", dpi = 600, width = 7, height = 7, units = "in")
```


# Plotting the other methods on 1000 simulated datasets
```{r plotting other methods on 10000 simulated datasets}
other_methods_df <- data.frame(c_index = c(0.6952395, 0.6943911, 0.6700623,0.6096405,0.7378887), method = c("DEsingle", "scDD", "DEseq2", "edgeR", "miRMS"))

other_methods_df$method <- factor(other_methods_df$method, levels = c("miRMS", "DEsingle", "scDD", "DEseq2", "edgeR"))

p0 <- ggplot(data = other_methods_df, aes(x = method, y = c_index))+
  geom_col(width = 0.3, fill = "skyblue")+
  xlab("Method")+
  ylab("Mean 10-fold\nCV C-index")+
  ggtitle("1000 Bootstrapped Datasets | Overall Survival")+
  scale_y_continuous(expand = c(0,0))+
  scale_x_discrete(expand = c(0,0))+
  coord_cartesian(ylim = c(0.5, 0.75))+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text.x = element_text(size = 14, angle = 45, vjust = 0.6, hjust = 0.6),
        axis.text.y = element_text(size = 14))
p0

ggsave(p0, filename = "mirms_vs_other_methods_1000_datasets.png", path = "Figures/panels/", dpi = 600, width = 7, height = 7, units = "in")
ggsave(p0, filename = "mirms_vs_other_methods__1000_datasets.svg", path = "Figures/panels/", dpi = 600, width = 7, height = 7, units = "in")
```

# Performing 10-fold CV on subsets of the predictors to see if we can stabalize GRIN2B
```{r 10-fold CV subsets}
# Identified signature is "gng13","tfrc","fam83f","dlk1" with 10-fold cv of 0.770655075918234
genes <- c("gng13","tfrc","fam83f","samd12","grin2b","dlk1")
# Second round of elimination to see if we can get it down to 4 genes to see if we see big differences in performance
genes2 <- c("gng13","tfrc","fam83f","grin2b","dlk1")

cox_preds2 <- as.data.frame(genes2)
rownames(cox_preds2) <- cox_preds2$genes2
colnames(cox_preds2) <- "preds"


# Loop through each gene and evaluate the model
current_preds <- cox_preds2

for (gene_to_drop in genes2) {
  current_preds <- cox_preds2
  current_preds <- current_preds[current_preds$preds != gene_to_drop, ]
  current_preds <- as.data.frame(current_preds)
  rownames(current_preds) <- current_preds$current_preds
  num_remaining_genes <- nrow(current_preds)
  
  message(paste0("The number of remaining genes are: ", num_remaining_genes))
  message(paste0("The current gene that has been dropped is: ", gene_to_drop))
  
  # Fit the model with the remaining genes
  current_cox <- cox_model_fitter(
    my_seed = 1,
    my_alpha = 0,
    sim_testing = FALSE,
    progress_free = FALSE,
    cox_predictors = current_preds,
    cox_df = scl_common,
    gene_num = num_remaining_genes,
    my_folds = NULL,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )
  
  message(paste0("The c-index of this gene set is: ", current_cox$CV$cvm[current_cox$CV$index[1]]))
}
```
# Forestplot
```{r forestplot of the 4 predictor model}
# Risk score: -0.9526172*tfrc + -0.0854650*fam83f + -0.0006146*dlk1 + -0.2557644*gng13
cox_mod <- coxph(Surv(time, vital.status) ~ tfrc + fam83f + dlk1 + gng13, data = scl_common)
forest_plot <- ggforest(model = cox_mod, data = scl_common)


# Nicer forestplot
x <- summary(cox_mod)
mod_coefs <- x$coefficients
genes <- rownames(mod_coefs)
mod_cis <- x$conf.int
genes2 <- rownames(mod_cis)
mod_coefs <- as.data.frame(mod_coefs)
mod_cis <- as.data.frame(mod_cis)
mod_coefs$gene <- genes
mod_cis$gene <- genes2
total_mod_df <- merge(mod_coefs, mod_cis, by = "gene")
total_mod_df <- total_mod_df %>%
  select(gene, `exp(coef).x`, `lower .95`, `upper .95`, `Pr(>|z|)`) %>%
  rename("gene" = gene, "mean" = `exp(coef).x` , "lower" = `lower .95`,  "upper" = `upper .95`, "p_value" = `Pr(>|z|)`) %>%
  mutate(gene = toupper(gene),
         mean = signif(mean, digits = 2),
         lower = signif(lower, digits = 2),
         upper = signif(upper, digits = 2),
         p_value = signif(p_value, digits = 2)) %>%
  mutate(hr = mean,
         n = rep(72, times = 4)) %>%
  arrange(p_value)


finished_fp <- total_mod_df %>%
  forestplot::forestplot(labeltext = c(gene, n, hr, p_value),
                         xlog = TRUE,
                         vertices = TRUE) %>%
  fp_set_style(box = "royalblue",
               line = "darkblue") %>%
   fp_set_zebra_style("#EFEFEF") %>%
  fp_add_header(gene = "Gene",
                n = "n",
                hr = "HR",
                p_value = "p-value") %>%
  fp_decorate_graph(graph.pos = 4)
```


# miRNA + MAD + SDE Overall survival KM plot 4 gene signature (miRMS signature)
```{r original data risk score and km plot for miRNA + MAD + SDE}
# Original data risk score
# First, let's assume your coefficients for each gene are stored in a vector like this:
coef <- c(-0.9526172, -0.0854650, -0.0006146, -0.2557644)

# And your data frame `data` has columns named after the genes
genes <- c("tfrc", "fam83f", "dlk1", "gng13")

scl_common$risk_score <- rowSums(sapply(seq_along(genes), function(i) scl_common[, genes[i]] * coef[i]))
median_risk <- median(scl_common$risk_score)
scl_common$risk <- ifelse(scl_common$risk_score > median_risk, "high", "low")

scl_common <- scl_common %>%
  select(patient.id, sex, smoker, vital.status, time, n.stage, m.stage, uicc.tumor.stage, chemotherapy, neoadjuvant.chemotherapy, risk_score, risk, everything())

# Function to compute p-value from Kaplan-Meier fit
compute_p_value <- function(data, progress_free = FALSE) {
  if (progress_free) {
    fit <- survfit(Surv(data$time2, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time2, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  } else {
    fit <- survfit(Surv(data$time, data$vital.status) ~ risk, data = data)
    logrank_test <- survdiff(Surv(data$time, data$vital.status) ~ risk, data = data)
    p_value <- 1 - pchisq(logrank_test$chisq, length(logrank_test$n) - 1)
    return(p_value)
  }
}

# Compute observed p-value
observed_p_value <- compute_p_value(scl_common)


# Plotting the KM curve
fit <- survfit(Surv(scl_common$time, scl_common$vital.status) ~ risk, data = scl_common)
p1 <- ggsurvplot(
  fit = fit,
  data = scl_common,
  conf.int = TRUE,
  pval = TRUE,
  pval.size = 5,
  pval.coord = c(3500, 0.8),
  palette = c("red", "blue"),
  censor.shape = "|", 
  surv.median.line = "hv",
  size = 1.5,
  censor.size = 4.5,
  xlab = "Time (days)",
  legend.title = "Risk",
  title = "Single Dataset | miRMS",
  legend.labs = c("High risk", "Low risk"),
  ggtheme = theme(
    axis.line = element_line(color = "black", linewidth = 1.25, lineend = "round"),
    axis.title = element_text(size = 18, face = "bold"),
    plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 16),
    axis.ticks = element_line(linewidth = 1.25),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    panel.background = element_blank()
  )
)


# Saving as PNG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_d_4_gene_predictor.png", device = "png", width = 8, height = 8, dpi = 600, units = "in")

# Saving as SVG
ggsave(p1$plot, path = "Figures/panels/", filename = "figure_a_panel_d_4_gene_predictor.svg", device = "svg", width = 8, height = 8, dpi = 600, units = "in")
```


# Now taking our 1000 datasets and testing the 4 predictors we have identified and seeing how they perform
```{r for 1000 simulations of 10 fold cv on mirna + mad + sde 4 gene signature}
cox_outputs <- list()
counter <- 1
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# Extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# Calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7378887 for 4 active predictors
```



```{r mirna + mad + sde progress free for 4 predictors}
cox_outputs <- list()
counter <- 1
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds
for (d in 1:length(bootstrap_datasets)) {
  current_dataset <- bootstrap_datasets[[d]]
  current_cox <- cox_model_fitter(
    my_seed = 1688405764,
    my_alpha = 0,
    sim_testing = TRUE,
    progress_free = TRUE,
    cox_predictors = cox_preds,
    cox_df = current_dataset,
    gene_num = 4, 
    my_folds = NULL,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10
  )

  cox_outputs[[counter]] <- current_cox
  counter <- counter + 1
}


# extract the mean cross-validated performance for each fold at the minimum lambda value
cv_performance <- sapply(cox_outputs, function(x) x$CV$cvm[x$CV$lambda == x$CV$lambda.min])

# calculate the mean performance across all folds
mean_performance <- mean(cv_performance) # 0.7567699 with the 6 active predictors from MAD + SDE + miRNA
```

# Male vs. Female for 4 predictor model
```{r male vs. female 4 predictor model}
# Power analysis to determine how many samples for each group we need to detect a medium effect size with 95% power at 0.05 significance level
sample_size <- pwr.t.test(
  d = 0.2,
  sig.level = 0.05,
  power = 0.8,
  alternative = "two.sided"
)


# Extract the required sample size
required_sample_size <- ceiling(sample_size$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds


# Function to generate random samples
generate_matched_sex_samples <- function(data, sex_column=sex, sex_to_match, num_samples_to_generate, replace = TRUE) {
  # Filter the DataFrame to get samples with the specified subtype
  sex_data <- data %>%
    filter({{ sex_column }} == sex_to_match)
  
  # Use the slice_sample() function from dplyr to randomly select samples
  generated_samples <- sex_data %>%
    slice_sample(n = num_samples_to_generate, replace = replace)
  
  return(generated_samples)
}

for (s in unique(scl_common$sex)){
  current_sex <- filter(scl_common, sex == s)
  current_sex <- generate_matched_sex_samples(scl_common, sex_to_match = paste0(s), num_samples_to_generate = required_sample_size, replace = TRUE)
  message(paste0("On sex: ", s))
  # Number of iterations
  num_iterations <- 10000
  
  cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
  rownames(cox_preds) <- cox_preds$preds
  
  # Create a progress bar
  pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (i in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/random_seeds_initial_training_set_sex_",s,"_with_power_analysis_80_10000_iters_final.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = current_sex,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[i] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  current_df <- data.frame(sex = rep(s, length(c_index_vector)), c_index = c_index_vector)
  write.csv(current_df, file = paste0("Outputs/sex_",tolower(s),"_c_index_peformance_0.80_final.csv"))
  
  
  print(mean(c_index_vector))
  
}
```


```{r calculating stats for male v female performance with 4 predictor model}
male_df <- read.csv("Outputs/sex_male_c_index_peformance_0.80_final.csv", row.names = 1)
female_df <- read.csv("Outputs/sex_female_c_index_peformance_0.80_final.csv", row.names = 1)
sex_specific_df <- bind_rows(male_df, female_df)


# Check the assumptions for the t-test
assumptions_met <- TRUE

# Check for normality assumption
if (!shapiro.test(sex_specific_df$c_index)$p.value > 0.05) {
  assumptions_met <- FALSE
  message("Normality assumption not met. Trying Wilcoxon signed-rank test instead.")
}

# Check for homogeneity of variances assumption (Levene's test)
if (assumptions_met && !car::leveneTest(c_index ~ sex, data = sex_specific_df)$p.value > 0.05) {
  assumptions_met <- FALSE
  message("Homogeneity of variances assumption not met. Trying Wilcoxon signed-rank test instead.")
}

# Perform the appropriate test based on assumptions
if (assumptions_met) {
  # Perform t-test
  t_test_result <- t.test(c_index ~ sex, data = sex_specific_df)
  p_value <- t_test_result$p.value
  test_used <- "t-test"
} else {
  # Perform Wilcoxon signed-rank test
  wilcox_result <- wilcox.test(c_index ~ sex, data = sex_specific_df)
  p_value <- wilcox_result$p.value
  test_used <- "Wilcoxon signed-rank test"
}

# Print the results
cat("Test Used:", test_used, "\n")
cat("P-Value:", p_value, "\n")
p_value_formatted <- format_p(p = p_value, stars = TRUE, stars_only = TRUE)
```

# Male vs. Female Plot
```{r male v female 4 predictor plot}
sex_specific_df$sex <- factor(sex_specific_df$sex, levels = c("Male", "Female"))
p3 <- ggplot(data = sex_specific_df, aes(x = sex, y = c_index))+
  geom_violin()+
  geom_sina()+
  xlab("Sex")+
  ylab("C-index of\n 10000 10-fold CVs")+
  ggtitle("Sex-Specific")+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, hjust = 0.5, face = "bold"),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14),
        legend.position = "none",
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 14))+
  scale_x_discrete(breaks = c("Male", "Female"),
                   labels = c("Male \n(n = 394)",
                              "Female \n(n = 394)"))+
  geom_signif(annotations = "***", xmin = 1, xmax = 2, y_position = 1.02, tip_length = 0, vjust = 0.5)

p3


ggsave(p3, filename= "sex_specific_panel_4_preds_10000_iters.png", units = "in", dpi = 600, path = "Figures/panels/", width = 8, height = 8)
ggsave(p3, filename= "sex_specific_panel_4_preds_10000_iters.svg", units = "in", dpi = 600, path = "Figures/panels/", width = 8, height = 8)
```

# Cancer Subtyping for 4 predictor model
```{r cancer subtyping survival 4 gene predictor}
scl_common <- scl_common %>%
  mutate(
    # Calculate the maximum expression value across the specified genes for each patient
    max_expression = pmax(ascl1, yap1, neurod1, pou2f3)
  ) %>%
  rowwise() %>%
  mutate(
    # Create a new column to indicate the category (A, Y, N, P) for each patient
    subtype = case_when(
      max_expression == ascl1 ~ "A",
      max_expression == yap1 ~ "Y",
      max_expression == neurod1 ~ "N",
      max_expression == pou2f3 ~ "P",
      TRUE ~ NA_character_
    )
  ) %>%
  ungroup()

scl_common <- scl_common %>%
  filter(subtype == "A" | subtype == "N" | subtype == "P")


generate_matched_samples <- function(data, subtype_column=subtype, subtype_to_match, num_samples_to_generate, replace = TRUE) {
  # Filter the DataFrame to get samples with the specified subtype
  subtype_data <- data %>%
    filter({{ subtype_column }} == subtype_to_match)
  
  # Use the slice_sample() function from dplyr to randomly select samples
  generated_samples <- subtype_data %>%
    slice_sample(n = num_samples_to_generate, replace = replace)
  
  return(generated_samples)
}


# Power analysis for each subtype
# Adjust the function and arguments based on your test and data
# f = 0.2 equal small effect size, 0.5 = medium effect size, 0.8 = large effect size
power_analysis <- pwr.anova.test(f = 0.2, k = 3, power = 0.8, sig.level = 0.05
)

# Extract the required sample size
required_sample_size <- ceiling(power_analysis$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")


for (s in unique(scl_common$subtype)){
  current_sub <- filter(scl_common, subtype == s)
  current_sub <- generate_matched_samples(scl_common, subtype_to_match = paste0(s), num_samples_to_generate = required_sample_size, replace = TRUE)
  message(paste0("On subtype: ", s))
  # Number of iterations
  num_iterations <- 1000
  
  cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
  rownames(cox_preds) <- cox_preds$preds
  
  # Create a progress bar
  pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (i in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("~/Documents/Work/Phd_program/hong_lab/Projects/sclc/Outputs/random_seeds/random_seeds_initial_training_set_subtype_",s,"_with_power_analysis_80_1000_iters_4_preds.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = current_sub,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[i] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  current_df <- data.frame(subtype = rep(s, length(c_index_vector)), c_index = c_index_vector)
  View(current_df)
  write.csv(current_df, file = paste0("~/Documents/Work/Phd_program/hong_lab/Projects/sclc/Outputs/random_seeds/subtype_",s,"_c_index_peformance_1000_iters_4_preds_0.8_pwr.csv"))
  
  
  print(mean(c_index_vector))
  
}

```

```{r subtype plotting for the 4 predictor model}
subtype_df_a <- read.csv("~/Documents/Work/Phd_program/hong_lab/Projects/sclc/Outputs/random_seeds/subtype_A_c_index_peformance_1000_iters_4_preds_0.8_pwr.csv", row.names = 1)
subtype_df_n <- read.csv("~/Documents/Work/Phd_program/hong_lab/Projects/sclc/Outputs/random_seeds/subtype_N_c_index_peformance_1000_iters_4_preds_0.8_pwr.csv", row.names = 1)
subtype_df_p <- read.csv("~/Documents/Work/Phd_program/hong_lab/Projects/sclc/Outputs/random_seeds/subtype_P_c_index_peformance_1000_iters_4_preds_0.8_pwr.csv", row.names = 1)

subtype_df <- bind_rows(subtype_df_a, subtype_df_n, subtype_df_p)


p4 <- ggplot(data = subtype_df, aes(x = subtype, y = c_index))+
  geom_violin()+
  geom_sina()+
  stat_summary(fun = mean, geom = "point", shape = 23, size = 4, fill = "red", color = "red") +
  xlab("Subtype")+
  ylab("Mean C-index\nof 1000 10-fold CVs")+
  ggtitle("Subtype-Specific", subtitle = "All pairwise p-values < 0.001")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 22),
        plot.subtitle = element_text(hjust = 0.5, size = 16),
        axis.title = element_text(face = "bold", size = 22),
        axis.text.x = element_text(size = 16),
        axis.text.y = element_text(size = 20)) +
  coord_cartesian(ylim = c(0.4, 1.0))+
  scale_x_discrete(breaks = c("A", "N", "P"),
                   labels = c("A\n(n = 82)",
                              "N\n(n = 82)",
                              "P\n(n = 82)"))
  

p4


anova_test <- aov(c_index~subtype, data = subtype_df)
summary(anova_test)


dunn_test <- dunn.test(subtype_df$c_index, subtype_df$subtype, method = "bh")

ggsave(p4, filename = "4a.svg", path = "~/Documents/Work/Phd_program/hong_lab/Projects/sclc/Figures/panels/", dpi = 600, device = "svg", units = "in", width = 4, height = 4, bg = "white")


ggsave(p4, filename = "4a.png", path = "~/Documents/Work/Phd_program/hong_lab/Projects/sclc/Figures/panels/", dpi = 600, device = "png", units = "in", width = 4, height = 4, bg = "white")

```
# Tumor Staging for 4 predictor model
```{r tumor stages for 4 predictor model}
# I
scl_common <- scl_common %>%
  mutate(
    uicc.tumor.stage = case_when(
      uicc.tumor.stage %in% c("I", "Ia", "Ib", "IB") ~ "I",
      TRUE ~ uicc.tumor.stage
    )
  )


# II
scl_common <- scl_common %>%
  mutate(
    uicc.tumor.stage = case_when(
      uicc.tumor.stage %in% c("II", "IIa", "IIb") ~ "II",
      TRUE ~ uicc.tumor.stage
    )
  )

# III
scl_common <- scl_common %>%
  mutate(
    uicc.tumor.stage = case_when(
      uicc.tumor.stage %in% c("III", "IIIa", "IIIb") ~ "III",
      TRUE ~ uicc.tumor.stage
    )
  )


# Power analysis to determine how many samples for each group we need to detect a small effect size with 95% power at 0.05 significance level
sample_size <- pwr.t.test(
  d = 0.2,
  sig.level = 0.05,
  power = 0.8,
  alternative = "two.sided"
)


# Extract the required sample size
required_sample_size <- ceiling(sample_size$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")


generate_matched_tumor_samples <- function(data, num_samples_to_generate, replace = TRUE) {
  # Use the slice_sample() function from dplyr to randomly select samples
  generated_samples <- data %>%
    slice_sample(n = num_samples_to_generate, replace = replace)
  
  return(generated_samples)
}



# I + II C-index:  0.8135212
early_stage_df <- filter(scl_common, uicc.tumor.stage == "I" | uicc.tumor.stage == "II")

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds
early_stage_df <- generate_matched_tumor_samples(data = early_stage_df, num_samples_to_generate = required_sample_size)

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_first_and_second_tumor_stage_only_training_data_4_preds_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = early_stage_df,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

mean(c_index_vector)

# III + IV C-index: 0.7172984
late_stage_df <- filter(scl_common, uicc.tumor.stage == "III" | uicc.tumor.stage == "IV")
late_stage_df <- generate_matched_tumor_samples(data = late_stage_df, num_samples_to_generate = required_sample_size)

cox_preds <- data.frame(preds = c("tfrc", "fam83f", "dlk1", "gng13"))
rownames(cox_preds) <- cox_preds$preds

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a vector to store c-index values
c_index_vector <- numeric(num_iterations)

# Loop through iterations
for (i in 1:num_iterations) {
  # Generate a random seed for each iteration
  random_seed <- sample.int(10^6, 1)
  
  
  # Append the random seed to the CSV file
  write.table(data.frame(random_seed), file = "Outputs/random_seeds_third_and_fourth_tumor_stage_only_training_data_4_preds_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  
  # Call cox_model_fitter with the random seed and other parameters
  current_cox <- cox_model_fitter(
    my_seed = random_seed,
    my_alpha = 0,
    progress_free = FALSE,
    sim_testing = TRUE,
    cox_predictors = cox_preds,
    cox_df = late_stage_df,
    gene_num = 4,
    save_coefs = FALSE,
    tumor_stage = FALSE,
    tumor_n = FALSE,
    tumor_m = FALSE,
    calc_auc = FALSE,
    cat_preds = FALSE,
    n_folds = 10,
    my_folds = NULL
  )
  
  # Extract the c-index at lambda.min value from CV results
  min_lambda <- current_cox$CV$lambda.min
  min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
  c_index <- current_cox$CV$cvm[min_lambda_index]
  
  # Store the c-index value in the vector
  c_index_vector[i] <- c_index
  
  # Update the progress bar
  pb$tick()
}

write.csv(c_index_vector, "Outputs/late_tumor_stage.csv")

mean(c_index_vector)
```
# Tumor Plot
```{r plot for tumor staging for 4 predictor model}
tumor_df_early <- read.csv("Outputs/early_tumor_stage.csv", row.names = 1)
tumor_df_early$tumor_stage <- rep("Early", nrow(tumor_df_early))
colnames(tumor_df_early)[1] <- "c_index"

tumor_df_late <- read.csv("Outputs/late_tumor_stage.csv", row.names = 1)
tumor_df_late$tumor_stage <- rep("Late", nrow(tumor_df_late))
colnames(tumor_df_late)[1] <- "c_index"

tumor_df <- bind_rows(tumor_df_early, tumor_df_late)

p5 <- ggplot(data = tumor_df, aes(x = tumor_stage, y = c_index))+
  geom_violin()+
  geom_sina()+
  xlab("Tumor Stage")+
  ylab("C-index of\n 10000 10-fold CVs")+
  ggtitle("Tumor Staging")+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, hjust = 0.5, face = "bold"),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 14))+
  scale_x_discrete(breaks = c("Early", "Late"),
                   labels = c("Early \n(n = 394)",
                              "Late \n(n = 394)"))+
  geom_signif(annotations = "***", xmin = 1, xmax = 2, y_position = 0.85, tip_length = 0, vjust = 0.5)
  

p5

ggsave(p5, filename= "tumor_stage_specific_plot.png", units = "in", dpi = 600, path = "Figures/panels/", width = 8, height = 8, bg = "white")

ggsave(p5, filename = "tumor_stage_specific_plot.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")
```

```{r calculating stats for 4 predictors tumor staging}
# Perform Wilcoxon signed-rank test
wilcox_result <- wilcox.test(c_index ~ tumor_stage, data = tumor_df)
p_value <- wilcox_result$p.value
test_used <- "Wilcoxon signed-rank test"

# Print the results
cat("Test Used:", test_used, "\n")
cat("P-Value:", p_value, "\n")
p_value_formatted <- format_p(p = p_value, stars = TRUE, stars_only = TRUE)
```

# N staging for 4 predictor model
```{r n stage for 4 predictor model}
# Power analysis to determine how many samples for each group we need to detect a medium effect size with 95% power at 0.05 significance level
power_analysis <- pwr.anova.test(f = 0.2, k = 3, power = 0.80, sig.level = 0.05)


# Extract the required sample size
required_sample_size <- ceiling(power_analysis$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")

# Function to generate simulated samples
generate_matched_tumor_samples <- function(data, num_samples_to_generate, replace = TRUE) {
  # Use the slice_sample() function from dplyr to randomly select samples
  generated_samples <- data %>%
    slice_sample(n = num_samples_to_generate, replace = replace)
  
  return(generated_samples)
}

# Automated for all n stages

# Predictors
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds

# Specify the unique n.stage values in your data
scl_common_n_analysis_df <- scl_common %>%
  filter(n.stage != "") %>%
  filter(n.stage != 3) %>%
  filter(n.stage != "X")
n_stage_values <- unique(scl_common_n_analysis_df$n.stage)
n_stage_values <- c("0", "1", "2")

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = length(n_stage_values) * num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a list to store c-index vectors
c_index_vectors <- list()

# Loop through n.stage values
for (n_stage_value in n_stage_values) {
  # Filter data for the current n.stage
  n_stage_df <- filter(scl_common_n_analysis_df, n.stage == n_stage_value)
  
  # Generate matched tumor samples
  n_stage_df <- generate_matched_tumor_samples(data = n_stage_df, num_samples_to_generate = required_sample_size)
  
  # Create a directory for the current n.stage value
  dir.create(paste0("Outputs/n_stage_", n_stage_value), showWarnings = FALSE)
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (iteration in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/n_stage_", n_stage_value, "/random_seeds.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = n_stage_df,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[iteration] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  # Store the c-index vector in the list
  c_index_vectors[[as.character(n_stage_value)]] <- c_index_vector
  
  # Save c-index vector to a CSV file
  write.csv(c_index_vector, file = paste0("Outputs/n_stage_", n_stage_value, "/c_index_results.csv"))
  
  # Save the cox_df as an RDS file for future use
  saveRDS(n_stage_df, file = paste0("Outputs/n_stage_", n_stage_value, "/cox_df.rds"))
  
  # Save the current n.stage value for the random seed file
  write.table(data.frame(n_stage = n_stage_value), file = "Outputs/random_seeds.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  # Calculate and print the mean c-index for the current n.stage value
  mean_c_index <- mean(c_index_vector)
  cat(paste("Mean C-Index for n.stage", n_stage_value, ":", mean_c_index, "\n"))
}
```
# N Stage Plot
```{r n stage plot}
n_stage_0_df <- read.csv("Outputs/n_stage_0/c_index_results.csv")
n_stage_1_df <- read.csv("Outputs/n_stage_1/c_index_results.csv")
n_stage_2_df <- read.csv("Outputs/n_stage_2/c_index_results.csv")

n_stages <- list(n_stage_0_df, n_stage_1_df, n_stage_2_df)

for(x in 1:3){
  current_df <- n_stages[[x]]
  colnames(current_df) <- c("iteration", "c_index")
  current_df$n_stage <- rep(x = x - 1, times = nrow(current_df))
  n_stages[[x]] <- current_df
}

n_stages_df <-  bind_rows(n_stages) 
n_stages_df$n_stage <- factor(n_stages_df$n_stage, levels = c(0,1,2))

aov_res <- aov(c_index~n_stage, data = n_stages_df)
summary(aov_res)

dunn_res <- dunn.test::dunn.test(n_stages_df$c_index, n_stages_df$n_stage, method = "holm")


n_stage_plot <- ggplot(data = n_stages_df, mapping = aes(x = n_stage, y = c_index))+
  geom_violin()+
  geom_sina()+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 16, hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14))+
  xlab("N Stage")+
  ylab("Mean C-index of\n10000 10-Fold CVs")+
  ggtitle("N Staging", subtitle = "All pairwise p-values < 0.001")+
  scale_x_discrete(breaks = c(0, 1, 2),
                   labels = c("0\n(n = 82)",
                              "1\n(n = 82)",
                              "2\n(n = 82)"))


n_stage_plot

ggsave(n_stage_plot, filename = "n_stage_specific_plot.png", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")

ggsave(n_stage_plot, filename = "n_stage_specific_plot.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")
```

# M Staging for 4 predictor model
```{r m stage 4 predictor}
# Automated for all m stages

# Power analysis to determine how many samples for each group we need to detect a small effect size with 80% power at 0.05 significance level
power_analysis <- pwr.t.test(
  d = 0.2,
  sig.level = 0.05,
  power = 0.8,
  alternative = "two.sided"
)



# Extract the required sample size
required_sample_size <- ceiling(power_analysis$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")

# Predictors
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds


# Consolidate subtypes of m stage
scl_common_m_analysis_df <- scl_common %>%
  mutate(m.stage = case_when(
    m.stage %in% c("1a", "1b") ~ "1",  # Consolidate "1a" and "1b" into "1"
    TRUE ~ m.stage                     # Keep all other subtypes as is
  )) %>%
  filter(m.stage != "") %>%
  filter(m.stage != "x")


# Specify the unique m.stage values in the data
scl_common_m_analysis_df <- scl_common_m_analysis_df %>%
  filter(m.stage != "")
chemo_values <- unique(scl_common_m_analysis_df$m.stage)
chemo_values <- c("0", "1")

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = length(chemo_values) * num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a list to store c-index vectors
c_index_vectors <- list()

# Loop through m.stage values
for (chemo_value in chemo_values) {
  # Filter data for the current m.stage
  m_stage_df <- filter(scl_common_m_analysis_df, m.stage == chemo_value)
  
  # Generate matched tumor samples
  m_stage_df <- generate_matched_tumor_samples(data = m_stage_df, num_samples_to_generate = required_sample_size)
  
  # Create a directory for the current m.stage value
  dir.create(paste0("Outputs/m_stage_", chemo_value), showWarnings = FALSE)
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (iteration in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/m_stage_", chemo_value, "/random_seeds.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = m_stage_df,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[iteration] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  # Store the c-index vector in the list
  c_index_vectors[[as.character(chemo_value)]] <- c_index_vector
  
  # Save c-index vector to a CSV file
  write.csv(c_index_vector, file = paste0("Outputs/m_stage_", chemo_value, "/c_index_results.csv"))
  
  # Save the cox_df as an RDS file for future use
  saveRDS(m_stage_df, file = paste0("Outputs/m_stage_", chemo_value, "/cox_df.rds"))
  
  # Save the current m.stage value for the random seed file
  write.table(data.frame(m_stage = chemo_value), file = "Outputs/random_seeds.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
  
  # Calculate and print the mean c-index for the current m.stage value
  mean_c_index <- mean(c_index_vector)
  cat(paste("Mean C-Index for m.stage", chemo_value, ":", mean_c_index, "\n"))
}
```
# M staging plot
```{r m stage plot}
m_stage_0_df <- read.csv("Outputs/m_stage_0/c_index_results.csv")
m_stage_1_df <- read.csv("Outputs/m_stage_1/c_index_results.csv")

m_stages <- list(m_stage_0_df, m_stage_1_df)

for(x in 1:2){
  current_df <- m_stages[[x]]
  colnames(current_df) <- c("iteration", "c_index")
  current_df$m_stage <- rep(x = x - 1, times = nrow(current_df))
  m_stages[[x]] <- current_df
}

m_stages_df <-  bind_rows(m_stages) 
m_stages_df$m_stage <- factor(m_stages_df$m_stage, levels = c(0,1))

wilcox_result <- wilcox.test(c_index ~ m_stage, data = m_stages_df)
p_value <- wilcox_result$p.value
p_value_formatted <- format_p(p = p_value, stars = TRUE, stars_only = TRUE)

m_stage_plot <- ggplot(data = m_stages_df, mapping = aes(x = m_stage, y = c_index))+
  geom_violin()+
  geom_sina()+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14))+
  xlab("M Stage")+
  ylab("Mean C-index of\n10000 10-Fold CVs")+
  ggtitle("M Staging")+
  scale_x_discrete(breaks = c(0, 1),
                   labels = c("0\n(n = 394)",
                              "1\n(n = 394)"))+
  geom_signif(annotations = "***", xmin = 1, xmax = 2, y_position = 0.92, tip_length = 0, vjust = 0.5)


m_stage_plot

ggsave(m_stage_plot, filename = "m_stage_specific_plot.png", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")

ggsave(m_stage_plot, filename = "m_stage_specific_plot.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")
```

# Chemotherapy Analysis 4 gene predictor
```{r chemotherapy 4 predictor}
# Automated for all chemotherapy treatments

# Power analysis to determine how many samples for each group we need to detect a small effect size with 80% power at 0.05 significance level
power_analysis <- pwr.t.test(
  d = 0.2,
  sig.level = 0.05,
  power = 0.8,
  alternative = "two.sided"
)


# Extract the required sample size
required_sample_size <- ceiling(power_analysis$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")

# Predictors
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds


# Consolidate subtypes of m stage
scl_common_chemo_analysis_df <- scl_common %>%
  filter(chemotherapy != "")


# Specify the unique m.stage values in the data
chemo_values <- unique(scl_common_chemo_analysis_df$chemotherapy)
chemo_values <- c("No", "Yes")

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = length(chemo_values) * num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a list to store c-index vectors
c_index_vectors <- list()

# Loop through m.stage values
for (chemo_value in chemo_values) {
  # Filter data for the current m.stage
  chemo_stage_df <- filter(scl_common_chemo_analysis_df, chemotherapy == chemo_value)
  
  # Generate matched tumor samples
  chemo_stage_df <- generate_matched_tumor_samples(data = chemo_stage_df, num_samples_to_generate = required_sample_size)
  
  # Create a directory for the current m.stage value
  dir.create(paste0("Outputs/chemo_stage_", chemo_value), showWarnings = FALSE)
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (iteration in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/chemo_stage_", chemo_value, "/random_seeds.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = chemo_stage_df,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[iteration] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  # Store the c-index vector in the list
  c_index_vectors[[as.character(chemo_value)]] <- c_index_vector
  
  # Save c-index vector to a CSV file
  write.csv(c_index_vector, file = paste0("Outputs/chemo_stage_", chemo_value, "/c_index_results.csv"))
  
  # Save the cox_df as an RDS file for future use
  saveRDS(m_stage_df, file = paste0("Outputs/chemo_stage_", chemo_value, "/cox_df.rds"))
  
  # Calculate and print the mean c-index for the current m.stage value
  mean_c_index <- mean(c_index_vector)
  cat(paste("Mean C-Index for chemotherapy status", chemo_value, ":", mean_c_index, "\n"))
}
```

# Chemotherapy Analysis Plot
```{r chemotherapy plot plot}
chemo_no_df <- read.csv("Outputs/chemo_stage_No/c_index_results.csv")
chemo_no_df$chemo <- rep("no", nrow(chemo_no_df))
colnames(chemo_no_df) <- c("iteration", "c_index", "chemo")
chemo_yes_df <- read.csv("Outputs/chemo_stage_Yes/c_index_results.csv")
chemo_yes_df$chemo <- rep("yes", nrow(chemo_yes_df))
colnames(chemo_yes_df) <- c("iteration", "c_index", "chemo")

chemo_stages_df <-  bind_rows(chemo_no_df, chemo_yes_df) 
chemo_stages_df$chemo <- factor(chemo_stages_df$chemo, levels = c("yes","no"))

wilcox_result <- wilcox.test(c_index ~ chemo, data = chemo_stages_df)
p_value <- wilcox_result$p.value
p_value_formatted <- format_p(p = p_value, stars = TRUE, stars_only = TRUE)

chemo_stage_plot <- ggplot(data = chemo_stages_df, mapping = aes(x = chemo, y = c_index))+
  geom_violin()+
  geom_sina()+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14))+
  xlab("Chemotherapy")+
  ylab("Mean C-index of\n10000 10-Fold CVs")+
  ggtitle("Chemotherapy Status")+
  scale_x_discrete(breaks = c("yes", "no"),
                   labels = c("Yes\n(n = 394)",
                              "No\n(n = 394)"))+
  geom_signif(annotations = "***", xmin = 1, xmax = 2, y_position = 0.91, tip_length = 0, vjust = 0.5)


chemo_stage_plot

ggsave(chemo_stage_plot, filename = "chemo_stage_specific_plot.png", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")

ggsave(chemo_stage_plot, filename = "chemo_stage_specific_plot.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")
```
# Age analysis
```{r age 4 predictor}
# Automated for age split

# Power analysis to determine how many samples for each group we need to detect a small effect size with 80% power at 0.05 significance level
power_analysis <- pwr.t.test(
  d = 0.2,
  sig.level = 0.05,
  power = 0.8,
  alternative = "two.sided"
)

# Function to find the mode just out of curiosity
Modes <- function(x) {
  ux <- unique(x)
  tab <- tabulate(match(x, ux))
  ux[tab == max(tab)]
}

Modes(scl_common$age)

# Extract the required sample size
required_sample_size <- ceiling(power_analysis$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")

# Predictors
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds


# Consolidate age range into two values (old and young based on if they are above ("old") or below ("young") the median age of the dataset)
scl_common_age_analysis_df <- scl_common %>%
  mutate(age_cat = ifelse(age > median(age), "old", "young"))

# Specify the unique m.stage values in the data
age_values <- unique(scl_common_age_analysis_df$age_cat)
age_values <- c("young", "old")

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = length(age_values) * num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a list to store c-index vectors
c_index_vectors <- list()

# Loop through m.stage values
for (age_value in age_values) {
  age_stage_df <- filter(scl_common_age_analysis_df, age_cat == age_value)
  
  # Generate matched tumor samples
  age_stage_df <- generate_matched_tumor_samples(data = age_stage_df, num_samples_to_generate = required_sample_size)
  
  # Create a directory for the current age value
  dir.create(paste0("Outputs/age_stage_", age_value), showWarnings = FALSE)
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (iteration in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/age_stage_", age_value, "/random_seeds.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = age_stage_df,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[iteration] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  # Store the c-index vector in the list
  c_index_vectors[[as.character(age_value)]] <- c_index_vector
  
  # Save c-index vector to a CSV file
  write.csv(c_index_vector, file = paste0("Outputs/age_stage_", age_value, "/c_index_results.csv"))
  
  # Save the cox_df as an RDS file for future use
  saveRDS(age_stage_df, file = paste0("Outputs/age_stage_", age_value, "/cox_df.rds"))
  
  # Calculate and print the mean c-index for the current m.stage value
  mean_c_index <- mean(c_index_vector)
  cat(paste("Mean C-Index for age status", age_value, ":", mean_c_index, "\n"))
}
```
# Age Plot
```{r age plot}
chemo_no_df <- read.csv("Outputs/age_stage_old/c_index_results.csv")
chemo_no_df$age <- rep("old", nrow(chemo_no_df))
colnames(chemo_no_df) <- c("iteration", "c_index", "age")
chemo_yes_df <- read.csv("Outputs/age_stage_young/c_index_results.csv")
chemo_yes_df$age <- rep("young", nrow(chemo_yes_df))
colnames(chemo_yes_df) <- c("iteration", "c_index", "age")

chemo_stages_df <-  bind_rows(chemo_no_df, chemo_yes_df) 
chemo_stages_df$age <- factor(chemo_stages_df$age, levels = c("young","old"))

wilcox_result <- wilcox.test(c_index ~ age, data = chemo_stages_df)
p_value <- wilcox_result$p.value
p_value_formatted <- format_p(p = p_value, stars = TRUE, stars_only = TRUE)

chemo_stage_plot <- ggplot(data = chemo_stages_df, mapping = aes(x = age, y = c_index))+
  geom_violin()+
  geom_sina()+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14))+
  xlab("Age")+
  ylab("Mean C-index of\n10000 10-Fold CVs")+
  ggtitle("Age")+
  scale_x_discrete(breaks = c("young", "old"),
                   labels = c("Young\n(n = 394)",
                              "Old\n(n = 394)"))+
  geom_signif(annotations = "***", xmin = 1, xmax = 2, y_position = 0.76, tip_length = 0, vjust = 0.5)


chemo_stage_plot

ggsave(chemo_stage_plot, filename = "age_specific_plot.png", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")

ggsave(chemo_stage_plot, filename = "age_specific_plot.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")
```
# Smoker analysis
```{r smoker 4 predictor}
# Automated for smoker status

# Power analysis to determine how many samples for each group we need to detect a small effect size with 80% power at 0.05 significance level
power_analysis <- pwr.t.test(
  d = 0.2,
  sig.level = 0.05,
  power = 0.8,
  alternative = "two.sided"
)


# Extract the required sample size
required_sample_size <- ceiling(power_analysis$n)

# Print the results
cat("Required Sample Size:", required_sample_size, "\n")

# Predictors
cox_preds <- data.frame(preds = c("tfrc", "fam83f", "gng13", "dlk1"))
rownames(cox_preds) <- cox_preds$preds


scl_common_smoker_analysis_df <- scl_common %>%
  filter(smoker != "")


# Specify the unique m.stage values in the data
chemo_values <- unique(scl_common_smoker_analysis_df$smoker)
chemo_values <- c(0, 1)

# Number of iterations
num_iterations <- 10000

# Create a progress bar
pb <- progress_bar$new(total = length(chemo_values) * num_iterations, format = "[:bar] :percent :current/:total :eta")

# Initialize a list to store c-index vectors
c_index_vectors <- list()

# Loop through m.stage values
for (chemo_value in chemo_values) {
  # Filter data for the current m.stage
  chemo_stage_df <- filter(scl_common_smoker_analysis_df, smoker == chemo_value)
  
  # Generate matched tumor samples
  chemo_stage_df <- generate_matched_tumor_samples(data = chemo_stage_df, num_samples_to_generate = required_sample_size)
  
  # Create a directory for the current m.stage value
  dir.create(paste0("Outputs/smoker_", chemo_value), showWarnings = FALSE)
  
  # Initialize a vector to store c-index values
  c_index_vector <- numeric(num_iterations)
  
  # Loop through iterations
  for (iteration in 1:num_iterations) {
    # Generate a random seed for each iteration
    random_seed <- sample.int(10^6, 1)
    
    # Append the random seed to the CSV file
    write.table(data.frame(random_seed), file = paste0("Outputs/smoker_", chemo_value, "/random_seeds.csv"), append = TRUE, row.names = FALSE, col.names = FALSE)
    
    # Call cox_model_fitter with the random seed and other parameters
    current_cox <- cox_model_fitter(
      my_seed = random_seed,
      my_alpha = 0,
      progress_free = FALSE,
      sim_testing = TRUE,
      cox_predictors = cox_preds,
      cox_df = chemo_stage_df,
      gene_num = 4,
      save_coefs = FALSE,
      tumor_stage = FALSE,
      tumor_n = FALSE,
      tumor_m = FALSE,
      calc_auc = FALSE,
      cat_preds = FALSE,
      n_folds = 10,
      my_folds = NULL
    )
    
    # Extract the c-index at lambda.min value from CV results
    min_lambda <- current_cox$CV$lambda.min
    min_lambda_index <- which(current_cox$CV$lambda == current_cox$CV$lambda.min)
    c_index <- current_cox$CV$cvm[min_lambda_index]
    
    # Store the c-index value in the vector
    c_index_vector[iteration] <- c_index
    
    # Update the progress bar
    pb$tick()
  }
  
  # Store the c-index vector in the list
  c_index_vectors[[as.character(chemo_value)]] <- c_index_vector
  
  # Save c-index vector to a CSV file
  write.csv(c_index_vector, file = paste0("Outputs/smoker_", chemo_value, "/c_index_results.csv"))
  
  # Save the cox_df as an RDS file for future use
  saveRDS(m_stage_df, file = paste0("Outputs/smoker_", chemo_value, "/cox_df.rds"))
  
  # Calculate and print the mean c-index for the current m.stage value
  mean_c_index <- mean(c_index_vector)
  cat(paste("Mean C-Index for smoker status", chemo_value, ":", mean_c_index, "\n"))
}
```

# Smoker Plot
```{r smoker plot}
chemo_no_df <- read.csv("Outputs/smoker_0/c_index_results.csv")
chemo_no_df$age <- rep("no", nrow(chemo_no_df))
colnames(chemo_no_df) <- c("iteration", "c_index", "smoking_status")
chemo_yes_df <- read.csv("Outputs/smoker_1/c_index_results.csv")
chemo_yes_df$age <- rep("yes", nrow(chemo_yes_df))
colnames(chemo_yes_df) <- c("iteration", "c_index", "smoking_status")

chemo_stages_df <-  bind_rows(chemo_no_df, chemo_yes_df) 
chemo_stages_df$smoking_status <- factor(chemo_stages_df$smoking_status, levels = c("no","yes"))

wilcox_result <- wilcox.test(c_index ~ smoking_status, data = chemo_stages_df)
p_value <- wilcox_result$p.value
p_value_formatted <- format_p(p = p_value, stars = TRUE, stars_only = TRUE)

chemo_stage_plot <- ggplot(data = chemo_stages_df, mapping = aes(x = smoking_status, y = c_index))+
  geom_violin()+
  geom_sina()+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 16, face = "bold"),
        axis.text = element_text(size = 14))+
  xlab("Smoker")+
  ylab("Mean C-index of\n10000 10-Fold CVs")+
  ggtitle("Smoker")+
  scale_x_discrete(breaks = c("no", "yes"),
                   labels = c("No\n(n = 394)",
                              "Yes\n(n = 394)"))+
  geom_signif(annotations = "***", xmin = 1, xmax = 2, y_position = 0.83, tip_length = 0, vjust = 0.5)


chemo_stage_plot

ggsave(chemo_stage_plot, filename = "smoker_plot.png", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")

ggsave(chemo_stage_plot, filename = "smoker_plot.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 6, width = 6, bg = "white", units = "in")
```


# Reactome Pathway enrichment 4 predictor model
```{r reactome pathway enrichment for 4 genes}
reactome_df <- read.csv("Figures/panels/Reactome_2022_table.txt", sep = "\t") 
reactome_df <- reactome_df %>%
  filter(Adjusted.P.value < 0.05) %>%
  select(Term, P.value, Adjusted.P.value, Combined.Score) %>%
  slice_head(n = 5) %>%
  mutate(Term = str_replace_all(Term, "R-HSA-\\d+", ""))

reactome_plot <- ggplot(data = reactome_df, aes(x = reorder(Term, Combined.Score, decreasing = FALSE), y = Combined.Score, fill = Combined.Score))+
  geom_col(width = 0.5, fill = "skyblue")+
  coord_flip()+
  xlab("Term")+
  ylab("Combined Score")+
  scale_y_continuous(expand = c(0,0))+
  ggtitle("Reactome")+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 24, hjust = 0.5, face = "bold"),
        axis.title = element_text(size = 22, face = "bold"),
        axis.text = element_text(size = 18),
        legend.position = "none")+
  guides(fill = guide_colorbar(barwidth = 15))

ggsave(reactome_plot, filename = "reactome_pathways.png", path = "Figures/panels/", dpi = 600, height = 10, width = 10, bg = "white", units = "in")

ggsave(reactome_plot, filename = "reactome_pathways.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 10, width = 10, bg = "white", units = "in")
```

# WikiPathways Enrichment 4 Predictor Model
```{r wikipath pathways}
wikipath_df <- read.csv("Figures/panels/WikiPathway_2023_Human_table.txt", sep = "\t")
wikipath_df <- wikipath_df %>%
  filter(Adjusted.P.value < 0.05) %>%
  select(Term, P.value, Adjusted.P.value, Combined.Score) %>%
  slice_head(n = 5) %>%
  mutate(Term = str_replace_all(Term, "WP\\d+", ""))

wikipath_plot <- ggplot(data = wikipath_df, aes(x = reorder(Term, Combined.Score, decreasing = FALSE), y = Combined.Score, fill = Combined.Score))+
  geom_col(width = 0.5, fill = "skyblue")+
  coord_flip()+
  scale_y_continuous(expand = c(0,0))+
  xlab("Term")+
  ylab("Combined Score")+
  ggtitle("WikiPathways")+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 24, hjust = 0.5, face = "bold"),
        axis.title = element_text(size = 22, face = "bold"),
        axis.text = element_text(size = 18),
        legend.position = "none")+
  guides(fill = guide_colorbar(barwidth = 15))

ggsave(wikipath_plot, filename = "wikipathways_pathways.png", path = "Figures/panels/", dpi = 600, height = 18, width = 18, bg = "white", units = "in")

ggsave(wikipath_plot, filename = "wikipathways_pathways.svg", device = "svg", path = "Figures/panels/", dpi = 600, height = 18, width = 18, bg = "white", units = "in")
```


# Random Forset
```{r random forest}
scl_common_rf <- scl_common %>%
  select(-patient.id, -age, -sex, -smoker, -n.stage, -m.stage, -uicc.tumor.stage, -chemotherapy, -neoadjuvant.chemotherapy, -acquisition.method, -radiation)

num_iterations <- 1
c_index_values <- numeric(num_iterations)
for (i in 1:num_iterations) {
  current_seed <- as.integer(Sys.time())
  set.seed(current_seed)
  sclc_obj <- rfsrc(Surv(time, vital.status) ~ ., data = scl_common_rf)
  
  # Getting c-index from prediction (c-index = 0.4060543)
  current_cindex <- get.cindex(time = scl_common_rf$time, censoring = scl_common_rf$vital.status, predicted = sclc_obj$predicted.oob)
  c_index_values[i] <- current_cindex
}

write.csv(c_index_values, "Outputs/random_forest/rf_cindex_values_for_initial_training_data.csv")
```

# Random Forset Gene Optimization
```{r random forest multithreading}
library(foreach)
library(doParallel)

# Load data
mirna_mad_sde_optimized <- readRDS("Outputs/Optimization_mirna_mad_sde_1_alpha.rds")

# Set row names for each dataframe in the list
mirna_mad_sde_optimized <- lapply(mirna_mad_sde_optimized, function(df) {
  rownames(df) <- tolower(rownames(df))
  return(df)
})

scl_common_rf <- scl_common %>% 
  select(-patient.id, -age, -sex, -smoker, -n.stage, -m.stage, -uicc.tumor.stage, -chemotherapy, -neoadjuvant.chemotherapy, -acquisition.method, -radiation)

gene_sizes <- seq(2, 8, 1)



# Set up parallel backend to use a limited number of processors
registerDoParallel(cores = 4) # Adjust based on your system

foreach(gs = gene_sizes, .combine = rbind) %dopar% {
  foreach(i = seq_along(mirna_mad_sde_optimized), .combine = rbind) %dopar% {
    current_genes <- head(rownames(mirna_mad_sde_optimized[[i]]), n = gs)
    current_genes <- intersect(current_genes, colnames(scl_common_rf))
    
    if (length(current_genes) > 0) {
      current_genes_formula <- paste(current_genes, collapse = " + ")
      rf_formula <- as.formula(paste("Surv(time, vital.status) ~", current_genes_formula))
      sclc_obj <- rfsrc(rf_formula, data = scl_common_rf)
      
      current_cindex <- get.cindex(time = scl_common_rf$time, censoring = scl_common_rf$vital.status, predicted = sclc_obj$predicted.oob)
      
      # Save individual iteration results
      c_index_df <- data.frame(gene_size = gs, c_index = round(current_cindex, digits = 4), genes = paste(current_genes, collapse = ","), random_seed = as.integer(Sys.time()))
      write.csv(c_index_df, paste0("Outputs/random_forest_gene_optimization/random_forest_gene_optimization_gs_", gs, "_index_", i, ".csv"))
    }
  }
}

# Stop parallel backend
stopImplicitCluster()
```

# Random Forest Gene Optimization Plot
```{r random forest gene optimization plot}
# Function to read and bind all CSV files in a folder into a single dataframe
read_and_bind_csv_files_in_folder <- function(folder_path, pattern = ".csv$") {
  # Get a list of all CSV files in the folder that match the pattern
  file_list <- list.files(path = folder_path, pattern = pattern, full.names = TRUE)
  
  # Initialize an empty list to store individual data frames
  df_list <- list()
  
  # Loop through each file path in the list and read the CSV file
  for (file_path in file_list) {
    df <- read.csv(file_path, header = TRUE, stringsAsFactors = FALSE, row.names = 1)
    df_list <- append(df_list, list(df))
  }
  
  # Bind all data frames in the list row-wise into a single dataframe
  combined_df <- do.call(rbind, df_list)
  
  return(combined_df)
}

rf_df <- read_and_bind_csv_files_in_folder("Outputs/random_forest_gene_optimization/")

rf_df_sub <- rf_df %>%
  filter(gene_size == 2)


max_rf_df <- rf_df_sub[which.max(rf_df_sub$c_index),]
max_rf_df <- max_rf_df %>%
  select(-random_seed, -genes)

initial_rf_df <- data.frame(gene_size = NA, c_index = 0.4060543)

all_rf_df <- bind_rows(initial_rf_df, max_rf_df)
all_rf_df$model <- rep("random forest", times = 2)
all_rf_df$method <- c("non-optimized", "optimized")

p1 <- ggplot(data = all_rf_df, aes(x = method, y = c_index)) +
  geom_col(fill = "skyblue", width = 0.3) +
  xlab("Method") +
  ylab("C-index") +
  scale_y_continuous(expand = c(0, 0)) +
  coord_cartesian(ylim = c(0.4, 0.80))+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 22),
        axis.title = element_text(face = "bold", size = 22),
        axis.text = element_text(size = 20)) +
  ggtitle("Random Forest")
```

# DeepSurv
```{r deepsurv}
scl_common_ds <- scl_common %>%
  select(-patient.id, -age, -sex, -smoker, -n.stage, -m.stage, -uicc.tumor.stage, -chemotherapy, -neoadjuvant.chemotherapy, -acquisition.method, -radiation)
scl_common_ds <- scl_common_ds %>%
  select(time,vital.status, tfrc, fam83f, gng13, dlk1)
# sclc_deepsurv <- deepsurv(formula = Surv(time, vital.status)~ tfrc+fam83f, data = scl_common_ds)
```

# 10-fold CV DeepSurv
```{r 10 fold cv DeepSurv}
library(caret)

# Set the number of folds
num_folds <- 10

# Initialize an empty vector to store c-index values
c_index_values <- numeric(num_folds)

# Create a list of indices for 10-fold cross-validation
cv_indices <- createFolds(1:nrow(scl_common_ds), k = num_folds)

# Perform 10-fold cross-validation
for (fold in 1:num_folds) {
  # Split the data into training and testing sets for this fold
  train_indices <- unlist(cv_indices[-fold])
  test_indices <- cv_indices[[fold]]
  
  # Fit the deepSurv model on the training data
  fit <- deepsurv(formula = Surv(time, vital.status)~ tfrc+gng13+fam83f+dlk1, data = scl_common_ds[train_indices,])
  
  # Predict the risk scores on the test data
  my_newdata <- scl_common_ds%>%
    select(-time, -vital.status)
  my_newdata <- my_newdata %>%
    select(tfrc, gng13, fam83f, dlk1)
  
  p <- predict(fit, type = "risk", newdata = my_newdata[test_indices, ])
  
  # Calculate the concordance index for this fold
  c_index <- rcorr.cens(p, scl_common_ds[test_indices, "time"])
  
  # Store the c-index value for this fold
  c_index_values[fold] <- unname(c_index[1])
  
  # Print the c-index for this fold to the console
  cat("Fold", fold, "C-Index:", c_index, "\n")
}

# Calculate and print the mean c-index across all folds
mean_c_index <- mean(c_index_values)
cat("Mean C-Index:", mean_c_index, "\n")

```

# 10000 10-fold CVs
```{r 10000 10 fold cv DeepSurv}
# Number of iterations
num_iterations <- 10000
set.seed(1688405764)

# Set the number of folds
num_folds <- 10

# Create a progress bar
pb <- progress_bar$new(
  format = "[:bar] :percent ETA: :eta",
  total = num_iterations
)

for (i in 1:num_iterations){
  # Initialize an empty vector to store c-index values
  c_index_values <- numeric(num_folds)
  
  # Create a list of indices for 10-fold cross-validation
  cv_indices <- createFolds(1:nrow(scl_common_ds), k = num_folds)
  
  # Perform 10-fold cross-validation
  for (fold in 1:num_folds) {
    # Split the data into training and testing sets for this fold
    train_indices <- unlist(cv_indices[-fold])
    test_indices <- cv_indices[[fold]]
    
    # Fit the deepSurv model on the training data
    fit <- deepsurv(formula = Surv(time, vital.status)~ tfrc+gng13+fam83f+dlk1, data = scl_common_ds[train_indices,])
    
    # Predict the risk scores on the test data
    my_newdata <- scl_common_ds%>%
      select(-time, -vital.status)
    my_newdata <- my_newdata %>%
      select(tfrc, gng13, fam83f, dlk1)
    
    p <- predict(fit, type = "risk", newdata = my_newdata[test_indices, ])
    
    # Calculate the concordance index for this fold
    c_index <- rcorr.cens(p, scl_common_ds[test_indices, "time"])
    
    # Store the c-index value for this fold
    c_index_values[fold] <- unname(c_index[1])
    
    # Print the c-index for this fold to the console
    # cat("Fold", fold, "C-Index:", c_index, "\n")
  }
  
  # Calculate and print the mean c-index across all folds
  mean_c_index <- mean(c_index_values)
  
  # Append the mean c-index to the CSV file
  mean_cindex_data <- data.frame(mean_c_index, i)
  write.table(mean_cindex_data, file = "Outputs/deepsurv/mean_10_fold_cv_deep_surv_mirms_sig_used_10000_iters.csv",row.names = FALSE, append = TRUE, col.names = FALSE, sep = ",")
  
  # Append the c-index values to the CSV file
  cindex_data <- data.frame(c_index_values)
  write.table(cindex_data, file = "Outputs/deepsurv/10_fold_cv_deep_surv_mirms_sig_used_10000_iters.csv", append = TRUE, row.names = FALSE, col.names = FALSE, sep = ",")

  
  # cat("Mean C-Index:", mean_c_index, "for iteration ", i, "\n")
  pb$tick()
}

# Close pb
pb$terminate()
```

# Now using the gene prioritization and then taking the top 20 genes from the combined list to optimize for the deep learning methods
# DeepSurv optimization first
```{r optimal gene number for deepsurv method}
mirna_mad_sde_optimized <- readRDS("Outputs/Optimization_mirna_mad_sde_1_alpha.rds")
scl_common_ds <- scl_common %>%
  select(-patient.id, -age, -smoker, -sex, -n.stage, -m.stage, -uicc.tumor.stage, -chemotherapy, -neoadjuvant.chemotherapy, -radiation, -acquisition.method)

# gene_sizes <- seq(2, 8, 1)

# More expansive search space of genes from the prioritization space
gene_sizes <- c(20, 40, 80, 200)
counter <- 1
num_iterations <- 1
num_folds <- 10

# Create an outer progress bar
outer_pb <- progress_bar$new(
  format = "[:bar] :percent ETA: :eta",
  total = 118
)

# Set row names for each dataframe in the list
mirna_mad_sde_optimized <- lapply(mirna_mad_sde_optimized, function(df) {
  rownames(df) <- tolower(rownames(df))
  return(df)
})

# Remove specific entry because it continually crashes the grid search
mirna_mad_sde_optimized[[100]] <- NULL
mirna_mad_sde_optimized[[109]] <- NULL
mirna_mad_sde_optimized[[110]] <- NULL

for (ms in 1:length(mirna_mad_sde_optimized)) {
  for (gs in gene_sizes){
    for (i in 1:num_iterations){
      current_genes <- head(rownames(mirna_mad_sde_optimized[[ms]]), n = gs)
      current_genes <- intersect(current_genes, colnames(scl_common_ds))
      current_genes_formula <- paste(tolower(head(current_genes, n = gs)), collapse = " + ")
      
      # Initialize an empty vector to store c-index values
      c_index_values <- numeric(num_folds)
      
      # Create a list of indices for 10-fold cross-validation
      cv_indices <- createFolds(1:nrow(scl_common_ds), k = num_folds)
      
      # Perform 10-fold cross-validation
      for (fold in 1:num_folds) {
        
        # Split the data into training and testing sets for this fold
        train_indices <- unlist(cv_indices[-fold])
        test_indices <- cv_indices[[fold]]
        
        # Fit the deepSurv model on the training data
        deepsurv_formula <- as.formula(paste("Surv(time, vital.status) ~", current_genes_formula))
        
        # Check if there are no predictors
        if (length(attr(terms(deepsurv_formula), "term.labels")) == 1 && 
            all(grepl("Surv", attr(terms(deepsurv_formula), "term.labels")))) {
          print("There are no predictors in the formula.")
          next
        } else {
          # print("There are predictors in the formula.")
          
          fit <- deepsurv(formula = deepsurv_formula, data = scl_common_ds[train_indices,])
          
          # Predict the risk scores on the test data
          my_newdata <- scl_common_ds %>%
            select(-time, -vital.status)
          my_newdata <- my_newdata %>%
            select(all_of(current_genes))
          
          p <- predict(fit, type = "risk", newdata = my_newdata[test_indices, ])
          
          # Calculate the concordance index for this fold
          c_index <- rcorr.cens(p, scl_common_ds[test_indices, "time"])
          
          # Store the c-index value for this fold
          c_index_values[fold] <- unname(c_index[1])
        }
        
        # Calculate and print the mean c-index across all folds
        mean_c_index <- mean(c_index_values)
        
        # Append the mean c-index to the CSV file
        # Concatenate the elements with commas
        gene_string <- paste(current_genes, collapse = ",")
        mean_cindex_data <- data.frame(mean_c_index, i, gene_string)
        c_index_df <- data.frame(gene_size = gs, c_index = round(mean_c_index, digits = 4), genes = gene_string, random_seed = as.integer(Sys.time()))
        write.table(mean_cindex_data, file = "Outputs/deepsurv/mean_10_fold_cv_deep_surv_gene_optimization_1_iters_wider_search_space.csv",row.names = FALSE, append = TRUE, col.names = FALSE, sep = ",")
        
        # Append the c-index values to the CSV file
        cindex_data <- data.frame(c_index_values)
        write.table(cindex_data, file = "Outputs/deepsurv/10_fold_cv_deep_surv_gene_optimization_1_iter_wider_search_space.csv", append = TRUE, row.names = FALSE, col.names = FALSE, sep = ",")
      }
      
    }
  }
  # Update progress bar
  outer_pb$tick()
}
}
# Close the progress bar
outer_pb$terminate()
```

# New Figure 5 data
```{r new figure 5 data}
# Reading in the file
deepsurv_df <- read_csv("Outputs/deepsurv/mean_10_fold_cv_deep_surv_gene_optimization_1_iters.csv", col_names = FALSE)
colnames(deepsurv_df) <- c("mean_cindex", "iteration", "genes")
max_deepsurv_df <- deepsurv_df[which.max(deepsurv_df$mean_cindex),]
max_deepsurv_df <- max_deepsurv_df %>%
  select(-genes, -iteration)
max_deepsurv_df$method <- "DS"


mirms_max <- data.frame(mean_cindex = 0.7691000, method = "miRMS")
random_cindex <- data.frame(mean_cindex = 0.6061160, method = "RG")
random_forest_max <- data.frame(mean_cindex = 0.7046, method = "RF")

# deepSurv full df
full_deepsurv_df <- bind_rows(max_deepsurv_df, random_forest_max, mirms_max, random_cindex)
full_deepsurv_df$method <- factor(full_deepsurv_df$method, levels = c("DS", "RF", "RG", "miRMS"))
```


# New figure 5 plot
```{r new figure 5 plot}
p2 <- ggplot(data = full_deepsurv_df, aes(x = method, y = mean_cindex)) +
 geom_col(fill = "skyblue", width = 0.3)+
  xlab("Method") +
  ylab("Optimized C-index") +
  coord_cartesian(ylim = c(0.4, 0.80))+
  scale_y_continuous(expand = c(0,0))+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 22),
        axis.title = element_text(face = "bold", size = 22),
        axis.text = element_text(size = 20)) +
  ggtitle("Optimized Methods")

# PNG
ggsave(p2, filename = "Figures/finished_figures/figure5_new_version.png", device = "png", width = 4, height = 4, units = "in", dpi = 600)

# SVG
ggsave(p2, filename = "Figures/finished_figures/figure5_new_version.svg", device = "svg", width = 4, height = 4, units = "in", dpi = 600)
```

# Table 1
```{r table1}
# Load the data
data <- read.csv("Outputs/scl_common.csv", stringsAsFactors = FALSE)

data <- data %>%
  mutate(age = ifelse(age > 65, "Old", "Young")) %>%
  select(-patient.id, -time, -neoadjuvant.chemotherapy, -acquisition.method)

data <- data %>%
  mutate(uicc.tumor.stage = case_when(
    str_detect(uicc.tumor.stage, "^I[ab]*$|^IB$") ~ "I",
    str_detect(uicc.tumor.stage, "^II[ab]*$") ~ "II",
    str_detect(uicc.tumor.stage, "^III[ab]*$") ~ "III",
    str_detect(uicc.tumor.stage, "^IV$") ~ "IV",
    TRUE ~ as.character(uicc.tumor.stage) # Keep the original value if no match
  )) %>%
  rename("tumor.stage" = uicc.tumor.stage)


data <- data %>%
  mutate(m.stage = case_when(
    str_detect(m.stage, "^1[ab]*$") ~ "1",
    TRUE ~ as.character(m.stage) # Keep the original value if no match
  ))


data <- data %>%
  mutate(m.stage = case_when(
    str_detect(m.stage, "x") ~ "X",
    TRUE ~ as.character(m.stage) # Keep the original value if no match
  ))

data <- data %>%
  mutate(smoker = ifelse(smoker == 1, "Current", "Former"),
         vital.status = ifelse(vital.status == 1, "Deceased", "Alive"))

# Assuming the first 9 columns are metadata and converting them to character
metadata <- data[, 1:9] %>%
  mutate(across(everything(), as.character))

# Reshape the data to a long format
metadata_long <- metadata %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "value")

# Count the unique values for each metadata variable
metadata_counts <- metadata_long %>%
  group_by(variable) %>%
  filter(value != "" & !is.na(value)) %>%
  count(value, name = "count") %>%
  ungroup()

metadata_counts <- metadata_counts %>%
  mutate(group = str_remove(variable, "[:punct:].*|[:digit:].*")) %>%
  arrange(group, variable) # Ensure the data is sorted by group then by variable

metadata_counts <- metadata_counts %>%
  select(-variable)

half <- nrow(metadata_counts) %/% 2
first_half <- metadata_counts[1:half, ]
second_half <- metadata_counts[(half + 1):nrow(metadata_counts), ]


# Create the gt table
gt_table <- gt(metadata_counts) %>%
  tab_header(
    title = md("**Bulk RNA-seq**"),
    subtitle = md("Modified from George et al.")
  ) %>%
  cols_label(
    value = "",
    count = md("*n*")
  ) %>%
  tab_row_group(
    label = "Age",
    rows = 1:2
  ) %>%
  tab_row_group(
    label = "Chemotherapy",
    rows = 3:4
  ) %>%
  tab_row_group(
    label = "M Staging",
    rows = 5:7
  ) %>%
  tab_row_group(
    label = "N Staging",
    rows = 8:12
  )%>%
  tab_row_group(
    label = "Radiation",
    rows = 13:14
  )%>%
  tab_row_group(
    label = "Sex",
    rows = 15:16
  )%>%
  tab_row_group(
    label = "Smoker",
    rows = 17:18
  )%>%
  tab_row_group(
    label = "Tumor Stage",
    rows = 19:22
  )%>%
  tab_row_group(
    label = "Vital Status",
    rows = 23:24
  )%>%
    tab_options(
    row_group.background.color = "gray",
    row_group.font.size = "larger",
    row_group.font.weight = "bold"
  )
  
# Print the gt table
print(gt_table)


# First half of gt table
gt_table1 <- gt(first_half) %>%
  tab_header(
    title = md("**Bulk RNA-seq**"),
    subtitle = md("Modified from George et al.")
  ) %>%
  cols_label(
    value = "",
    count = md("*n*")
  ) %>%
  tab_row_group(
    label = "Age",
    rows = 1:2
  ) %>%
  tab_row_group(
    label = "Chemotherapy",
    rows = 3:4
  ) %>%
  tab_row_group(
    label = "M Staging",
    rows = 5:7
  ) %>%
  tab_row_group(
    label = "N Staging",
    rows = 8:12
  )%>%
    tab_options(
    row_group.background.color = "gray",
    row_group.font.size = "larger",
    row_group.font.weight = "bold"
  )



# Second half of gt table
gt_table2 <- gt(second_half) %>%
  tab_header(
    title = md("**Bulk RNA-seq**"),
    subtitle = md("Modified from George et al.")
  ) %>%
  cols_label(
    value = "",
    count = md("*n*")
  ) %>%
  tab_row_group(
    label = "Chemotherapy",
    rows = 1:2
  ) %>%
  tab_row_group(
    label = "Sex",
    rows = 3:4
  ) %>%
  tab_row_group(
    label = "Smoker",
    rows = 5:6
  ) %>%
  tab_row_group(
    label = "Tumor Staging",
    rows = 7:10
  )%>%
  tab_row_group(
    label = "Vital Status",
    rows = 11:12
  )%>%
    tab_options(
    row_group.background.color = "gray",
    row_group.font.size = "larger",
    row_group.font.weight = "bold"
  )



# Saving the tables
gtsave(gt_table, "Outputs/patient_characteristics_counts.png")
gtsave(gt_table1, "Outputs/patient_characteristics_counts_first_half_bulk.png")
gtsave(gt_table2, "Outputs/patient_characteristics_counts_second_half_bulk.png")
```

# Building a model from just smoking status
```{r smoker only model}
smoke_mod <- coxph(Surv(time,vital.status)~smoker, data = scl_common) # C-index: 0.522  (se = 0.041)
chemo_mod <- coxph(Surv(time,vital.status)~chemotherapy, data = scl_common) # C-index: 0.576  (se = 0.041)
m_mod_base <- coxph(Surv(time,vital.status)~m.stage, data = scl_common) # C-index: 0.595  (se = 0.035)
scl_common_m_simp <- scl_common |>
  # Recode the tumor values
  mutate(m_stage_recode = case_when(
    m.stage == "0" ~ 0,
    m.stage %in% c("1", "1a", "1b", "x") ~ 1,
    TRUE ~ NA_real_  # Handle unexpected values if needed
  ))

m_mod_simp <- coxph(Surv(time,vital.status)~m_stage_recode, data = scl_common_m_simp) # C-index: 0.586  (se = 0.033)
tumor_mod_base <- coxph(Surv(time,vital.status)~uicc.tumor.stage, data = scl_common) # C-index: 0.648  (se = 0.05)

scl_common <- scl_common |>
  # Recode the tumor values
  mutate(uicc_stage_recode = case_when(
    uicc.tumor.stage == "0" ~ 0,
    uicc.tumor.stage %in% c( "I", "Ia", "Ib", "IB") ~ 1,
    uicc.tumor.stage %in% c( "II", "IIa", "IIb") ~ 2,
    uicc.tumor.stage %in% c( "IIIa", "IIIb") ~ 3,
    uicc.tumor.stage %in% c( "IV") ~ 4,
    TRUE ~ NA_real_  # Handle unexpected values if needed
  ))

scl_common$uicc_stage_recode <- as.factor(scl_common$uicc_stage_recode)

tumor_mod_simp <- coxph(Surv(time,vital.status)~uicc_stage_recode, data = scl_common) # C-index: 0.614  (se = 0.045)


scl_common <- scl_common |>
  mutate(age = as.numeric(age)) |>
  # Recode the tumor values
  mutate(age_recode = if_else(age > mean(age), "old", "young"))
  ))

age_mod_bin <- coxph(Surv(time,vital.status)~age_recode, data = scl_common) # C-index: 0.504  (se = 0.041)


# Now creating 4 bins based on the range of ages of the dataset
# Create age labels
scl_common <- scl_common |>
  mutate(age_group = cut(
    age,
    breaks = c(47, 56, 65, 74, 83),  # Define the break points
    labels = c("47-55", "56-64", "65-73", "74-83"),  # Define the labels
    right = TRUE,  # Include the rightmost value in the interval
    include.lowest = TRUE  # Include the lowest value in the interval
  ))

age_mod_quartiles <- coxph(Surv(time,vital.status)~age_group, data = scl_common) # C-index: 0.575  (se = 0.042)

n_stage_base <- coxph(Surv(time,vital.status)~n.stage, data = scl_common) # C-index: 0.59  (se = 0.043)

scl_common <- scl_common |>
  # Recode the tumor values
  mutate(n_stage_recode = case_when(
    n.stage == "0" ~ 0,
    n.stage %in% c( "I", "Ia", "Ib", "IB") ~ 1,
    n.stage %in% c( "II", "IIa", "IIb") ~ 2,
    n.stage %in% c( "IIIa", "IIIb") ~ 3,
    n.stage %in% c( "IV") ~ 4,
    TRUE ~ NA_real_  # Handle unexpected values if needed
  ))

```

